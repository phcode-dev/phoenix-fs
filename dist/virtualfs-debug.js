(() => {
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequirefc80"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequirefc80"] = parcelRequire;
}
parcelRequire.register("7eWHE", function(module, exports) {
"use strict";









// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var $5457606f75a3fd9d$var$modules = [
    (parcelRequire("71gdd")),
    (parcelRequire("Bpdbx")),
    (parcelRequire("9Znyc")),
    (parcelRequire("68lqB")),
    (parcelRequire("kE7ef")),
    (parcelRequire("gqgPN")),
    (parcelRequire("klRRI")),
    (parcelRequire("9Caog")),
    (parcelRequire("9Wtr1"))
];
// Put all encoding/alias/codec definitions to single object and export it.
for(var $5457606f75a3fd9d$var$i = 0; $5457606f75a3fd9d$var$i < $5457606f75a3fd9d$var$modules.length; $5457606f75a3fd9d$var$i++){
    var $5457606f75a3fd9d$var$module = $5457606f75a3fd9d$var$modules[$5457606f75a3fd9d$var$i];
    for(var $5457606f75a3fd9d$var$enc in $5457606f75a3fd9d$var$module)if (Object.prototype.hasOwnProperty.call($5457606f75a3fd9d$var$module, $5457606f75a3fd9d$var$enc)) module.exports[$5457606f75a3fd9d$var$enc] = $5457606f75a3fd9d$var$module[$5457606f75a3fd9d$var$enc];
}

});
parcelRequire.register("71gdd", function(module, exports) {
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $51c533c7feb9a47f$require$Buffer = $xaL3N.Buffer;
// Export Node.js internal encodings.
module.exports = {
    // Encodings
    utf8: {
        type: "_internal",
        bomAware: true
    },
    cesu8: {
        type: "_internal",
        bomAware: true
    },
    unicode11utf8: "utf8",
    ucs2: {
        type: "_internal",
        bomAware: true
    },
    utf16le: "ucs2",
    binary: {
        type: "_internal"
    },
    base64: {
        type: "_internal"
    },
    hex: {
        type: "_internal"
    },
    // Codec.
    _internal: $51c533c7feb9a47f$var$InternalCodec
};
//------------------------------------------------------------------------------
function $51c533c7feb9a47f$var$InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") this.encoder = $51c533c7feb9a47f$var$InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = $51c533c7feb9a47f$var$InternalEncoderCesu8;
        // Add decoder for versions of Node not supporting CESU-8
        if ($51c533c7feb9a47f$require$Buffer.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
            this.decoder = $51c533c7feb9a47f$var$InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}
$51c533c7feb9a47f$var$InternalCodec.prototype.encoder = $51c533c7feb9a47f$var$InternalEncoder;
$51c533c7feb9a47f$var$InternalCodec.prototype.decoder = $51c533c7feb9a47f$var$InternalDecoder;

var $5oJF3 = parcelRequire("5oJF3");
var $51c533c7feb9a47f$require$StringDecoder = $5oJF3.StringDecoder;
if (!$51c533c7feb9a47f$require$StringDecoder.prototype.end) $51c533c7feb9a47f$require$StringDecoder.prototype.end = function() {};
function $51c533c7feb9a47f$var$InternalDecoder(options, codec) {
    this.decoder = new $51c533c7feb9a47f$require$StringDecoder(codec.enc);
}
$51c533c7feb9a47f$var$InternalDecoder.prototype.write = function(buf) {
    if (!$51c533c7feb9a47f$require$Buffer.isBuffer(buf)) buf = $51c533c7feb9a47f$require$Buffer.from(buf);
    return this.decoder.write(buf);
};
$51c533c7feb9a47f$var$InternalDecoder.prototype.end = function() {
    return this.decoder.end();
};
//------------------------------------------------------------------------------
// Encoder is mostly trivial
function $51c533c7feb9a47f$var$InternalEncoder(options, codec) {
    this.enc = codec.enc;
}
$51c533c7feb9a47f$var$InternalEncoder.prototype.write = function(str) {
    return $51c533c7feb9a47f$require$Buffer.from(str, this.enc);
};
$51c533c7feb9a47f$var$InternalEncoder.prototype.end = function() {};
//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.
function $51c533c7feb9a47f$var$InternalEncoderBase64(options, codec) {
    this.prevStr = "";
}
$51c533c7feb9a47f$var$InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return $51c533c7feb9a47f$require$Buffer.from(str, "base64");
};
$51c533c7feb9a47f$var$InternalEncoderBase64.prototype.end = function() {
    return $51c533c7feb9a47f$require$Buffer.from(this.prevStr, "base64");
};
//------------------------------------------------------------------------------
// CESU-8 encoder is also special.
function $51c533c7feb9a47f$var$InternalEncoderCesu8(options, codec) {}
$51c533c7feb9a47f$var$InternalEncoderCesu8.prototype.write = function(str) {
    var buf = $51c533c7feb9a47f$require$Buffer.alloc(str.length * 3), bufIdx = 0;
    for(var i = 0; i < str.length; i++){
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80) buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        } else {
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
};
$51c533c7feb9a47f$var$InternalEncoderCesu8.prototype.end = function() {};
//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+
function $51c533c7feb9a47f$var$InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}
$51c533c7feb9a47f$var$InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for(var i = 0; i < buf.length; i++){
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) {
            if (contBytes > 0) {
                res += this.defaultCharUnicode;
                contBytes = 0;
            }
            if (curByte < 0x80) res += String.fromCharCode(curByte);
            else if (curByte < 0xE0) {
                acc = curByte & 0x1F;
                contBytes = 1;
                accBytes = 1;
            } else if (curByte < 0xF0) {
                acc = curByte & 0x0F;
                contBytes = 2;
                accBytes = 1;
            } else res += this.defaultCharUnicode;
        } else if (contBytes > 0) {
            acc = acc << 6 | curByte & 0x3f;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
                // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;
                else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;
                else // Actually add character.
                res += String.fromCharCode(acc);
            }
        } else res += this.defaultCharUnicode;
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
};
$51c533c7feb9a47f$var$InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0) res += this.defaultCharUnicode;
    return res;
};

});
parcelRequire.register("xaL3N", function(module, exports) {
/* eslint-disable node/no-deprecated-api */ 
var $FkHbz = parcelRequire("FkHbz");
"use strict";

var $kznHi = parcelRequire("kznHi");
var $063b6d811290eaf5$var$Buffer = $kznHi.Buffer;
var $063b6d811290eaf5$var$safer = {};
var $063b6d811290eaf5$var$key;
for($063b6d811290eaf5$var$key in $kznHi){
    if (!$kznHi.hasOwnProperty($063b6d811290eaf5$var$key)) continue;
    if ($063b6d811290eaf5$var$key === "SlowBuffer" || $063b6d811290eaf5$var$key === "Buffer") continue;
    $063b6d811290eaf5$var$safer[$063b6d811290eaf5$var$key] = $kznHi[$063b6d811290eaf5$var$key];
}
var $063b6d811290eaf5$var$Safer = $063b6d811290eaf5$var$safer.Buffer = {};
for($063b6d811290eaf5$var$key in $063b6d811290eaf5$var$Buffer){
    if (!$063b6d811290eaf5$var$Buffer.hasOwnProperty($063b6d811290eaf5$var$key)) continue;
    if ($063b6d811290eaf5$var$key === "allocUnsafe" || $063b6d811290eaf5$var$key === "allocUnsafeSlow") continue;
    $063b6d811290eaf5$var$Safer[$063b6d811290eaf5$var$key] = $063b6d811290eaf5$var$Buffer[$063b6d811290eaf5$var$key];
}
$063b6d811290eaf5$var$safer.Buffer.prototype = $063b6d811290eaf5$var$Buffer.prototype;
if (!$063b6d811290eaf5$var$Safer.from || $063b6d811290eaf5$var$Safer.from === Uint8Array.from) $063b6d811290eaf5$var$Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    return $063b6d811290eaf5$var$Buffer(value, encodingOrOffset, length);
};
if (!$063b6d811290eaf5$var$Safer.alloc) $063b6d811290eaf5$var$Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    if (size < 0 || size >= 2 * 1073741824) throw new RangeError('The value "' + size + '" is invalid for option "size"');
    var buf = $063b6d811290eaf5$var$Buffer(size);
    if (!fill || fill.length === 0) buf.fill(0);
    else if (typeof encoding === "string") buf.fill(fill, encoding);
    else buf.fill(fill);
    return buf;
};
if (!$063b6d811290eaf5$var$safer.kStringMaxLength) try {
    $063b6d811290eaf5$var$safer.kStringMaxLength = $FkHbz.binding("buffer").kStringMaxLength;
} catch (e) {
// we can't determine kStringMaxLength in environments where process.binding
// is unsupported, so let's not set it
}
if (!$063b6d811290eaf5$var$safer.constants) {
    $063b6d811290eaf5$var$safer.constants = {
        MAX_LENGTH: $063b6d811290eaf5$var$safer.kMaxLength
    };
    if ($063b6d811290eaf5$var$safer.kStringMaxLength) $063b6d811290eaf5$var$safer.constants.MAX_STRING_LENGTH = $063b6d811290eaf5$var$safer.kStringMaxLength;
}
module.exports = $063b6d811290eaf5$var$safer;

});
parcelRequire.register("FkHbz", function(module, exports) {
// shim for using process in browser
var $07c3e2276d973f13$var$process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var $07c3e2276d973f13$var$cachedSetTimeout;
var $07c3e2276d973f13$var$cachedClearTimeout;
function $07c3e2276d973f13$var$defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function $07c3e2276d973f13$var$defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") $07c3e2276d973f13$var$cachedSetTimeout = setTimeout;
        else $07c3e2276d973f13$var$cachedSetTimeout = $07c3e2276d973f13$var$defaultSetTimout;
    } catch (e) {
        $07c3e2276d973f13$var$cachedSetTimeout = $07c3e2276d973f13$var$defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") $07c3e2276d973f13$var$cachedClearTimeout = clearTimeout;
        else $07c3e2276d973f13$var$cachedClearTimeout = $07c3e2276d973f13$var$defaultClearTimeout;
    } catch (e) {
        $07c3e2276d973f13$var$cachedClearTimeout = $07c3e2276d973f13$var$defaultClearTimeout;
    }
})();
function $07c3e2276d973f13$var$runTimeout(fun) {
    if ($07c3e2276d973f13$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if (($07c3e2276d973f13$var$cachedSetTimeout === $07c3e2276d973f13$var$defaultSetTimout || !$07c3e2276d973f13$var$cachedSetTimeout) && setTimeout) {
        $07c3e2276d973f13$var$cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $07c3e2276d973f13$var$cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return $07c3e2276d973f13$var$cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return $07c3e2276d973f13$var$cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function $07c3e2276d973f13$var$runClearTimeout(marker) {
    if ($07c3e2276d973f13$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if (($07c3e2276d973f13$var$cachedClearTimeout === $07c3e2276d973f13$var$defaultClearTimeout || !$07c3e2276d973f13$var$cachedClearTimeout) && clearTimeout) {
        $07c3e2276d973f13$var$cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $07c3e2276d973f13$var$cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return $07c3e2276d973f13$var$cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return $07c3e2276d973f13$var$cachedClearTimeout.call(this, marker);
        }
    }
}
var $07c3e2276d973f13$var$queue = [];
var $07c3e2276d973f13$var$draining = false;
var $07c3e2276d973f13$var$currentQueue;
var $07c3e2276d973f13$var$queueIndex = -1;
function $07c3e2276d973f13$var$cleanUpNextTick() {
    if (!$07c3e2276d973f13$var$draining || !$07c3e2276d973f13$var$currentQueue) return;
    $07c3e2276d973f13$var$draining = false;
    if ($07c3e2276d973f13$var$currentQueue.length) $07c3e2276d973f13$var$queue = $07c3e2276d973f13$var$currentQueue.concat($07c3e2276d973f13$var$queue);
    else $07c3e2276d973f13$var$queueIndex = -1;
    if ($07c3e2276d973f13$var$queue.length) $07c3e2276d973f13$var$drainQueue();
}
function $07c3e2276d973f13$var$drainQueue() {
    if ($07c3e2276d973f13$var$draining) return;
    var timeout = $07c3e2276d973f13$var$runTimeout($07c3e2276d973f13$var$cleanUpNextTick);
    $07c3e2276d973f13$var$draining = true;
    var len = $07c3e2276d973f13$var$queue.length;
    while(len){
        $07c3e2276d973f13$var$currentQueue = $07c3e2276d973f13$var$queue;
        $07c3e2276d973f13$var$queue = [];
        while(++$07c3e2276d973f13$var$queueIndex < len)if ($07c3e2276d973f13$var$currentQueue) $07c3e2276d973f13$var$currentQueue[$07c3e2276d973f13$var$queueIndex].run();
        $07c3e2276d973f13$var$queueIndex = -1;
        len = $07c3e2276d973f13$var$queue.length;
    }
    $07c3e2276d973f13$var$currentQueue = null;
    $07c3e2276d973f13$var$draining = false;
    $07c3e2276d973f13$var$runClearTimeout(timeout);
}
$07c3e2276d973f13$var$process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    $07c3e2276d973f13$var$queue.push(new $07c3e2276d973f13$var$Item(fun, args));
    if ($07c3e2276d973f13$var$queue.length === 1 && !$07c3e2276d973f13$var$draining) $07c3e2276d973f13$var$runTimeout($07c3e2276d973f13$var$drainQueue);
};
// v8 likes predictible objects
function $07c3e2276d973f13$var$Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
$07c3e2276d973f13$var$Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
$07c3e2276d973f13$var$process.title = "browser";
$07c3e2276d973f13$var$process.browser = true;
$07c3e2276d973f13$var$process.env = {};
$07c3e2276d973f13$var$process.argv = [];
$07c3e2276d973f13$var$process.version = ""; // empty string to avoid regexp issues
$07c3e2276d973f13$var$process.versions = {};
function $07c3e2276d973f13$var$noop() {}
$07c3e2276d973f13$var$process.on = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.addListener = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.once = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.off = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.removeListener = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.removeAllListeners = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.emit = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.prependListener = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.prependOnceListener = $07c3e2276d973f13$var$noop;
$07c3e2276d973f13$var$process.listeners = function(name) {
    return [];
};
$07c3e2276d973f13$var$process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
$07c3e2276d973f13$var$process.cwd = function() {
    return "/";
};
$07c3e2276d973f13$var$process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
$07c3e2276d973f13$var$process.umask = function() {
    return 0;
};

});

parcelRequire.register("kznHi", function(module, exports) {

$parcel$export(module.exports, "Buffer", () => $ef9975513e2e43d1$export$a143d493d941bafc, (v) => $ef9975513e2e43d1$export$a143d493d941bafc = v);
$parcel$export(module.exports, "SlowBuffer", () => $ef9975513e2e43d1$export$e4cf37d7f6fb9e0a, (v) => $ef9975513e2e43d1$export$e4cf37d7f6fb9e0a = v);
$parcel$export(module.exports, "INSPECT_MAX_BYTES", () => $ef9975513e2e43d1$export$f99ded8fe4b79145, (v) => $ef9975513e2e43d1$export$f99ded8fe4b79145 = v);
$parcel$export(module.exports, "kMaxLength", () => $ef9975513e2e43d1$export$599f31c3813fae4d, (v) => $ef9975513e2e43d1$export$599f31c3813fae4d = v);
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ var $ef9975513e2e43d1$export$a143d493d941bafc;
var $ef9975513e2e43d1$export$e4cf37d7f6fb9e0a;
var $ef9975513e2e43d1$export$f99ded8fe4b79145;
var $ef9975513e2e43d1$export$599f31c3813fae4d;
"use strict";

var $fAbtz = parcelRequire("fAbtz");

var $dPAzc = parcelRequire("dPAzc");
const $ef9975513e2e43d1$var$customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
$ef9975513e2e43d1$export$a143d493d941bafc = $ef9975513e2e43d1$var$Buffer;
$ef9975513e2e43d1$export$e4cf37d7f6fb9e0a = $ef9975513e2e43d1$var$SlowBuffer;
$ef9975513e2e43d1$export$f99ded8fe4b79145 = 50;
const $ef9975513e2e43d1$var$K_MAX_LENGTH = 0x7fffffff;
$ef9975513e2e43d1$export$599f31c3813fae4d = $ef9975513e2e43d1$var$K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ $ef9975513e2e43d1$var$Buffer.TYPED_ARRAY_SUPPORT = $ef9975513e2e43d1$var$typedArraySupport();
if (!$ef9975513e2e43d1$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function $ef9975513e2e43d1$var$typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty($ef9975513e2e43d1$var$Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!$ef9975513e2e43d1$var$Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty($ef9975513e2e43d1$var$Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!$ef9975513e2e43d1$var$Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function $ef9975513e2e43d1$var$createBuffer(length) {
    if (length > $ef9975513e2e43d1$var$K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, $ef9975513e2e43d1$var$Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function $ef9975513e2e43d1$var$Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return $ef9975513e2e43d1$var$allocUnsafe(arg);
    }
    return $ef9975513e2e43d1$var$from(arg, encodingOrOffset, length);
}
$ef9975513e2e43d1$var$Buffer.poolSize = 8192 // not used by this implementation
;
function $ef9975513e2e43d1$var$from(value, encodingOrOffset, length) {
    if (typeof value === "string") return $ef9975513e2e43d1$var$fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return $ef9975513e2e43d1$var$fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if ($ef9975513e2e43d1$var$isInstance(value, ArrayBuffer) || value && $ef9975513e2e43d1$var$isInstance(value.buffer, ArrayBuffer)) return $ef9975513e2e43d1$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && ($ef9975513e2e43d1$var$isInstance(value, SharedArrayBuffer) || value && $ef9975513e2e43d1$var$isInstance(value.buffer, SharedArrayBuffer))) return $ef9975513e2e43d1$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return $ef9975513e2e43d1$var$Buffer.from(valueOf, encodingOrOffset, length);
    const b = $ef9975513e2e43d1$var$fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return $ef9975513e2e43d1$var$Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ $ef9975513e2e43d1$var$Buffer.from = function(value, encodingOrOffset, length) {
    return $ef9975513e2e43d1$var$from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf($ef9975513e2e43d1$var$Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf($ef9975513e2e43d1$var$Buffer, Uint8Array);
function $ef9975513e2e43d1$var$assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function $ef9975513e2e43d1$var$alloc(size, fill, encoding) {
    $ef9975513e2e43d1$var$assertSize(size);
    if (size <= 0) return $ef9975513e2e43d1$var$createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? $ef9975513e2e43d1$var$createBuffer(size).fill(fill, encoding) : $ef9975513e2e43d1$var$createBuffer(size).fill(fill);
    return $ef9975513e2e43d1$var$createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ $ef9975513e2e43d1$var$Buffer.alloc = function(size, fill, encoding) {
    return $ef9975513e2e43d1$var$alloc(size, fill, encoding);
};
function $ef9975513e2e43d1$var$allocUnsafe(size) {
    $ef9975513e2e43d1$var$assertSize(size);
    return $ef9975513e2e43d1$var$createBuffer(size < 0 ? 0 : $ef9975513e2e43d1$var$checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ $ef9975513e2e43d1$var$Buffer.allocUnsafe = function(size) {
    return $ef9975513e2e43d1$var$allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ $ef9975513e2e43d1$var$Buffer.allocUnsafeSlow = function(size) {
    return $ef9975513e2e43d1$var$allocUnsafe(size);
};
function $ef9975513e2e43d1$var$fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!$ef9975513e2e43d1$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = $ef9975513e2e43d1$var$byteLength(string, encoding) | 0;
    let buf = $ef9975513e2e43d1$var$createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function $ef9975513e2e43d1$var$fromArrayLike(array) {
    const length = array.length < 0 ? 0 : $ef9975513e2e43d1$var$checked(array.length) | 0;
    const buf = $ef9975513e2e43d1$var$createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function $ef9975513e2e43d1$var$fromArrayView(arrayView) {
    if ($ef9975513e2e43d1$var$isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return $ef9975513e2e43d1$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return $ef9975513e2e43d1$var$fromArrayLike(arrayView);
}
function $ef9975513e2e43d1$var$fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, $ef9975513e2e43d1$var$Buffer.prototype);
    return buf;
}
function $ef9975513e2e43d1$var$fromObject(obj) {
    if ($ef9975513e2e43d1$var$Buffer.isBuffer(obj)) {
        const len = $ef9975513e2e43d1$var$checked(obj.length) | 0;
        const buf = $ef9975513e2e43d1$var$createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || $ef9975513e2e43d1$var$numberIsNaN(obj.length)) return $ef9975513e2e43d1$var$createBuffer(0);
        return $ef9975513e2e43d1$var$fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return $ef9975513e2e43d1$var$fromArrayLike(obj.data);
}
function $ef9975513e2e43d1$var$checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= $ef9975513e2e43d1$var$K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $ef9975513e2e43d1$var$K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function $ef9975513e2e43d1$var$SlowBuffer(length) {
    if (+length != length) length = 0;
    return $ef9975513e2e43d1$var$Buffer.alloc(+length);
}
$ef9975513e2e43d1$var$Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== $ef9975513e2e43d1$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
$ef9975513e2e43d1$var$Buffer.compare = function compare(a, b) {
    if ($ef9975513e2e43d1$var$isInstance(a, Uint8Array)) a = $ef9975513e2e43d1$var$Buffer.from(a, a.offset, a.byteLength);
    if ($ef9975513e2e43d1$var$isInstance(b, Uint8Array)) b = $ef9975513e2e43d1$var$Buffer.from(b, b.offset, b.byteLength);
    if (!$ef9975513e2e43d1$var$Buffer.isBuffer(a) || !$ef9975513e2e43d1$var$Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
$ef9975513e2e43d1$var$Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
$ef9975513e2e43d1$var$Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return $ef9975513e2e43d1$var$Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = $ef9975513e2e43d1$var$Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if ($ef9975513e2e43d1$var$isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!$ef9975513e2e43d1$var$Buffer.isBuffer(buf)) buf = $ef9975513e2e43d1$var$Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!$ef9975513e2e43d1$var$Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function $ef9975513e2e43d1$var$byteLength(string, encoding) {
    if ($ef9975513e2e43d1$var$Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || $ef9975513e2e43d1$var$isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return $ef9975513e2e43d1$var$utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return $ef9975513e2e43d1$var$base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : $ef9975513e2e43d1$var$utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
$ef9975513e2e43d1$var$Buffer.byteLength = $ef9975513e2e43d1$var$byteLength;
function $ef9975513e2e43d1$var$slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return $ef9975513e2e43d1$var$hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return $ef9975513e2e43d1$var$utf8Slice(this, start, end);
        case "ascii":
            return $ef9975513e2e43d1$var$asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return $ef9975513e2e43d1$var$latin1Slice(this, start, end);
        case "base64":
            return $ef9975513e2e43d1$var$base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $ef9975513e2e43d1$var$utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
$ef9975513e2e43d1$var$Buffer.prototype._isBuffer = true;
function $ef9975513e2e43d1$var$swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
$ef9975513e2e43d1$var$Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)$ef9975513e2e43d1$var$swap(this, i, i + 1);
    return this;
};
$ef9975513e2e43d1$var$Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        $ef9975513e2e43d1$var$swap(this, i, i + 3);
        $ef9975513e2e43d1$var$swap(this, i + 1, i + 2);
    }
    return this;
};
$ef9975513e2e43d1$var$Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        $ef9975513e2e43d1$var$swap(this, i, i + 7);
        $ef9975513e2e43d1$var$swap(this, i + 1, i + 6);
        $ef9975513e2e43d1$var$swap(this, i + 2, i + 5);
        $ef9975513e2e43d1$var$swap(this, i + 3, i + 4);
    }
    return this;
};
$ef9975513e2e43d1$var$Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return $ef9975513e2e43d1$var$utf8Slice(this, 0, length);
    return $ef9975513e2e43d1$var$slowToString.apply(this, arguments);
};
$ef9975513e2e43d1$var$Buffer.prototype.toLocaleString = $ef9975513e2e43d1$var$Buffer.prototype.toString;
$ef9975513e2e43d1$var$Buffer.prototype.equals = function equals(b) {
    if (!$ef9975513e2e43d1$var$Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return $ef9975513e2e43d1$var$Buffer.compare(this, b) === 0;
};
$ef9975513e2e43d1$var$Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = $ef9975513e2e43d1$export$f99ded8fe4b79145;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if ($ef9975513e2e43d1$var$customInspectSymbol) $ef9975513e2e43d1$var$Buffer.prototype[$ef9975513e2e43d1$var$customInspectSymbol] = $ef9975513e2e43d1$var$Buffer.prototype.inspect;
$ef9975513e2e43d1$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if ($ef9975513e2e43d1$var$isInstance(target, Uint8Array)) target = $ef9975513e2e43d1$var$Buffer.from(target, target.offset, target.byteLength);
    if (!$ef9975513e2e43d1$var$Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $ef9975513e2e43d1$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if ($ef9975513e2e43d1$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = $ef9975513e2e43d1$var$Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if ($ef9975513e2e43d1$var$Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return $ef9975513e2e43d1$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return $ef9975513e2e43d1$var$arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function $ef9975513e2e43d1$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
$ef9975513e2e43d1$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
$ef9975513e2e43d1$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return $ef9975513e2e43d1$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
$ef9975513e2e43d1$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return $ef9975513e2e43d1$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function $ef9975513e2e43d1$var$hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if ($ef9975513e2e43d1$var$numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function $ef9975513e2e43d1$var$utf8Write(buf, string, offset, length) {
    return $ef9975513e2e43d1$var$blitBuffer($ef9975513e2e43d1$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function $ef9975513e2e43d1$var$asciiWrite(buf, string, offset, length) {
    return $ef9975513e2e43d1$var$blitBuffer($ef9975513e2e43d1$var$asciiToBytes(string), buf, offset, length);
}
function $ef9975513e2e43d1$var$base64Write(buf, string, offset, length) {
    return $ef9975513e2e43d1$var$blitBuffer($ef9975513e2e43d1$var$base64ToBytes(string), buf, offset, length);
}
function $ef9975513e2e43d1$var$ucs2Write(buf, string, offset, length) {
    return $ef9975513e2e43d1$var$blitBuffer($ef9975513e2e43d1$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
$ef9975513e2e43d1$var$Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return $ef9975513e2e43d1$var$hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return $ef9975513e2e43d1$var$utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return $ef9975513e2e43d1$var$asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return $ef9975513e2e43d1$var$base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $ef9975513e2e43d1$var$ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
$ef9975513e2e43d1$var$Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function $ef9975513e2e43d1$var$base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return $fAbtz.fromByteArray(buf);
    else return $fAbtz.fromByteArray(buf.slice(start, end));
}
function $ef9975513e2e43d1$var$utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return $ef9975513e2e43d1$var$decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const $ef9975513e2e43d1$var$MAX_ARGUMENTS_LENGTH = 0x1000;
function $ef9975513e2e43d1$var$decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= $ef9975513e2e43d1$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $ef9975513e2e43d1$var$MAX_ARGUMENTS_LENGTH));
    return res;
}
function $ef9975513e2e43d1$var$asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function $ef9975513e2e43d1$var$latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function $ef9975513e2e43d1$var$hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += $ef9975513e2e43d1$var$hexSliceLookupTable[buf[i]];
    return out;
}
function $ef9975513e2e43d1$var$utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
$ef9975513e2e43d1$var$Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, $ef9975513e2e43d1$var$Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function $ef9975513e2e43d1$var$checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
$ef9975513e2e43d1$var$Buffer.prototype.readUintLE = $ef9975513e2e43d1$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readUintBE = $ef9975513e2e43d1$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readUint8 = $ef9975513e2e43d1$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 1, this.length);
    return this[offset];
};
$ef9975513e2e43d1$var$Buffer.prototype.readUint16LE = $ef9975513e2e43d1$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
$ef9975513e2e43d1$var$Buffer.prototype.readUint16BE = $ef9975513e2e43d1$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
$ef9975513e2e43d1$var$Buffer.prototype.readUint32LE = $ef9975513e2e43d1$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
$ef9975513e2e43d1$var$Buffer.prototype.readUint32BE = $ef9975513e2e43d1$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
$ef9975513e2e43d1$var$Buffer.prototype.readBigUInt64LE = $ef9975513e2e43d1$var$defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    $ef9975513e2e43d1$var$validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $ef9975513e2e43d1$var$boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
$ef9975513e2e43d1$var$Buffer.prototype.readBigUInt64BE = $ef9975513e2e43d1$var$defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    $ef9975513e2e43d1$var$validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $ef9975513e2e43d1$var$boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
$ef9975513e2e43d1$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
$ef9975513e2e43d1$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$ef9975513e2e43d1$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
$ef9975513e2e43d1$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
$ef9975513e2e43d1$var$Buffer.prototype.readBigInt64LE = $ef9975513e2e43d1$var$defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    $ef9975513e2e43d1$var$validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $ef9975513e2e43d1$var$boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
$ef9975513e2e43d1$var$Buffer.prototype.readBigInt64BE = $ef9975513e2e43d1$var$defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    $ef9975513e2e43d1$var$validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $ef9975513e2e43d1$var$boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
$ef9975513e2e43d1$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return $dPAzc.read(this, offset, true, 23, 4);
};
$ef9975513e2e43d1$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 4, this.length);
    return $dPAzc.read(this, offset, false, 23, 4);
};
$ef9975513e2e43d1$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 8, this.length);
    return $dPAzc.read(this, offset, true, 52, 8);
};
$ef9975513e2e43d1$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkOffset(offset, 8, this.length);
    return $dPAzc.read(this, offset, false, 52, 8);
};
function $ef9975513e2e43d1$var$checkInt(buf, value, offset, ext, max, min) {
    if (!$ef9975513e2e43d1$var$Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
$ef9975513e2e43d1$var$Buffer.prototype.writeUintLE = $ef9975513e2e43d1$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $ef9975513e2e43d1$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUintBE = $ef9975513e2e43d1$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $ef9975513e2e43d1$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUint8 = $ef9975513e2e43d1$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUint16LE = $ef9975513e2e43d1$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUint16BE = $ef9975513e2e43d1$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUint32LE = $ef9975513e2e43d1$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeUint32BE = $ef9975513e2e43d1$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function $ef9975513e2e43d1$var$wrtBigUInt64LE(buf, value, offset, min, max) {
    $ef9975513e2e43d1$var$checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function $ef9975513e2e43d1$var$wrtBigUInt64BE(buf, value, offset, min, max) {
    $ef9975513e2e43d1$var$checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
$ef9975513e2e43d1$var$Buffer.prototype.writeBigUInt64LE = $ef9975513e2e43d1$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return $ef9975513e2e43d1$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
$ef9975513e2e43d1$var$Buffer.prototype.writeBigUInt64BE = $ef9975513e2e43d1$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return $ef9975513e2e43d1$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
$ef9975513e2e43d1$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        $ef9975513e2e43d1$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        $ef9975513e2e43d1$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
$ef9975513e2e43d1$var$Buffer.prototype.writeBigInt64LE = $ef9975513e2e43d1$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return $ef9975513e2e43d1$var$wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
$ef9975513e2e43d1$var$Buffer.prototype.writeBigInt64BE = $ef9975513e2e43d1$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return $ef9975513e2e43d1$var$wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function $ef9975513e2e43d1$var$checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function $ef9975513e2e43d1$var$writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    $dPAzc.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
$ef9975513e2e43d1$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return $ef9975513e2e43d1$var$writeFloat(this, value, offset, true, noAssert);
};
$ef9975513e2e43d1$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return $ef9975513e2e43d1$var$writeFloat(this, value, offset, false, noAssert);
};
function $ef9975513e2e43d1$var$writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $ef9975513e2e43d1$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    $dPAzc.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
$ef9975513e2e43d1$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return $ef9975513e2e43d1$var$writeDouble(this, value, offset, true, noAssert);
};
$ef9975513e2e43d1$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return $ef9975513e2e43d1$var$writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
$ef9975513e2e43d1$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!$ef9975513e2e43d1$var$Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
$ef9975513e2e43d1$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !$ef9975513e2e43d1$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = $ef9975513e2e43d1$var$Buffer.isBuffer(val) ? val : $ef9975513e2e43d1$var$Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const $ef9975513e2e43d1$var$errors = {};
function $ef9975513e2e43d1$var$E(sym, getMessage, Base) {
    $ef9975513e2e43d1$var$errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
$ef9975513e2e43d1$var$E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
$ef9975513e2e43d1$var$E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
$ef9975513e2e43d1$var$E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $ef9975513e2e43d1$var$addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $ef9975513e2e43d1$var$addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function $ef9975513e2e43d1$var$addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function $ef9975513e2e43d1$var$checkBounds(buf, offset, byteLength) {
    $ef9975513e2e43d1$var$validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $ef9975513e2e43d1$var$boundsError(offset, buf.length - (byteLength + 1));
}
function $ef9975513e2e43d1$var$checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new $ef9975513e2e43d1$var$errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    $ef9975513e2e43d1$var$checkBounds(buf, offset, byteLength);
}
function $ef9975513e2e43d1$var$validateNumber(value, name) {
    if (typeof value !== "number") throw new $ef9975513e2e43d1$var$errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function $ef9975513e2e43d1$var$boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        $ef9975513e2e43d1$var$validateNumber(value, type);
        throw new $ef9975513e2e43d1$var$errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new $ef9975513e2e43d1$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new $ef9975513e2e43d1$var$errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const $ef9975513e2e43d1$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function $ef9975513e2e43d1$var$base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace($ef9975513e2e43d1$var$INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function $ef9975513e2e43d1$var$utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function $ef9975513e2e43d1$var$asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function $ef9975513e2e43d1$var$utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function $ef9975513e2e43d1$var$base64ToBytes(str) {
    return $fAbtz.toByteArray($ef9975513e2e43d1$var$base64clean(str));
}
function $ef9975513e2e43d1$var$blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $ef9975513e2e43d1$var$isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function $ef9975513e2e43d1$var$numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const $ef9975513e2e43d1$var$hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function $ef9975513e2e43d1$var$defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? $ef9975513e2e43d1$var$BufferBigIntNotDefined : fn;
}
function $ef9975513e2e43d1$var$BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

});
parcelRequire.register("fAbtz", function(module, exports) {

$parcel$export(module.exports, "toByteArray", () => $b5831eb1d6c96426$export$d622b2ad8d90c771, (v) => $b5831eb1d6c96426$export$d622b2ad8d90c771 = v);
$parcel$export(module.exports, "fromByteArray", () => $b5831eb1d6c96426$export$6100ba28696e12de, (v) => $b5831eb1d6c96426$export$6100ba28696e12de = v);
var $b5831eb1d6c96426$export$a48f0734ac7c2329;
var $b5831eb1d6c96426$export$d622b2ad8d90c771;
var $b5831eb1d6c96426$export$6100ba28696e12de;
"use strict";
$b5831eb1d6c96426$export$a48f0734ac7c2329 = $b5831eb1d6c96426$var$byteLength;
$b5831eb1d6c96426$export$d622b2ad8d90c771 = $b5831eb1d6c96426$var$toByteArray;
$b5831eb1d6c96426$export$6100ba28696e12de = $b5831eb1d6c96426$var$fromByteArray;
var $b5831eb1d6c96426$var$lookup = [];
var $b5831eb1d6c96426$var$revLookup = [];
var $b5831eb1d6c96426$var$Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var $b5831eb1d6c96426$var$code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var $b5831eb1d6c96426$var$i = 0, $b5831eb1d6c96426$var$len = $b5831eb1d6c96426$var$code.length; $b5831eb1d6c96426$var$i < $b5831eb1d6c96426$var$len; ++$b5831eb1d6c96426$var$i){
    $b5831eb1d6c96426$var$lookup[$b5831eb1d6c96426$var$i] = $b5831eb1d6c96426$var$code[$b5831eb1d6c96426$var$i];
    $b5831eb1d6c96426$var$revLookup[$b5831eb1d6c96426$var$code.charCodeAt($b5831eb1d6c96426$var$i)] = $b5831eb1d6c96426$var$i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$b5831eb1d6c96426$var$revLookup["-".charCodeAt(0)] = 62;
$b5831eb1d6c96426$var$revLookup["_".charCodeAt(0)] = 63;
function $b5831eb1d6c96426$var$getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function $b5831eb1d6c96426$var$byteLength(b64) {
    var lens = $b5831eb1d6c96426$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $b5831eb1d6c96426$var$_byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $b5831eb1d6c96426$var$toByteArray(b64) {
    var tmp;
    var lens = $b5831eb1d6c96426$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new $b5831eb1d6c96426$var$Arr($b5831eb1d6c96426$var$_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i)] << 18 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i)] << 2 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i)] << 10 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $b5831eb1d6c96426$var$revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function $b5831eb1d6c96426$var$tripletToBase64(num) {
    return $b5831eb1d6c96426$var$lookup[num >> 18 & 0x3F] + $b5831eb1d6c96426$var$lookup[num >> 12 & 0x3F] + $b5831eb1d6c96426$var$lookup[num >> 6 & 0x3F] + $b5831eb1d6c96426$var$lookup[num & 0x3F];
}
function $b5831eb1d6c96426$var$encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push($b5831eb1d6c96426$var$tripletToBase64(tmp));
    }
    return output.join("");
}
function $b5831eb1d6c96426$var$fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($b5831eb1d6c96426$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push($b5831eb1d6c96426$var$lookup[tmp >> 2] + $b5831eb1d6c96426$var$lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push($b5831eb1d6c96426$var$lookup[tmp >> 10] + $b5831eb1d6c96426$var$lookup[tmp >> 4 & 0x3F] + $b5831eb1d6c96426$var$lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

});

parcelRequire.register("dPAzc", function(module, exports) {

$parcel$export(module.exports, "read", () => $a11c6733277d3ca0$export$aafa59e2e03f2942, (v) => $a11c6733277d3ca0$export$aafa59e2e03f2942 = v);
$parcel$export(module.exports, "write", () => $a11c6733277d3ca0$export$68d8715fc104d294, (v) => $a11c6733277d3ca0$export$68d8715fc104d294 = v);
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $a11c6733277d3ca0$export$aafa59e2e03f2942;
var $a11c6733277d3ca0$export$68d8715fc104d294;
$a11c6733277d3ca0$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
$a11c6733277d3ca0$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

});



parcelRequire.register("5oJF3", function(module, exports) {

$parcel$export(module.exports, "StringDecoder", () => $3ee29d0004b91efe$export$63a7aa211a91ed69, (v) => $3ee29d0004b91efe$export$63a7aa211a91ed69 = v);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
var $3ee29d0004b91efe$export$63a7aa211a91ed69;
"use strict";

var $ALagx = parcelRequire("ALagx");
var $3ee29d0004b91efe$require$Buffer = $ALagx.Buffer;
/*</replacement>*/ var $3ee29d0004b91efe$var$isEncoding = $3ee29d0004b91efe$require$Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function $3ee29d0004b91efe$var$_normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function $3ee29d0004b91efe$var$normalizeEncoding(enc) {
    var nenc = $3ee29d0004b91efe$var$_normalizeEncoding(enc);
    if (typeof nenc !== "string" && ($3ee29d0004b91efe$require$Buffer.isEncoding === $3ee29d0004b91efe$var$isEncoding || !$3ee29d0004b91efe$var$isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
$3ee29d0004b91efe$export$63a7aa211a91ed69 = $3ee29d0004b91efe$var$StringDecoder;
function $3ee29d0004b91efe$var$StringDecoder(encoding) {
    this.encoding = $3ee29d0004b91efe$var$normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = $3ee29d0004b91efe$var$utf16Text;
            this.end = $3ee29d0004b91efe$var$utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = $3ee29d0004b91efe$var$utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = $3ee29d0004b91efe$var$base64Text;
            this.end = $3ee29d0004b91efe$var$base64End;
            nb = 3;
            break;
        default:
            this.write = $3ee29d0004b91efe$var$simpleWrite;
            this.end = $3ee29d0004b91efe$var$simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = $3ee29d0004b91efe$require$Buffer.allocUnsafe(nb);
}
$3ee29d0004b91efe$var$StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
$3ee29d0004b91efe$var$StringDecoder.prototype.end = $3ee29d0004b91efe$var$utf8End;
// Returns only complete characters in a Buffer
$3ee29d0004b91efe$var$StringDecoder.prototype.text = $3ee29d0004b91efe$var$utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
$3ee29d0004b91efe$var$StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function $3ee29d0004b91efe$var$utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function $3ee29d0004b91efe$var$utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = $3ee29d0004b91efe$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $3ee29d0004b91efe$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = $3ee29d0004b91efe$var$utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function $3ee29d0004b91efe$var$utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function $3ee29d0004b91efe$var$utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = $3ee29d0004b91efe$var$utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function $3ee29d0004b91efe$var$utf8Text(buf, i) {
    var total = $3ee29d0004b91efe$var$utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function $3ee29d0004b91efe$var$utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function $3ee29d0004b91efe$var$utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function $3ee29d0004b91efe$var$utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function $3ee29d0004b91efe$var$base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function $3ee29d0004b91efe$var$base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function $3ee29d0004b91efe$var$simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function $3ee29d0004b91efe$var$simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

});
parcelRequire.register("ALagx", function(module, exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ 
var $kznHi = parcelRequire("kznHi");
var $06e7f2cf4d8f5f53$var$Buffer = $kznHi.Buffer;
// alternative to using Object.keys for old browsers
function $06e7f2cf4d8f5f53$var$copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if ($06e7f2cf4d8f5f53$var$Buffer.from && $06e7f2cf4d8f5f53$var$Buffer.alloc && $06e7f2cf4d8f5f53$var$Buffer.allocUnsafe && $06e7f2cf4d8f5f53$var$Buffer.allocUnsafeSlow) module.exports = $kznHi;
else {
    // Copy properties from require('buffer')
    $06e7f2cf4d8f5f53$var$copyProps($kznHi, module.exports);
    module.exports.Buffer = $06e7f2cf4d8f5f53$var$SafeBuffer;
}
function $06e7f2cf4d8f5f53$var$SafeBuffer(arg, encodingOrOffset, length) {
    return $06e7f2cf4d8f5f53$var$Buffer(arg, encodingOrOffset, length);
}
$06e7f2cf4d8f5f53$var$SafeBuffer.prototype = Object.create($06e7f2cf4d8f5f53$var$Buffer.prototype);
// Copy static methods from Buffer
$06e7f2cf4d8f5f53$var$copyProps($06e7f2cf4d8f5f53$var$Buffer, $06e7f2cf4d8f5f53$var$SafeBuffer);
$06e7f2cf4d8f5f53$var$SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return $06e7f2cf4d8f5f53$var$Buffer(arg, encodingOrOffset, length);
};
$06e7f2cf4d8f5f53$var$SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = $06e7f2cf4d8f5f53$var$Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
$06e7f2cf4d8f5f53$var$SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $06e7f2cf4d8f5f53$var$Buffer(size);
};
$06e7f2cf4d8f5f53$var$SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return $kznHi.SlowBuffer(size);
};

});



parcelRequire.register("Bpdbx", function(module, exports) {

$parcel$export(module.exports, "_utf32", () => $07070353afc2871c$export$b2b6b8849c32811a, (v) => $07070353afc2871c$export$b2b6b8849c32811a = v);
$parcel$export(module.exports, "utf32le", () => $07070353afc2871c$export$8ab18849c577cec0, (v) => $07070353afc2871c$export$8ab18849c577cec0 = v);
$parcel$export(module.exports, "utf32be", () => $07070353afc2871c$export$197feba3617118ca, (v) => $07070353afc2871c$export$197feba3617118ca = v);
$parcel$export(module.exports, "ucs4le", () => $07070353afc2871c$export$b3ab04f31ec3be1f, (v) => $07070353afc2871c$export$b3ab04f31ec3be1f = v);
$parcel$export(module.exports, "ucs4be", () => $07070353afc2871c$export$a8734ff2aa536306, (v) => $07070353afc2871c$export$a8734ff2aa536306 = v);
$parcel$export(module.exports, "utf32", () => $07070353afc2871c$export$43e4d86902f4e7e9, (v) => $07070353afc2871c$export$43e4d86902f4e7e9 = v);
$parcel$export(module.exports, "ucs4", () => $07070353afc2871c$export$1350116c6c9180d2, (v) => $07070353afc2871c$export$1350116c6c9180d2 = v);
// == UTF32-LE/BE codec. ==========================================================
var $07070353afc2871c$export$b2b6b8849c32811a;
var $07070353afc2871c$export$8ab18849c577cec0;
var $07070353afc2871c$export$197feba3617118ca;
// Aliases
var $07070353afc2871c$export$b3ab04f31ec3be1f;
var $07070353afc2871c$export$a8734ff2aa536306;
// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});
// Encoder prepends BOM (which can be overridden with (addBOM: false}).
var $07070353afc2871c$export$43e4d86902f4e7e9;
var $07070353afc2871c$export$1350116c6c9180d2;
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $07070353afc2871c$require$Buffer = $xaL3N.Buffer;
$07070353afc2871c$export$b2b6b8849c32811a = $07070353afc2871c$var$Utf32Codec;
function $07070353afc2871c$var$Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
}
$07070353afc2871c$export$8ab18849c577cec0 = {
    type: "_utf32",
    isLE: true
};
$07070353afc2871c$export$197feba3617118ca = {
    type: "_utf32",
    isLE: false
};
$07070353afc2871c$export$b3ab04f31ec3be1f = "utf32le";
$07070353afc2871c$export$a8734ff2aa536306 = "utf32be";
$07070353afc2871c$var$Utf32Codec.prototype.encoder = $07070353afc2871c$var$Utf32Encoder;
$07070353afc2871c$var$Utf32Codec.prototype.decoder = $07070353afc2871c$var$Utf32Decoder;
// -- Encoding
function $07070353afc2871c$var$Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
}
$07070353afc2871c$var$Utf32Encoder.prototype.write = function(str) {
    var src = $07070353afc2871c$require$Buffer.from(str, "ucs2");
    var dst = $07070353afc2871c$require$Buffer.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for(var i = 0; i < src.length; i += 2){
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 0xD800 <= code && code < 0xDC00;
        var isLowSurrogate = 0xDC00 <= code && code < 0xE000;
        if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
                // (technically wrong, but expected by some applications, like Windows file names).
                write32.call(dst, this.highSurrogate, offset);
                offset += 4;
            } else {
                // Create 32-bit value from high and low surrogates;
                var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
                write32.call(dst, codepoint, offset);
                offset += 4;
                this.highSurrogate = 0;
                continue;
            }
        }
        if (isHighSurrogate) this.highSurrogate = code;
        else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
        }
    }
    if (offset < dst.length) dst = dst.slice(0, offset);
    return dst;
};
$07070353afc2871c$var$Utf32Encoder.prototype.end = function() {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate) return;
    var buf = $07070353afc2871c$require$Buffer.alloc(4);
    if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
    else buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
};
// -- Decoding
function $07070353afc2871c$var$Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
}
$07070353afc2871c$var$Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0) return "";
    var i = 0;
    var codepoint = 0;
    var dst = $07070353afc2871c$require$Buffer.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
        for(; i < src.length && overflow.length < 4; i++)overflow.push(src[i]);
        if (overflow.length === 4) {
            // NOTE: codepoint is a signed int32 and can be negative.
            // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
            if (isLE) codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
            else codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
            overflow.length = 0;
            offset = $07070353afc2871c$var$_writeCodepoint(dst, offset, codepoint, badChar);
        }
    }
    // Main loop. Should be as optimized as possible.
    for(; i < src.length - 3; i += 4){
        // NOTE: codepoint is a signed int32 and can be negative.
        if (isLE) codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        else codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        offset = $07070353afc2871c$var$_writeCodepoint(dst, offset, codepoint, badChar);
    }
    // Keep overflowing bytes.
    for(; i < src.length; i++)overflow.push(src[i]);
    return dst.slice(0, offset).toString("ucs2");
};
function $07070353afc2871c$var$_writeCodepoint(dst, offset, codepoint, badChar) {
    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
    if (codepoint < 0 || codepoint > 0x10FFFF) // Not a valid Unicode codepoint
    codepoint = badChar;
    // Ephemeral Planes: Write high surrogate.
    if (codepoint >= 0x10000) {
        codepoint -= 0x10000;
        var high = 0xD800 | codepoint >> 10;
        dst[offset++] = high & 0xff;
        dst[offset++] = high >> 8;
        // Low surrogate is written below.
        var codepoint = 0xDC00 | codepoint & 0x3FF;
    }
    // Write BMP char or low surrogate.
    dst[offset++] = codepoint & 0xff;
    dst[offset++] = codepoint >> 8;
    return offset;
}
$07070353afc2871c$var$Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
};
$07070353afc2871c$export$43e4d86902f4e7e9 = $07070353afc2871c$var$Utf32AutoCodec;
$07070353afc2871c$export$1350116c6c9180d2 = "utf32";
function $07070353afc2871c$var$Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
}
$07070353afc2871c$var$Utf32AutoCodec.prototype.encoder = $07070353afc2871c$var$Utf32AutoEncoder;
$07070353afc2871c$var$Utf32AutoCodec.prototype.decoder = $07070353afc2871c$var$Utf32AutoDecoder;
// -- Encoding
function $07070353afc2871c$var$Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
}
$07070353afc2871c$var$Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
};
$07070353afc2871c$var$Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
};
// -- Decoding
function $07070353afc2871c$var$Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
}
$07070353afc2871c$var$Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32) return "";
        // We have enough bytes -> detect endianness.
        var encoding = $07070353afc2871c$var$detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.write(buf);
};
$07070353afc2871c$var$Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = $07070353afc2871c$var$detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail) resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.end();
};
function $07070353afc2871c$var$detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0; // Number of invalid chars when decoded as LE or BE.
    var bmpCharsLE = 0, bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.
    outer_loop: for(var i = 0; i < bufs.length; i++){
        var buf = bufs[i];
        for(var j = 0; j < buf.length; j++){
            b.push(buf[j]);
            if (b.length === 4) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) return "utf-32le";
                    if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) return "utf-32be";
                }
                if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
                if (b[3] !== 0 || b[2] > 0x10) invalidLE++;
                if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
                if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
                b.length = 0;
                charsProcessed++;
                if (charsProcessed >= 100) break outer_loop;
            }
        }
    }
    // Make decisions.
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || "utf-32le";
}

});

parcelRequire.register("9Znyc", function(module, exports) {

$parcel$export(module.exports, "utf16be", () => $745c143eca151bee$export$8b9ec48b10867f55, (v) => $745c143eca151bee$export$8b9ec48b10867f55 = v);
$parcel$export(module.exports, "utf16", () => $745c143eca151bee$export$5e3087022f4331a5, (v) => $745c143eca151bee$export$5e3087022f4331a5 = v);
// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js
// == UTF16-BE codec. ==========================================================
var $745c143eca151bee$export$8b9ec48b10867f55;
// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});
// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).
var $745c143eca151bee$export$5e3087022f4331a5;
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $745c143eca151bee$require$Buffer = $xaL3N.Buffer;
$745c143eca151bee$export$8b9ec48b10867f55 = $745c143eca151bee$var$Utf16BECodec;
function $745c143eca151bee$var$Utf16BECodec() {}
$745c143eca151bee$var$Utf16BECodec.prototype.encoder = $745c143eca151bee$var$Utf16BEEncoder;
$745c143eca151bee$var$Utf16BECodec.prototype.decoder = $745c143eca151bee$var$Utf16BEDecoder;
$745c143eca151bee$var$Utf16BECodec.prototype.bomAware = true;
// -- Encoding
function $745c143eca151bee$var$Utf16BEEncoder() {}
$745c143eca151bee$var$Utf16BEEncoder.prototype.write = function(str) {
    var buf = $745c143eca151bee$require$Buffer.from(str, "ucs2");
    for(var i = 0; i < buf.length; i += 2){
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
    }
    return buf;
};
$745c143eca151bee$var$Utf16BEEncoder.prototype.end = function() {};
// -- Decoding
function $745c143eca151bee$var$Utf16BEDecoder() {
    this.overflowByte = -1;
}
$745c143eca151bee$var$Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0) return "";
    var buf2 = $745c143eca151bee$require$Buffer.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
    }
    for(; i < buf.length - 1; i += 2, j += 2){
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
};
$745c143eca151bee$var$Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
};
$745c143eca151bee$export$5e3087022f4331a5 = $745c143eca151bee$var$Utf16Codec;
function $745c143eca151bee$var$Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}
$745c143eca151bee$var$Utf16Codec.prototype.encoder = $745c143eca151bee$var$Utf16Encoder;
$745c143eca151bee$var$Utf16Codec.prototype.decoder = $745c143eca151bee$var$Utf16Decoder;
// -- Encoding (pass-through)
function $745c143eca151bee$var$Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
}
$745c143eca151bee$var$Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
};
$745c143eca151bee$var$Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
};
// -- Decoding
function $745c143eca151bee$var$Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
}
$745c143eca151bee$var$Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16) return "";
        // We have enough bytes -> detect endianness.
        var encoding = $745c143eca151bee$var$detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.write(buf);
};
$745c143eca151bee$var$Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = $745c143eca151bee$var$detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for(var i = 0; i < this.initialBufs.length; i++)resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail) resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.end();
};
function $745c143eca151bee$var$detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.
    outer_loop: for(var i = 0; i < bufs.length; i++){
        var buf = bufs[i];
        for(var j = 0; j < buf.length; j++){
            b.push(buf[j]);
            if (b.length === 2) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE) return "utf-16le";
                    if (b[0] === 0xFE && b[1] === 0xFF) return "utf-16be";
                }
                if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
                if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
                b.length = 0;
                charsProcessed++;
                if (charsProcessed >= 100) break outer_loop;
            }
        }
    }
    // Make decisions.
    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
    // So, we count ASCII as if it was LE or BE, and decide from that.
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || "utf-16le";
}

});

parcelRequire.register("68lqB", function(module, exports) {

$parcel$export(module.exports, "utf7", () => $47741c99b3ffda78$export$b2f9c8661b81cf99, (v) => $47741c99b3ffda78$export$b2f9c8661b81cf99 = v);
$parcel$export(module.exports, "unicode11utf7", () => $47741c99b3ffda78$export$cc49de5f94fc4004, (v) => $47741c99b3ffda78$export$cc49de5f94fc4004 = v);
$parcel$export(module.exports, "utf7imap", () => $47741c99b3ffda78$export$2488b28744623c18, (v) => $47741c99b3ffda78$export$2488b28744623c18 = v);
// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3
var $47741c99b3ffda78$export$b2f9c8661b81cf99;
var $47741c99b3ffda78$export$cc49de5f94fc4004;
// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.
var $47741c99b3ffda78$export$2488b28744623c18;
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $47741c99b3ffda78$require$Buffer = $xaL3N.Buffer;
$47741c99b3ffda78$export$b2f9c8661b81cf99 = $47741c99b3ffda78$var$Utf7Codec;
$47741c99b3ffda78$export$cc49de5f94fc4004 = "utf7"; // Alias UNICODE-1-1-UTF-7
function $47741c99b3ffda78$var$Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
}
$47741c99b3ffda78$var$Utf7Codec.prototype.encoder = $47741c99b3ffda78$var$Utf7Encoder;
$47741c99b3ffda78$var$Utf7Codec.prototype.decoder = $47741c99b3ffda78$var$Utf7Decoder;
$47741c99b3ffda78$var$Utf7Codec.prototype.bomAware = true;
// -- Encoding
var $47741c99b3ffda78$var$nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
function $47741c99b3ffda78$var$Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}
$47741c99b3ffda78$var$Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return $47741c99b3ffda78$require$Buffer.from(str.replace($47741c99b3ffda78$var$nonDirectChars, (function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
};
$47741c99b3ffda78$var$Utf7Encoder.prototype.end = function() {};
// -- Decoding
function $47741c99b3ffda78$var$Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
}
var $47741c99b3ffda78$var$base64Regex = /[A-Za-z0-9\/+]/;
var $47741c99b3ffda78$var$base64Chars = [];
for(var $47741c99b3ffda78$var$i = 0; $47741c99b3ffda78$var$i < 256; $47741c99b3ffda78$var$i++)$47741c99b3ffda78$var$base64Chars[$47741c99b3ffda78$var$i] = $47741c99b3ffda78$var$base64Regex.test(String.fromCharCode($47741c99b3ffda78$var$i));
var $47741c99b3ffda78$var$plusChar = "+".charCodeAt(0), $47741c99b3ffda78$var$minusChar = "-".charCodeAt(0), $47741c99b3ffda78$var$andChar = "&".charCodeAt(0);
$47741c99b3ffda78$var$Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    // The decoder is more involved as we must handle chunks in stream.
    for(var i = 0; i < buf.length; i++){
        if (!inBase64) // Write direct chars until '+'
        {
            if (buf[i] == $47741c99b3ffda78$var$plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i + 1;
                inBase64 = true;
            }
        } else if (!$47741c99b3ffda78$var$base64Chars[buf[i]]) {
            if (i == lastI && buf[i] == $47741c99b3ffda78$var$minusChar) res += "+";
            else {
                var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                res += this.iconv.decode($47741c99b3ffda78$require$Buffer.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i] != $47741c99b3ffda78$var$minusChar) i--;
            lastI = i + 1;
            inBase64 = false;
            base64Accum = "";
        }
    }
    if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode($47741c99b3ffda78$require$Buffer.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
};
$47741c99b3ffda78$var$Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode($47741c99b3ffda78$require$Buffer.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
};
$47741c99b3ffda78$export$2488b28744623c18 = $47741c99b3ffda78$var$Utf7IMAPCodec;
function $47741c99b3ffda78$var$Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
}
$47741c99b3ffda78$var$Utf7IMAPCodec.prototype.encoder = $47741c99b3ffda78$var$Utf7IMAPEncoder;
$47741c99b3ffda78$var$Utf7IMAPCodec.prototype.decoder = $47741c99b3ffda78$var$Utf7IMAPDecoder;
$47741c99b3ffda78$var$Utf7IMAPCodec.prototype.bomAware = true;
// -- Encoding
function $47741c99b3ffda78$var$Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = $47741c99b3ffda78$require$Buffer.alloc(6);
    this.base64AccumIdx = 0;
}
$47741c99b3ffda78$var$Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = $47741c99b3ffda78$require$Buffer.alloc(str.length * 5 + 10), bufIdx = 0;
    for(var i = 0; i < str.length; i++){
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) {
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
                    base64AccumIdx = 0;
                }
                buf[bufIdx++] = $47741c99b3ffda78$var$minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }
            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character
                if (uChar === $47741c99b3ffda78$var$andChar) buf[bufIdx++] = $47741c99b3ffda78$var$minusChar;
            }
        } else {
            if (!inBase64) {
                buf[bufIdx++] = $47741c99b3ffda78$var$andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;
                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
};
$47741c99b3ffda78$var$Utf7IMAPEncoder.prototype.end = function() {
    var buf = $47741c99b3ffda78$require$Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = $47741c99b3ffda78$var$minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
};
// -- Decoding
function $47741c99b3ffda78$var$Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
}
var $47741c99b3ffda78$var$base64IMAPChars = $47741c99b3ffda78$var$base64Chars.slice();
$47741c99b3ffda78$var$base64IMAPChars[",".charCodeAt(0)] = true;
$47741c99b3ffda78$var$Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).
    for(var i = 0; i < buf.length; i++){
        if (!inBase64) // Write direct chars until '&'
        {
            if (buf[i] == $47741c99b3ffda78$var$andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i + 1;
                inBase64 = true;
            }
        } else if (!$47741c99b3ffda78$var$base64IMAPChars[buf[i]]) {
            if (i == lastI && buf[i] == $47741c99b3ffda78$var$minusChar) res += "&";
            else {
                var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, "/");
                res += this.iconv.decode($47741c99b3ffda78$require$Buffer.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i] != $47741c99b3ffda78$var$minusChar) i--;
            lastI = i + 1;
            inBase64 = false;
            base64Accum = "";
        }
    }
    if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode($47741c99b3ffda78$require$Buffer.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
};
$47741c99b3ffda78$var$Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode($47741c99b3ffda78$require$Buffer.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
};

});

parcelRequire.register("kE7ef", function(module, exports) {

$parcel$export(module.exports, "_sbcs", () => $f07d268e8a97f5b9$export$90ce6c201c0ff1a9, (v) => $f07d268e8a97f5b9$export$90ce6c201c0ff1a9 = v);
// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 
var $f07d268e8a97f5b9$export$90ce6c201c0ff1a9;
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $f07d268e8a97f5b9$require$Buffer = $xaL3N.Buffer;
$f07d268e8a97f5b9$export$90ce6c201c0ff1a9 = $f07d268e8a97f5b9$var$SBCSCodec;
function $f07d268e8a97f5b9$var$SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) throw new Error("SBCS codec is called without the data.");
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for(var i = 0; i < 128; i++)asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = $f07d268e8a97f5b9$require$Buffer.from(codecOptions.chars, "ucs2");
    // Encoding buffer.
    var encodeBuf = $f07d268e8a97f5b9$require$Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for(var i = 0; i < codecOptions.chars.length; i++)encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
}
$f07d268e8a97f5b9$var$SBCSCodec.prototype.encoder = $f07d268e8a97f5b9$var$SBCSEncoder;
$f07d268e8a97f5b9$var$SBCSCodec.prototype.decoder = $f07d268e8a97f5b9$var$SBCSDecoder;
function $f07d268e8a97f5b9$var$SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}
$f07d268e8a97f5b9$var$SBCSEncoder.prototype.write = function(str) {
    var buf = $f07d268e8a97f5b9$require$Buffer.alloc(str.length);
    for(var i = 0; i < str.length; i++)buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
};
$f07d268e8a97f5b9$var$SBCSEncoder.prototype.end = function() {};
function $f07d268e8a97f5b9$var$SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}
$f07d268e8a97f5b9$var$SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = $f07d268e8a97f5b9$require$Buffer.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for(var i = 0; i < buf.length; i++){
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
};
$f07d268e8a97f5b9$var$SBCSDecoder.prototype.end = function() {};

});

parcelRequire.register("gqgPN", function(module, exports) {
"use strict";
// Manually added data to be used by sbcs codec in addition to generated one.
module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xc4\xc9\xd6\xdc\xe1\xe4\xe9\xed\xf3\xf4\xf6\xf5\xfa\xfc\xb0\xa3\xa7\xb6\xdf\xae\xa9\xa8\xac\xab\xbb\xa0\xd5\xf7\xc1\xcd\xd3\xd4\xda\xdd\xfd"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": "\xb0\xb7\xa0"
    },
    "mik": {
        "type": "_sbcs",
        "chars": "\xa7\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\xe9\xe2\x84\xe0\x86\xe7\xea\xeb\xe8\xef\xee\x8d\x8e\x8f\x90\xf4\xa4\xfb\xf9\xa3\xab\xbb\xb5\xb0\xb7\xb2\xa0"
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
};

});

parcelRequire.register("klRRI", function(module, exports) {
"use strict";
// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
        "type": "_sbcs",
        "chars": "\xa0"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
        "type": "_sbcs",
        "chars": "\xa0\xa4\xa6\xa7\xa8\xa9\xab\xac\xad\xae\xb0\xb1\xb4\xb5\xb6\xb7\xb8\xbb\xc1\xc2\xc4\xc7\xc9\xcb\xcd\xce\xd3\xd4\xd6\xd7\xda\xdc\xdd\xdf\xe1\xe2\xe4\xe7\xe9\xeb\xed\xee\xf3\xf4\xf6\xf7\xfa\xfc\xfd"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
        "type": "_sbcs",
        "chars": "\xa0\xa4\xa6\xa7\xa9\xab\xac\xad\xae\xb0\xb1\xb5\xb6\xb7\xbb"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
        "type": "_sbcs",
        "chars": "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
        "type": "_sbcs",
        "chars": "\xa0\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xab\xac\xad\xae\xb0\xb1\xb2\xb3\xb5\xb6\xb7\xbb\xbd"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
        "type": "_sbcs",
        "chars": "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xff"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
        "type": "_sbcs",
        "chars": "\xa0\xa1\xa2\xa3\xa5\xa6\xa7\xa8\xa9\xd7\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xf7\xbb\xbc\xbd\xbe\xbf"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
        "type": "_sbcs",
        "chars": "\xa0\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xbb\xbc\xbd\xbe\xd7\xe0\xe2\xe7\xe8\xe9\xea\xeb\xee\xef\xf4\xf7\xf9\xfb\xfc"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
        "type": "_sbcs",
        "chars": "\xa8\xb8\xaf\xa0\xa2\xa3\xa4\xa6\xa7\xd8\xa9\xab\xac\xad\xae\xc6\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xf8\xb9\xbb\xbc\xbd\xbe\xe6\xc4\xc5\xc9\xd3\xd5\xd6\xd7\xdc\xdf\xe4\xe5\xe9\xf3\xf5\xf6\xf7\xfc"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
        "type": "_sbcs",
        "chars": "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcd\xce\xcf\xd1\xd3\xd4\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xed\xee\xef\xf1\xf3\xf4\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xff"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    },
    "cp28591": "iso88591",
    "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa4\xa7\xa8\xad\xb0\xb4\xb8\xc1\xc2\xc4\xc7\xc9\xcb\xcd\xce\xd3\xd4\xd6\xd7\xda\xdc\xdd\xdf\xe1\xe2\xe4\xe7\xe9\xeb\xed\xee\xf3\xf4\xf6\xf7\xfa\xfc\xfd"
    },
    "cp28592": "iso88592",
    "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa3\xa4\xa7\xa8\xad\xb0\xb2\xb3\xb4\xb5\xb7\xb8\xbd\xc0\xc1\xc2\xc4\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd6\xd7\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe4\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf6\xf7\xf9\xfa\xfb\xfc"
    },
    "cp28593": "iso88593",
    "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa4\xa7\xa8\xad\xaf\xb0\xb4\xb8\xc1\xc2\xc3\xc4\xc5\xc6\xc9\xcb\xcd\xce\xd4\xd5\xd6\xd7\xd8\xda\xdb\xdc\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe9\xeb\xed\xee\xf4\xf5\xf6\xf7\xf8\xfa\xfb\xfc"
    },
    "cp28594": "iso88594",
    "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xad\xa7"
    },
    "cp28595": "iso88595",
    "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa4\xad"
    },
    "cp28596": "iso88596",
    "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa3\xa6\xa7\xa8\xa9\xab\xac\xad\xb0\xb1\xb2\xb3\xb7\xbb\xbd"
    },
    "cp28597": "iso88597",
    "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xd7\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xf7\xbb\xbc\xbd\xbe"
    },
    "cp28598": "iso88598",
    "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xff"
    },
    "cp28599": "iso88599",
    "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa7\xad\xb0\xb7\xc1\xc2\xc3\xc4\xc5\xc6\xc9\xcb\xcd\xce\xcf\xd0\xd3\xd4\xd5\xd6\xd8\xda\xdb\xdc\xdd\xde\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe9\xeb\xed\xee\xef\xf0\xf3\xf4\xf5\xf6\xf8\xfa\xfb\xfc\xfd\xfe"
    },
    "cp28600": "iso885910",
    "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
    },
    "cp28601": "iso885911",
    "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa2\xa3\xa4\xa6\xa7\xd8\xa9\xab\xac\xad\xae\xc6\xb0\xb1\xb2\xb3\xb5\xb6\xb7\xf8\xb9\xbb\xbc\xbd\xbe\xe6\xc4\xc5\xc9\xd3\xd5\xd6\xd7\xdc\xdf\xe4\xe5\xe9\xf3\xf5\xf6\xf7\xfc"
    },
    "cp28603": "iso885913",
    "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa3\xa7\xa9\xad\xae\xb6\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd8\xd9\xda\xdb\xdc\xdd\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf8\xf9\xfa\xfb\xfc\xfd\xff"
    },
    "cp28604": "iso885914",
    "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa5\xa7\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb5\xb6\xb7\xb9\xba\xbb\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    },
    "cp28605": "iso885915",
    "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa7\xa9\xab\xad\xb0\xb1\xb6\xb7\xbb\xc0\xc1\xc2\xc4\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd6\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe4\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf2\xf3\xf4\xf6\xf9\xfa\xfb\xfc\xff"
    },
    "cp28606": "iso885916",
    "cp437": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xec\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xff\xd6\xdc\xa2\xa3\xa5\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xac\xbd\xbc\xa1\xab\xbb\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
        "type": "_sbcs",
        "chars": "\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
        "type": "_sbcs",
        "chars": "\xfc\xe9\xe4\xe5\xc4\xc5\xc9\xe6\xc6\xf6\xa2\xd6\xdc\xf8\xa3\xd8\xd7\xa4\xf3\xa6\xa9\xae\xac\xbd\xbc\xab\xbb\xd3\xdf\xf5\xd5\xb5\xad\xb1\xbe\xb6\xa7\xf7\xb0\xb7\xb9\xb3\xb2\xa0"
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xec\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xff\xd6\xdc\xf8\xa3\xd8\xd7\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xae\xac\xbd\xbc\xa1\xab\xbb\xc1\xc2\xc0\xa9\xa2\xa5\xe3\xc3\xa4\xf0\xd0\xca\xcb\xc8\xcd\xce\xcf\xa6\xcc\xd3\xdf\xd4\xd2\xf5\xd5\xb5\xfe\xde\xda\xdb\xd9\xfd\xdd\xaf\xb4\xad\xb1\xbe\xb6\xa7\xf7\xb8\xb0\xa8\xb7\xb9\xb3\xb2\xa0"
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe7\xeb\xee\xc4\xc9\xf4\xf6\xd6\xdc\xd7\xe1\xed\xf3\xfa\xac\xab\xbb\xc1\xc2\xa4\xcb\xcd\xce\xd3\xdf\xd4\xda\xfd\xdd\xb4\xad\xa7\xf7\xb8\xb0\xa8\xa0"
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
        "type": "_sbcs",
        "chars": "\xab\xbb\xa4\xad\xa7\xa0"
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
        "type": "_sbcs",
        "chars": "\xa3\xd7\xae\xac\xbd\xbc\xab\xbb\xa9\xa2\xa5\xa4\xa6\xb5\xaf\xb4\xad\xb1\xbe\xb6\xa7\xf7\xb8\xb0\xa8\xb7\xb9\xb3\xb2\xa0"
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xd6\xdc\xf8\xa3\xd8\xe1\xed\xf3\xfa\xf1\xd1\xbf\xae\xac\xbd\xbc\xa1\xab\xbb\xc1\xc2\xc0\xa9\xa2\xa5\xe3\xc3\xa4\xba\xaa\xca\xcb\xc8\xcd\xce\xcf\xa6\xcc\xd3\xdf\xd4\xd2\xf5\xd5\xb5\xd7\xda\xdb\xd9\xec\xff\xaf\xb4\xad\xb1\xbe\xb6\xa7\xf7\xb8\xb0\xa8\xb7\xb9\xb3\xb2\xa0"
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xec\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xff\xd6\xdc\xf8\xa3\xd8\xd7\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xae\xac\xbd\xbc\xa1\xab\xbb\xc1\xc2\xc0\xa9\xa2\xa5\xe3\xc3\xa4\xf0\xd0\xca\xcb\xc8\xcd\xce\xcf\xa6\xcc\xd3\xdf\xd4\xd2\xf5\xd5\xb5\xfe\xde\xda\xdb\xd9\xfd\xdd\xaf\xb4\xad\xb1\xbe\xb6\xa7\xf7\xb8\xb0\xa8\xb7\xb9\xb3\xb2\xa0"
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe3\xe0\xc1\xe7\xea\xca\xe8\xcd\xd4\xec\xc3\xc2\xc9\xc0\xc8\xf4\xf5\xf2\xda\xf9\xcc\xd5\xdc\xa2\xa3\xd9\xd3\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xd2\xac\xbd\xbc\xa1\xab\xbb\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xd0\xf0\xde\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xfe\xfb\xdd\xfd\xd6\xdc\xf8\xa3\xd8\xe1\xed\xf3\xfa\xc1\xcd\xd3\xda\xbf\xac\xbd\xbc\xa1\xab\xbb\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
        "type": "_sbcs",
        "chars": "\xa2\xa3\xa5\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xac\xbd\xbc\xa1\xab\xbb\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xc2\xe0\xb6\xe7\xea\xeb\xe8\xef\xee\xc0\xa7\xc9\xc8\xca\xf4\xcb\xcf\xfb\xf9\xa4\xd4\xdc\xa2\xa3\xd9\xdb\xa6\xb4\xf3\xfa\xa8\xb8\xb3\xaf\xce\xac\xbd\xbc\xbe\xab\xbb\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
        "type": "_sbcs",
        "chars": "\x00\x01\x02\x03\x04\x05\x06\x07\b	\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\xb0\xb7\xb1\xbd\xbc\xab\xbb\xa0\xad\xa3\xa4\xa2\xa6\xac\xf7\xd7"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
        "type": "_sbcs",
        "chars": "\xc7\xfc\xe9\xe2\xe4\xe0\xe5\xe7\xea\xeb\xe8\xef\xee\xec\xc4\xc5\xc9\xe6\xc6\xf4\xf6\xf2\xfb\xf9\xff\xd6\xdc\xf8\xa3\xd8\xe1\xed\xf3\xfa\xf1\xd1\xaa\xba\xbf\xac\xbd\xbc\xa1\xab\xa4\xdf\xb5\xb1\xf7\xb0\xb7\xb2\xa0"
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
        "type": "_sbcs",
        "chars": "\xb0\xb7\xa4\xa0"
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
        "type": "_sbcs",
        "chars": "\xb7\xac\xa6\xa9\xb2\xb3\xa3\xbd\xab\xbb\xad\xb1\xa7\xb0\xa8\xa0"
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xff"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
        "type": "_sbcs",
        "chars": "\xd7\xf7\x88\xa0\xa4\xad"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xad\xa7"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
        "type": "_sbcs",
        "chars": "\xb7\xa4\xa0"
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb5\xb6\xb7\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcd\xce\xcf\xd1\xd3\xd4\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xed\xee\xef\xf1\xf3\xf4\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xff"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa2\xac\xa6"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
        "type": "_sbcs",
        "chars": "\xa2\xac\xa6\xa0"
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
        "type": "_sbcs",
        "chars": "\x81\x82\x83\x84\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa5\xa6\xa7\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb5\xb6\xb7\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcd\xce\xcf\xd1\xd3\xd4\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdf\xe0\xe1\xe2\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xed\xee\xef\xf1\xf3\xf4\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xff"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xb0\xa2\xa3\xa7\xb6\xdf\xae\xb4\xa8\xd8\xb1\xb5\xaa\xba\xf8\xbf\xa1\xac\xab\xa0\xc0\xc3\xd5\xf7\xa9\xa4\xc6\xbb\xb7\xc2\xc1\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xcb\xb8\xca\xe6"
    },
    "maccyrillic": {
        "type": "_sbcs",
        "chars": "\xb0\xa2\xa3\xa7\xb6\xae\xa9\xb1\xb5\xac\xab\xbb\xa0\xf7\xa4"
    },
    "macgreek": {
        "type": "_sbcs",
        "chars": "\xc4\xb9\xb2\xc9\xb3\xd6\xdc\xe0\xe2\xe4\xa8\xe7\xe9\xe8\xea\xeb\xa3\xee\xef\xbd\xf4\xf6\xa6\xad\xf9\xfb\xfc\xdf\xae\xa9\xa7\xb0\xb1\xa5\xac\xab\xbb\xa0\xf7"
    },
    "maciceland": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xdd\xb0\xa2\xa3\xa7\xb6\xdf\xae\xa9\xb4\xa8\xc6\xd8\xb1\xa5\xb5\xaa\xba\xe6\xf8\xbf\xa1\xac\xab\xbb\xa0\xc0\xc3\xd5\xf7\xff\xa4\xd0\xf0\xde\xfe\xfd\xb7\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xb8"
    },
    "macroman": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xb0\xa2\xa3\xa7\xb6\xdf\xae\xa9\xb4\xa8\xc6\xd8\xb1\xa5\xb5\xaa\xba\xe6\xf8\xbf\xa1\xac\xab\xbb\xa0\xc0\xc3\xd5\xf7\xff\xa4\xb7\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xb8"
    },
    "macromania": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xb0\xa2\xa3\xa7\xb6\xdf\xae\xa9\xb4\xa8\xb1\xa5\xb5\xaa\xba\xbf\xa1\xac\xab\xbb\xa0\xc0\xc3\xd5\xf7\xff\xa4\xb7\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xb8"
    },
    "macthai": {
        "type": "_sbcs",
        "chars": "\xab\xbb\xa0\uFEFF\xae\xa9"
    },
    "macturkish": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xb0\xa2\xa3\xa7\xb6\xdf\xae\xa9\xb4\xa8\xc6\xd8\xb1\xa5\xb5\xaa\xba\xe6\xf8\xbf\xa1\xac\xab\xbb\xa0\xc0\xc3\xd5\xf7\xff\xb7\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xb8"
    },
    "macukraine": {
        "type": "_sbcs",
        "chars": "\xb0\xa3\xa7\xb6\xae\xa9\xb1\xb5\xac\xab\xbb\xa0\xf7\xa4"
    },
    "koi8r": {
        "type": "_sbcs",
        "chars": "\xa0\xb0\xb2\xb7\xf7\xa9"
    },
    "koi8u": {
        "type": "_sbcs",
        "chars": "\xa0\xb0\xb2\xb7\xf7\xa9"
    },
    "koi8ru": {
        "type": "_sbcs",
        "chars": "\xa0\xb0\xb2\xb7\xf7\xa9"
    },
    "koi8t": {
        "type": "_sbcs",
        "chars": "\xa4\xa6\xa7\xab\xac\xad\xae\xb0\xb1\xb2\xb6\xb7\xbb\xa9"
    },
    "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0)(\xbb\xab.,-"
    },
    "rk1048": {
        "type": "_sbcs",
        "chars": "\xa0\xa4\xa6\xa7\xa9\xab\xac\xad\xae\xb0\xb1\xb5\xb6\xb7\xbb"
    },
    "tcvn": {
        "type": "_sbcs",
        "chars": "\x00\xda\x03\x07\b	\n\v\f\r\x0e\x0f\x10\xdd\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\xc0\xc3\xc1\xc8\xc9\xcc\xcd\xd2\xd5\xd3\xd9\xa0\xc2\xca\xd4\xe2\xea\xf4\xe0\xe3\xe1\xe8\xe9\xec\xed\xf2\xf5\xf3\xf9\xfa\xfd"
    },
    "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\x8d\x8e\x8f\x90\x9d\x9e\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    },
    "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\x8d\x8e\x8f\x90\x9d\x9e\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    },
    "pt154": {
        "type": "_sbcs",
        "chars": "\xa0\xa7\xa9\xab\xac\xae\xb0\xb6\xb7\xbb"
    },
    "viscii": {
        "type": "_sbcs",
        "chars": "\x00\x01\x03\x04\x07\b	\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x15\x16\x17\x18\x1a\x1b\x1c\x1d\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\xd5\xc0\xc1\xc2\xc3\xc8\xc9\xca\xcc\xcd\xd2\xd3\xd4\xd9\xda\xdd\xe0\xe1\xe2\xe3\xe8\xe9\xea\xec\xed\xf2\xf3\xf4\xf5\xf9\xfa\xfd"
    },
    "iso646cn": {
        "type": "_sbcs",
        "chars": "\x00\x01\x02\x03\x04\x05\x06\x07\b	\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#\xa5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\x7f"
    },
    "iso646jp": {
        "type": "_sbcs",
        "chars": "\x00\x01\x02\x03\x04\x05\x06\x07\b	\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xa5]^_`abcdefghijklmnopqrstuvwxyz{|}\x7f"
    },
    "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xc0\xc2\xc8\xca\xcb\xce\xcf\xb4\xa8\xd9\xdb\xaf\xdd\xfd\xb0\xc7\xe7\xd1\xf1\xa1\xbf\xa4\xa3\xa5\xa7\xa2\xe2\xea\xf4\xfb\xe1\xe9\xf3\xfa\xe0\xe8\xf2\xf9\xe4\xeb\xf6\xfc\xc5\xee\xd8\xc6\xe5\xed\xf8\xe6\xc4\xec\xd6\xdc\xc9\xef\xdf\xd4\xc1\xc3\xe3\xd0\xf0\xcd\xcc\xd3\xd2\xd5\xf5\xda\xff\xde\xfe\xb7\xb5\xb6\xbe\xbc\xbd\xaa\xba\xab\xbb\xb1"
    },
    "macintosh": {
        "type": "_sbcs",
        "chars": "\xc4\xc5\xc7\xc9\xd1\xd6\xdc\xe1\xe0\xe2\xe4\xe3\xe5\xe7\xe9\xe8\xea\xeb\xed\xec\xee\xef\xf1\xf3\xf2\xf4\xf6\xf5\xfa\xf9\xfb\xfc\xb0\xa2\xa3\xa7\xb6\xdf\xae\xa9\xb4\xa8\xc6\xd8\xb1\xa5\xb5\xaa\xba\xe6\xf8\xbf\xa1\xac\xab\xbb\xa0\xc0\xc3\xd5\xf7\xff\xa4\xb7\xc2\xca\xc1\xcb\xc8\xcd\xce\xcf\xcc\xd3\xd4\xd2\xda\xdb\xd9\xaf\xb8"
    },
    "ascii": {
        "type": "_sbcs",
        "chars": ""
    },
    "tis620": {
        "type": "_sbcs",
        "chars": ""
    }
};

});

parcelRequire.register("9Caog", function(module, exports) {

$parcel$export(module.exports, "_dbcs", () => $6fffb8feeb31ceca$export$d4d33b1e1c7abf2e, (v) => $6fffb8feeb31ceca$export$d4d33b1e1c7abf2e = v);
// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.
var $6fffb8feeb31ceca$export$d4d33b1e1c7abf2e;
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $6fffb8feeb31ceca$require$Buffer = $xaL3N.Buffer;
$6fffb8feeb31ceca$export$d4d33b1e1c7abf2e = $6fffb8feeb31ceca$var$DBCSCodec;
var $6fffb8feeb31ceca$var$UNASSIGNED = -1, $6fffb8feeb31ceca$var$GB18030_CODE = -2, $6fffb8feeb31ceca$var$SEQ_START = -10, $6fffb8feeb31ceca$var$NODE_START = -1000, $6fffb8feeb31ceca$var$UNASSIGNED_NODE = new Array(0x100), $6fffb8feeb31ceca$var$DEF_CHAR = -1;
for(var $6fffb8feeb31ceca$var$i = 0; $6fffb8feeb31ceca$var$i < 0x100; $6fffb8feeb31ceca$var$i++)$6fffb8feeb31ceca$var$UNASSIGNED_NODE[$6fffb8feeb31ceca$var$i] = $6fffb8feeb31ceca$var$UNASSIGNED;
// Class DBCSCodec reads and initializes mapping tables.
function $6fffb8feeb31ceca$var$DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
    // Load tables.
    var mappingTable = codecOptions.table();
    // Decode tables: MBCS -> Unicode.
    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = $6fffb8feeb31ceca$var$UNASSIGNED_NODE.slice(0); // Create root node.
    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];
    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for(var i = 0; i < mappingTable.length; i++)this._addDecodeChunk(mappingTable[i]);
    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.
        // Add GB18030 common decode nodes.
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push($6fffb8feeb31ceca$var$UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push($6fffb8feeb31ceca$var$UNASSIGNED_NODE.slice(0));
        // Fill out the tree
        var firstByteNode = this.decodeTables[0];
        for(var i = 0x81; i <= 0xFE; i++){
            var secondByteNode = this.decodeTables[$6fffb8feeb31ceca$var$NODE_START - firstByteNode[i]];
            for(var j = 0x30; j <= 0x39; j++){
                if (secondByteNode[j] === $6fffb8feeb31ceca$var$UNASSIGNED) secondByteNode[j] = $6fffb8feeb31ceca$var$NODE_START - commonThirdByteNodeIdx;
                else if (secondByteNode[j] > $6fffb8feeb31ceca$var$NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
                var thirdByteNode = this.decodeTables[$6fffb8feeb31ceca$var$NODE_START - secondByteNode[j]];
                for(var k = 0x81; k <= 0xFE; k++){
                    if (thirdByteNode[k] === $6fffb8feeb31ceca$var$UNASSIGNED) thirdByteNode[k] = $6fffb8feeb31ceca$var$NODE_START - commonFourthByteNodeIdx;
                    else if (thirdByteNode[k] === $6fffb8feeb31ceca$var$NODE_START - commonFourthByteNodeIdx) continue;
                    else if (thirdByteNode[k] > $6fffb8feeb31ceca$var$NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
                    var fourthByteNode = this.decodeTables[$6fffb8feeb31ceca$var$NODE_START - thirdByteNode[k]];
                    for(var l = 0x30; l <= 0x39; l++)if (fourthByteNode[l] === $6fffb8feeb31ceca$var$UNASSIGNED) fourthByteNode[l] = $6fffb8feeb31ceca$var$GB18030_CODE;
                }
            }
        }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    // Encode tables: Unicode -> DBCS.
    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];
    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) for(var i = 0; i < codecOptions.encodeSkipVals.length; i++){
        var val = codecOptions.encodeSkipVals[i];
        if (typeof val === "number") skipEncodeChars[val] = true;
        else for(var j = val.from; j <= val.to; j++)skipEncodeChars[j] = true;
    }
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);
    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for(var uChar in codecOptions.encodeAdd)if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === $6fffb8feeb31ceca$var$UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === $6fffb8feeb31ceca$var$UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
}
$6fffb8feeb31ceca$var$DBCSCodec.prototype.encoder = $6fffb8feeb31ceca$var$DBCSEncoder;
$6fffb8feeb31ceca$var$DBCSCodec.prototype.decoder = $6fffb8feeb31ceca$var$DBCSDecoder;
// Decoder helpers
$6fffb8feeb31ceca$var$DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for(; addr > 0; addr >>>= 8)bytes.push(addr & 0xFF);
    if (bytes.length == 0) bytes.push(0);
    var node = this.decodeTables[0];
    for(var i = bytes.length - 1; i > 0; i--){
        var val = node[bytes[i]];
        if (val == $6fffb8feeb31ceca$var$UNASSIGNED) {
            node[bytes[i]] = $6fffb8feeb31ceca$var$NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = $6fffb8feeb31ceca$var$UNASSIGNED_NODE.slice(0));
        } else if (val <= $6fffb8feeb31ceca$var$NODE_START) node = this.decodeTables[$6fffb8feeb31ceca$var$NODE_START - val];
        else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
};
$6fffb8feeb31ceca$var$DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);
    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;
    // Write all other elements of the chunk to the table.
    for(var k = 1; k < chunk.length; k++){
        var part = chunk[k];
        if (typeof part === "string") for(var l = 0; l < part.length;){
            var code = part.charCodeAt(l++);
            if (0xD800 <= code && code < 0xDC00) {
                var codeTrail = part.charCodeAt(l++);
                if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (0x0FF0 < code && code <= 0x0FFF) {
                var len = 0xFFF - code + 2;
                var seq = [];
                for(var m = 0; m < len; m++)seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.
                writeTable[curAddr++] = $6fffb8feeb31ceca$var$SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
            } else writeTable[curAddr++] = code; // Basic char
        }
        else if (typeof part === "number") {
            var charCode = writeTable[curAddr - 1] + 1;
            for(var l = 0; l < part; l++)writeTable[curAddr++] = charCode++;
        } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
};
// Encoder helpers
$6fffb8feeb31ceca$var$DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined) this.encodeTable[high] = $6fffb8feeb31ceca$var$UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
};
$6fffb8feeb31ceca$var$DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= $6fffb8feeb31ceca$var$SEQ_START) this.encodeTableSeq[$6fffb8feeb31ceca$var$SEQ_START - bucket[low]][$6fffb8feeb31ceca$var$DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == $6fffb8feeb31ceca$var$UNASSIGNED) bucket[low] = dbcsCode;
};
$6fffb8feeb31ceca$var$DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    var node;
    if (bucket[low] <= $6fffb8feeb31ceca$var$SEQ_START) // There's already a sequence with  - use it.
    node = this.encodeTableSeq[$6fffb8feeb31ceca$var$SEQ_START - bucket[low]];
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== $6fffb8feeb31ceca$var$UNASSIGNED) node[$6fffb8feeb31ceca$var$DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = $6fffb8feeb31ceca$var$SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }
    // Traverse the character tree, allocating new nodes as needed.
    for(var j = 1; j < seq.length - 1; j++){
        var oldVal = node[uCode];
        if (typeof oldVal === "object") node = oldVal;
        else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[$6fffb8feeb31ceca$var$DEF_CHAR] = oldVal;
        }
    }
    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
};
$6fffb8feeb31ceca$var$DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for(var i = 0; i < 0x100; i++){
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode]) continue;
        if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
        } else if (uCode <= $6fffb8feeb31ceca$var$NODE_START) {
            var subNodeIdx = $6fffb8feeb31ceca$var$NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {
                var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.
                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
                else subNodeEmpty[subNodeIdx] = true;
            }
        } else if (uCode <= $6fffb8feeb31ceca$var$SEQ_START) {
            this._setEncodeSequence(this.decodeTableSeq[$6fffb8feeb31ceca$var$SEQ_START - uCode], mbCode);
            hasValues = true;
        }
    }
    return hasValues;
};
// == Encoder ==================================================================
function $6fffb8feeb31ceca$var$DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}
$6fffb8feeb31ceca$var$DBCSEncoder.prototype.write = function(str) {
    var newBuf = $6fffb8feeb31ceca$require$Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
    while(true){
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        } else {
            var uCode = nextChar;
            nextChar = -1;
        }
        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) {
            if (uCode < 0xDC00) {
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = $6fffb8feeb31ceca$var$UNASSIGNED;
                }
            } else if (leadSurrogate !== -1) {
                uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                leadSurrogate = -1;
            } else // Incomplete surrogate pair - only trail surrogate found.
            uCode = $6fffb8feeb31ceca$var$UNASSIGNED;
        } else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode;
            uCode = $6fffb8feeb31ceca$var$UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }
        // 2. Convert uCode character.
        var dbcsCode = $6fffb8feeb31ceca$var$UNASSIGNED;
        if (seqObj !== undefined && uCode != $6fffb8feeb31ceca$var$UNASSIGNED) {
            var resCode = seqObj[uCode];
            if (typeof resCode === "object") {
                seqObj = resCode;
                continue;
            } else if (typeof resCode == "number") dbcsCode = resCode;
            else if (resCode == undefined) {
                // Try default character for this sequence
                resCode = seqObj[$6fffb8feeb31ceca$var$DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.
                }
            }
            seqObj = undefined;
        } else if (uCode >= 0) {
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
            if (dbcsCode <= $6fffb8feeb31ceca$var$SEQ_START) {
                seqObj = this.encodeTableSeq[$6fffb8feeb31ceca$var$SEQ_START - dbcsCode];
                continue;
            }
            if (dbcsCode == $6fffb8feeb31ceca$var$UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = $6fffb8feeb31ceca$var$findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                    dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                    dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                    dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }
        // 3. Write dbcsCode character.
        if (dbcsCode === $6fffb8feeb31ceca$var$UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8; // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        } else if (dbcsCode < 0x1000000) {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = dbcsCode >> 8 & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        } else {
            newBuf[j++] = dbcsCode >>> 24;
            newBuf[j++] = dbcsCode >>> 16 & 0xFF;
            newBuf[j++] = dbcsCode >>> 8 & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
};
$6fffb8feeb31ceca$var$DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.
    var newBuf = $6fffb8feeb31ceca$require$Buffer.alloc(10), j = 0;
    if (this.seqObj) {
        var dbcsCode = this.seqObj[$6fffb8feeb31ceca$var$DEF_CHAR];
        if (dbcsCode !== undefined) {
            if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
            else {
                newBuf[j++] = dbcsCode >> 8; // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else ;
        this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
};
// Export for testing
$6fffb8feeb31ceca$var$DBCSEncoder.prototype.findIdx = $6fffb8feeb31ceca$var$findIdx;
// == Decoder ==================================================================
function $6fffb8feeb31ceca$var$DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBytes = [];
    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}
$6fffb8feeb31ceca$var$DBCSDecoder.prototype.write = function(buf) {
    var newBuf = $6fffb8feeb31ceca$require$Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for(var i = 0, j = 0; i < buf.length; i++){
        var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];
        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) ;
        else if (uCode === $6fffb8feeb31ceca$var$UNASSIGNED) {
            // TODO: Callback with seq.
            uCode = this.defaultCharUnicode.charCodeAt(0);
            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
        } else if (uCode === $6fffb8feeb31ceca$var$GB18030_CODE) {
            if (i >= 3) var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);
            else var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);
            var idx = $6fffb8feeb31ceca$var$findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= $6fffb8feeb31ceca$var$NODE_START) {
            nodeIdx = $6fffb8feeb31ceca$var$NODE_START - uCode;
            continue;
        } else if (uCode <= $6fffb8feeb31ceca$var$SEQ_START) {
            var seq = this.decodeTableSeq[$6fffb8feeb31ceca$var$SEQ_START - uCode];
            for(var k = 0; k < seq.length - 1; k++){
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
        } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode >= 0x10000) {
            uCode -= 0x10000;
            var uCodeLead = 0xD800 | uCode >> 10;
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;
            uCode = 0xDC00 | uCode & 0x3FF;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;
        // Reset trie node.
        nodeIdx = 0;
        seqStart = i + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
};
$6fffb8feeb31ceca$var$DBCSDecoder.prototype.end = function() {
    var ret = "";
    // Try to parse all remaining chars.
    while(this.prevBytes.length > 0){
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        // Parse remaining as usual.
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0) ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
};
// Binary search for GB18030. Returns largest i such that table[i] <= val.
function $6fffb8feeb31ceca$var$findIdx(table, val) {
    if (table[0] > val) return -1;
    var l = 0, r = table.length;
    while(l < r - 1){
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val) l = mid;
        else r = mid;
    }
    return l;
}

});

parcelRequire.register("9Wtr1", function(module, exports) {
"use strict";












// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.
module.exports = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("gFTJM"));
        },
        encodeAdd: {
            "\xa5": 0x5C,
            "": 0x7E
        },
        encodeSkipVals: [
            {
                from: 0xED40,
                to: 0xF940
            }
        ]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("djpaj"));
        },
        encodeAdd: {
            "\xa5": 0x5C,
            "": 0x7E
        }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("7vKCs"));
        }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("7vKCs")).concat((parcelRequire("j71gS")));
        }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("7vKCs")).concat((parcelRequire("j71gS")));
        },
        gb18030: function() {
            return (parcelRequire("6juhO"));
        },
        encodeSkipVals: [
            0x80
        ],
        encodeAdd: {
            "": 0xA2E3
        }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("2gKJ2"));
        }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("fkDu7"));
        }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
        type: "_dbcs",
        table: function() {
            return (parcelRequire("fkDu7")).concat((parcelRequire("bBQGb")));
        },
        encodeSkipVals: [
            // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
            // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
            // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
            0x8e69,
            0x8e6f,
            0x8e7e,
            0x8eab,
            0x8eb4,
            0x8ecd,
            0x8ed0,
            0x8f57,
            0x8f69,
            0x8f6e,
            0x8fcb,
            0x8ffe,
            0x906d,
            0x907a,
            0x90c4,
            0x90dc,
            0x90f1,
            0x91bf,
            0x92af,
            0x92b0,
            0x92b1,
            0x92b2,
            0x92d1,
            0x9447,
            0x94ca,
            0x95d9,
            0x96fc,
            0x9975,
            0x9b76,
            0x9b78,
            0x9b7b,
            0x9bc6,
            0x9bde,
            0x9bec,
            0x9bf6,
            0x9c42,
            0x9c53,
            0x9c62,
            0x9c68,
            0x9c6b,
            0x9c77,
            0x9cbc,
            0x9cbd,
            0x9cd0,
            0x9d57,
            0x9d5a,
            0x9dc4,
            0x9def,
            0x9dfb,
            0x9ea9,
            0x9eef,
            0x9efd,
            0x9f60,
            0x9fcb,
            0xa077,
            0xa0dc,
            0xa0df,
            0x8fcc,
            0x92c8,
            0x9644,
            0x96ed,
            // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
            0xa2a4,
            0xa2a5,
            0xa2a7,
            0xa2a6,
            0xa2cc,
            0xa2ce
        ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
};

});
parcelRequire.register("gFTJM", function(module, exports) {
module.exports = JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","\xb4\xa8",9,"\xb1\xd7"],["8180","\xf7\xb0\xa7"],["81b8",""],["81c8",""],["81da",""],["81f0","\xb6"],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');

});

parcelRequire.register("djpaj", function(module, exports) {
module.exports = JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","\xb4\xa8",9,"\xb1\xd7\xf7\xb0\xa7"],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2","\xb6"],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af","\xb8\xaf"],["8fa2c2","\xa1\xa6\xbf"],["8fa2eb","\xba\xaa\xa9\xae\xa4"],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1","\xc6"],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab","\xd8"],["8fa9af","\xde"],["8fa9c1","\xe6\xf0\xf8\xdf\xfe"],["8faaa1","\xc1\xc0\xc4\xc2\xc5\xc3\xc7\xc9\xc8\xcb\xca"],["8faaba","\xcd\xcc\xcf\xce\xd1\xd3\xd2\xd6\xd4\xd5\xda\xd9\xdc\xdb\xdd"],["8faba1","\xe1\xe0\xe4\xe2\xe5\xe3\xe7\xe9\xe8\xeb\xea"],["8fabbd","\xed\xec\xef\xee"],["8fabc5","\xf1\xf3\xf2\xf6\xf4\xf5\xfa\xf9\xfc\xfb\xfd\xff"],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');

});

parcelRequire.register("7vKCs", function(module, exports) {
module.exports = JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","\xb7\xa8",7,"\xb1\xd7\xf7\xb0\xa4\xa7"],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1","\xe1\xe0\xe9\xe8\xed\xec\xf3\xf2\xfa\xf9\xfc\xea"],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');

});

parcelRequire.register("j71gS", function(module, exports) {
module.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]');

});

parcelRequire.register("6juhO", function(module, exports) {
module.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

});

parcelRequire.register("2gKJ2", function(module, exports) {
module.exports = JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"\xb7\xa8\xad",9,"\xb1\xd7\xf7\xb0\xa7"],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,"\xb4\xb8\xa1\xbf\xa4\xb6\xae"],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,"\xc6\xd0\xaa"],["a8a6",""],["a8a8","\xd8\xba\xde"],["a8b1","",27,"",25,"",14,"\xbd\xbc\xbe"],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"\xe6\xf0\xf8\xdf\xfe",27,"",25,"",14,"\xb9\xb2\xb3"],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');

});

parcelRequire.register("fkDu7", function(module, exports) {
module.exports = JSON.parse('[["0","\\u0000",127],["a140","\xb7"],["a1a1","\xa7\xaf\xd7\xf7\xb1",4,""],["a240","\xb0",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');

});

parcelRequire.register("bBQGb", function(module, exports) {
module.exports = JSON.parse('[["8740","\uD85C\uDE67\uD85F\uDCB1\uD85F\uDCC5\uD850\uDEBF\uD84D\uDE17\uD85C\uDF52\uD85B\uDE8B\uD85C\uDCD2\uD868\uDF51\uD85F\uDC6C\uD85A\uDF23\uD856\uDE54\uD846\uDE63\uD84F\uDE06\uD84F\uDF61"],["8767","\uD862\uDFB9\uD85E\uDFEF\uD847\uDD5E\uD867\uDEB0\uD866\uDD45\uD847\uDD53\uD84D\uDE9E\uD858\uDC21"],["87a1","\uD856\uDCDE\uD850\uDD61\uD862\uDD0D\uD84C\uDDEA\uD842\uDE8A\uD84C\uDE5E\uD857\uDDB9\uD84D\uDE8E\uD85E\uDF65\uD85B\uDE88\uD857\uDD99\uD849\uDCBC\uD849\uDCC1\uD849\uDCC9\uD849\uDCCC\uD84D\uDDBB\uD86B\uDDFF"],["8840","",4,"\uD840\uDD0C\uD840\uDCD1\uD840\uDCCD\uD840\uDCCB\uD847\uDFE8\uD840\uDCCA\uD840\uDD0E\xc1\xc0\xc9\xc8\xd3\xd2\xca\xca\xca\xe1\xe0\xe9\xe8\xed\xec\xf3\xf2\xfa\xf9"],["88a1","\xfc\xea\xea\xea"],["8940","\uD868\uDFA9\uD844\uDD45"],["8943",""],["8946",""],["894c","\uD85D\uDF35"],["89a1",""],["89ab",""],["89b0","\uD842\uDDE7"],["89b5","\uD867\uDDF6\uD85C\uDC0E\uD868\uDD33"],["89c1",""],["89c5","\uD861\uDC6C\uD847\uDDCA\uD841\uDDD0\uD84A\uDEE6"],["8a40","\uD85F\uDD84"],["8a43","\uD843\uDC42\uD843\uDD15\uD854\uDD2B\uD84B\uDCC6\uD840\uDF41\uD853\uDDB8\uD865\uDCE5\uD860\uDCBE\uD84B\uDC38\uD860\uDD5D\uD85A\uDDF2\uD853\uDDEA\uD843\uDD7C\uD843\uDFB4\uD843\uDCD5\uD844\uDCF4\uD843\uDE96\uD843\uDC0B\uD843\uDF64\uD84B\uDCA9\uD860\uDE56\uD851\uDCD3"],["8a64","\uD843\uDD46\uD866\uDE4D\uD860\uDCE9\uD853\uDEA7\uD84B\uDCC2\uD865\uDDF4\uD854\uDEC7\uD865\uDFD4\uD85E\uDCC8\uD84B\uDD44"],["8a76","\uD858\uDCA5\uD84B\uDD4C\uD84A\uDFCA\uD844\uDC77\uD844\uDC6F"],["8aa1","\uD859\uDEDA\uD859\uDF16\uD85E\uDDA0\uD854\uDC52\uD843\uDC43\uD848\uDDA1\uD862\uDF4C\uD841\uDF31"],["8aac","\uD840\uDDA9\uD84B\uDD8D"],["8ab2","\uD851\uDDC8\uD841\uDCFC\uD858\uDC97\uD843\uDF4C\uD843\uDD96"],["8abb","\uD84A\uDE66\uD844\uDC9D\uD843\uDD9C\uD849\uDF75"],["8ac9","\uD869\uDE01\uD843\uDE09\uD84A\uDECF\uD84B\uDCC9"],["8ace","\uD844\uDCC8\uD84E\uDDC2\uD860\uDE9B\uD857\uDE49\uD848\uDCC7\uD843\uDF31\uD84B\uDCB2\uD865\uDF20\uD853\uDE3B"],["8adf","\uD85D\uDD74\uD84B\uDE8B\uD848\uDE08\uD869\uDE5B\uD863\uDCCD\uD843\uDE7A\uD843\uDC34\uD85A\uDC1C\uD844\uDCCF\uD84A\uDC03\uD84A\uDD39\uD854\uDDE3\uD843\uDE8C\uD843\uDF8D\uD843\uDEAA\uD843\uDF30\uD843\uDD47\uD844\uDD4F\uD843\uDE4C"],["8af6","\uD843\uDEAB\uD842\uDFA9\uD843\uDD48\uD844\uDCC0\uD844\uDD3D\uD849\uDE96\uD843\uDFAD"],["8b40","\uD84C\uDFF4\uD85D\uDE39\uD84A\uDFCE\uD843\uDD7E\uD843\uDD7F\uD84B\uDC51\uD84B\uDC55\uD843\uDE98\uD844\uDCC7\uD843\uDF2E\uD869\uDE32\uD85A\uDF50\uD863\uDCD2\uD863\uDD99\uD863\uDCCA"],["8b55","\uD867\uDEC3\uD85D\uDF5E\uD84B\uDDEE\uD859\uDD72\uD860\uDCBD\uD843\uDEFA\uD843\uDE0F\uD843\uDE77\uD843\uDEFB\uD853\uDDEB\uD843\uDCD6\uD849\uDFB5\uD844\uDCC9\uD843\uDE10\uD843\uDE78\uD844\uDC78\uD844\uDD48\uD860\uDE07\uD845\uDC55\uD843\uDE79\uD853\uDE50\uD84B\uDDA4\uD844\uDC1D\uD844\uDC1E\uD844\uDCF5\uD844\uDCF6\uD843\uDE11"],["8ba1","\uD85D\uDE94\uD860\uDECD\uD843\uDFB5\uD843\uDE7B\uD854\uDD7E\uD843\uDFB6\uD844\uDD80\uD854\uDED8\uD868\uDEBD\uD852\uDDDA\uD846\uDC3A\uD850\uDD77\uD860\uDE7C\uD855\uDF3D\uD856\uDF74\uD84C\uDD3D\uD846\uDFC1\uD87E\uDC78\uD840\uDC86\uD852\uDCE9\uD858\uDE6A"],["8bde","\uD858\uDF4B\uD859\uDE12\uD85A\uDD51\uD85E\uDCB2\uD863\uDE0F\uD866\uDC10\uD840\uDC87"],["8c40","\uD867\uDC73\uD850\uDD4E\uD854\uDDCD\uD857\uDD30\uD862\uDE32\uD84C\uDE81\uD868\uDD07\uD846\uDD80\uD861\uDF0F\uD868\uDEBA\uD842\uDE6F\uD866\uDD47\uD862\uDEEA\uD848\uDC7E\uD862\uDDE3\uD847\uDDB6\uD849\uDF12"],["8ca1","\uD84C\uDFF9\uD84F\uDC63"],["8ca7","\uD851\uDD05\uD852\uDE13\uD857\uDCA4\uD855\uDE95\uD863\uDDB9\uD845\uDC3F"],["8cc9",""],["8cce","\uD852\uDD7B\uD85C\uDD0D\uD85B\uDD74\uD85A\uDF15\uD85B\uDFBE\uD84C\uDE56\uD849\uDF96"],["8ce6","\uD84E\uDF1A\uD84D\uDD51\uD850\uDCEC\uD847\uDE23\uD840\uDDA4\uD85B\uDC41\uD840\uDE39\uD866\uDCFA"],["8d40","\uD842\uDF9F"],["8d42","\uD848\uDDC1\uD862\uDD6D\uD864\uDC79\uD868\uDDB5\uD85B\uDC46\uD861\uDEB2\uD85C\uDFFF\uD855\uDC9A\uD852\uDF0F"],["8da1","\uD862\uDDC0\uD84F\uDF41\uD840\uDF25\uD843\uDED8"],["8e40","\uD84F\uDED7\uD85B\uDED3\uD855\uDFE0\uD862\uDFE9\uD856\uDCE1\uD865\uDCD9\uD856\uDDAC\uD859\uDC8D\uD857\uDC01\uD854\uDF0E\uD857\uDCFE\uD856\uDFB4\uD85B\uDC7F\uD857\uDD20\uD857\uDC65\uD857\uDCC1\uD852\uDC82\uD851\uDD78"],["8ea1","\uD85B\uDE44\uD85B\uDED6\uD850\uDC57\uD858\uDC29\uD845\uDFF9\uD860\uDF6D\uD858\uDD21\uD858\uDD5A\uD858\uDED0\uD858\uDF51\uD845\uDE61\uD840\uDC68\uD84D\uDF66\uD860\uDF3A\uD859\uDC89\uD868\uDC87\uD85B\uDCC3\uD849\uDF14\uD859\uDE26\uD84F\uDDE3\uD859\uDEE8\uD862\uDE48\uD849\uDEF6\uD859\uDC98\uD853\uDFB8\uD845\uDC8A\uD846\uDC5E\uD852\uDE65\uD852\uDE95\uD842\uDF0D\uD85A\uDE52\uD84F\uDD7E\uD845\uDCFD\uD85A\uDF0A\uD852\uDDA7\uD84D\uDD30\uD845\uDF73\uD84F\uDDF8\uD87E\uDD94"],["8f40","\uD843\uDE16\uD845\uDFB4\uD84C\uDD7D\uD84D\uDD5A\uD84F\uDE8B\uD85B\uDDA3\uD85A\uDF05\uD85A\uDF97\uD84D\uDDCE\uD85B\uDDA5\uD85B\uDED4\uD85B\uDE42\uD84B\uDEEF\uD856\uDFE4\uD84F\uDCB5\uD85A\uDF96\uD85B\uDE77\uD85B\uDE43\uD857\uDC91\uD857\uDCC0\uD85B\uDE99"],["8fa1","\uD861\uDE25\uD861\uDE3B\uD85C\uDC88\uD845\uDD82\uD85C\uDCCD\uD87E\uDDB2\uD846\uDCA2\uD85C\uDF9A\uD868\uDCF8\uD84B\uDC27\uD85D\uDDE0\uD84F\uDDB9\uD85D\uDDE4\uD85D\uDF0F\uD862\uDE25\uD85E\uDD24\uD85E\uDEBD\uD85E\uDE59\uD85E\uDF3A\uD84F\uDF8F\uD85E\uDF38\uD855\uDC30\uD855\uDD65\uD852\uDE7A\uD845\uDEDF\uD85F\uDD54\uD85F\uDD8F\uD87E\uDDD4\uD85F\uDD53\uD85F\uDD98\uD85F\uDDBD\uD846\uDD10\uD853\uDCC9"],["9040","\uD860\uDC02\uD844\uDC14\uD852\uDD8A\uD860\uDDBC\uD85C\uDD0C\uD860\uDF65\uD861\uDC12\uD868\uDE9F\uD842\uDE50\uD862\uDDDE\uD861\uDD3D\uD84F\uDDBB\uD84C\uDE62\uD868\uDC14\uD861\uDEBC\uD861\uDD01\uD848\uDF25\uD85B\uDED7\uD861\uDD3C\uD85E\uDEBE\uD861\uDD6C\uD861\uDE0B\uD861\uDF13\uD861\uDEE6\uD862\uDD33\uD847\uDE89\uD855\uDDB9\uD862\uDEC6\uD84F\uDC9B\uD862\uDF0C\uD855\uDDDB"],["90a1","\uD843\uDD31\uD862\uDEE1\uD862\uDFEB\uD862\uDEE2\uD862\uDEE5\uD862\uDFEC\uD863\uDC39\uD862\uDFFF\uD849\uDE7A\uD861\uDED8\uD844\uDE7C\uD84F\uDE2E\uD85B\uDED5\uD862\uDEE0\uD85B\uDCB8\uD840\uDE74\uD859\uDC10\uD864\uDCAF\uD864\uDCE5\uD852\uDED1\uD846\uDD15\uD84C\uDF0A\uD852\uDEE9\uD864\uDDD5\uD864\uDDEB\uD84C\uDCB7\uD84C\uDCBC\uD855\uDC6C\uD865\uDC33\uD865\uDC1D\uD85E\uDD7A\uD85C\uDD75\uD841\uDE30\uD850\uDD5C"],["9140","\uD855\uDF06\uD85B\uDD27\uD845\uDED3\uD852\uDE29\uD866\uDC57\uD866\uDD05\uD855\uDF25\uD864\uDCB1\uD866\uDFD5\uD866\uDF05\uD861\uDE00\uD85A\uDDA8\uD84C\uDC7D\uD867\uDD3E\uD846\uDC63\uD850\uDE4B\uD867\uDE68\uD867\uDFB7\uD868\uDD92\uD868\uDDAB\uD868\uDCE1\uD868\uDD23\uD868\uDDDF\uD868\uDD34"],["91a1","\uD848\uDD5B\uD868\uDD93\uD868\uDE20\uD846\uDD3B\uD868\uDE33\uD868\uDCB9\uD868\uDEB4\uD850\uDF64\uD863\uDC2B\uD85B\uDDA2\uD864\uDC8B\uD852\uDD75\uD852\uDDBB\uD852\uDDF8\uD850\uDF48\uD852\uDE51\uD862\uDFDA\uD846\uDCFA\uD862\uDD7E\uD863\uDE36\uD862\uDE44\uD862\uDD6C\uD851\uDCB9\uD851\uDC73\uD850\uDFF8\uD845\uDFEF\uD846\uDCBE\uD84D\uDD99\uD846\uDC85\uD855\uDC2F\uD845\uDFF8\uD845\uDEFB\uD846\uDC39\uD845\uDF74\uD846\uDCD1\uD857\uDF4B\uD845\uDEC0\uD852\uDE25\uD844\uDFFE\uD844\uDEA8"],["9240","\uD844\uDFC6\uD845\uDCB6\uD84D\uDEA6\uD852\uDD94\uD85C\uDD65\uD84F\uDE31\uD855\uDD5C\uD84F\uDEFB\uD85C\uDC52\uD84D\uDEEE\uD866\uDD9D\uD85B\uDF26\uD846\uDD22\uD84D\uDF3F\uD850\uDCE1\uD850\uDC8B\uD850\uDD0F\uD85B\uDC21\uD859\uDEB1\uD843\uDFDF\uD842\uDFA8\uD843\uDE0D\uD862\uDF13\uD851\uDC36\uD841\uDC65\uD840\uDF7F\uD855\uDE51\uD840\uDDAB\uD840\uDFCB\uD840\uDF0A\uD841\uDC14\uD840\uDEC0\uD863\uDEB3\uD840\uDE75\uD840\uDE0C"],["92a1","\uD852\uDE0E\uD84F\uDE8A\uD84D\uDD95\uD84F\uDE39\uD84F\uDEBF\uD846\uDC84\uD84F\uDE89\uD841\uDDE0\uD841\uDCA3\uD841\uDC92\uD841\uDC91\uD862\uDE9C\uD841\uDF0E\uD842\uDC73\uD850\uDF8C\uD843\uDC20\uD852\uDDAC\uD844\uDCE4\uD843\uDE1D\uD852\uDEBC\uD850\uDC8D\uD850\uDCC9\uD840\uDF45\uD842\uDFC6\uD862\uDE46\uD845\uDEFA\uD845\uDF6F\uD845\uDF10\uD856\uDD46\uD846\uDDF3\uD846\uDC61\uD850\uDE95\uD857\uDE83"],["9340","\uD862\uDFD7\uD841\uDC13\uD844\uDF03\uD862\uDDFB\uD846\uDD96\uD846\uDD7C\uD84E\uDEEE\uD846\uDD03\uD846\uDD04\uD846\uDCA0\uD845\uDEFE\uD862\uDE47\uD847\uDDBA\uD84D\uDC72\uD862\uDDA8\uD846\uDD27\uD845\uDFAB\uD845\uDF3B\uD85D\uDDFD\uD84A\uDC60\uD849\uDE2B\uD849\uDDAF\uD849\uDDBE\uD864\uDC88\uD85B\uDF73\uD840\uDC3E\uD840\uDC46\uD849\uDE1B\uD84B\uDC9B\uD84B\uDD07\uD851\uDED4\uD864\uDD4D"],["93a1","\uD851\uDE65\uD84A\uDF6A\uD84A\uDF22\uD84D\uDC50\uD866\uDCEA\uD84B\uDE78\uD869\uDC5B\uD852\uDDE3\uD84B\uDD67\uD84B\uDCA1\uD84C\uDC8E\uD84C\uDEAD\uD852\uDD89\uD84C\uDEAB\uD84C\uDEE0\uD846\uDCD9\uD865\uDC3F\uD84C\uDE89\uD84C\uDDB3\uD855\uDD84\uD862\uDF22\uD855\uDD8F\uD845\uDEFC\uD855\uDD5B\uD855\uDC25\uD84C\uDD03\uD846\uDC2A\uD84C\uDE34\uD84C\uDE0F\uD84C\uDD82\uD850\uDEC9\uD85B\uDD24\uD85E\uDC70\uD847\uDDEB\uD84C\uDED2\uD84C\uDEE1\uD856\uDC72\uD84E\uDC3A\uD84D\uDFBC\uD84D\uDFA2\uD84C\uDFFE\uD851\uDE2A\uD84D\uDFD5\uD851\uDC87\uD846\uDD12\uD84F\uDFC0\uD84F\uDC9A\uD862\uDFEA\uD862\uDECB"],["9440","\uD860\uDC1E\uD862\uDDDC\uD852\uDDEC\uD84F\uDF7F\uD850\uDC3C\uD850\uDF1A\uD850\uDE76\uD851\uDF8F\uD851\uDF25\uD852\uDEA4\uD841\uDDEB\uD84F\uDEF8\uD84D\uDE5F\uD852\uDE4A\uD852\uDD17\uD857\uDFE1\uD852\uDEDF\uD863\uDC23\uD84F\uDF35\uD85B\uDDEA\uD853\uDCD9\uD853\uDD06\uD869\uDDC6\uD862\uDECC\uD852\uDDAB\uD852\uDD8E"],["94a1","\uD852\uDE4E\uD852\uDDC5\uD852\uDCF3\uD862\uDEE3\uD846\uDC64\uD854\uDE21\uD854\uDDE7\uD84C\uDE32\uD851\uDE97\uD84D\uDF81\uD852\uDCF0\uD852\uDEBA\uD852\uDEC7\uD852\uDE96\uD858\uDDAE\uD855\uDD81\uD85D\uDF41\uD855\uDEE3\uD84F\uDEFA\uD845\uDEE6\uD843\uDD4C\uD852\uDD8C\uD840\uDE99\uD84F\uDDBA\uD845\uDF6E\uD840\uDDD4\uD843\uDC0D\uD849\uDEF5\uD856\uDEAF\uD856\uDE9C\uD840\uDE5B\uD856\uDFC6\uD856\uDFB3\uD857\uDEBC\uD857\uDEA6\uD852\uDDF9\uD845\uDFB0\uD858\uDE61"],["9540","\uD858\uDD5C\uD85E\uDF48\uD857\uDE82\uD85A\uDF75\uD842\uDD16\uD840\uDC4E\uD84D\uDDCF\uD859\uDC12\uD858\uDFF8\uD852\uDD62\uD842\uDC2C\uD856\uDEE9\uD857\uDD43\uD857\uDE0E\uD84D\uDC3F\uD852\uDDF7\uD859\uDDAD\uD859\uDDA0\uD85C\uDD27\uD85B\uDCD1\uD859\uDFB4\uD85A\uDE42\uD85A\uDE51\uD85B\uDDA7\uD85C\uDE1B\uD846\uDC40\uD846\uDCA1\uD846\uDCD8\uD87E\uDDBC\uD84F\uDD8F\uD85D\uDC22"],["95a1","\uD855\uDE83\uD85D\uDF85\uD85D\uDF84\uD862\uDFF5\uD862\uDFD9\uD862\uDF9C\uD862\uDDF9\uD865\uDC48\uD850\uDE84\uD846\uDC45\uD85F\uDDDC\uD853\uDC09\uD848\uDF21\uD845\uDFDA\uD852\uDD2F\uD862\uDE4B\uD862\uDEFC\uD863\uDC1D\uD863\uDC3B\uD863\uDD34\uD852\uDCFF\uD852\uDE42\uD850\uDFEA\uD84C\uDE25\uD863\uDEE7\uD863\uDE66\uD863\uDE65\uD852\uDDED\uD852\uDE78\uD84F\uDFEE\uD864\uDCB0"],["9640","\uD864\uDC93\uD855\uDFDF\uD862\uDD89\uD863\uDC26\uD862\uDF2F\uD858\uDFBE\uD850\uDE1B\uD843\uDF26\uD862\uDFC5\uD852\uDEB2\uD865\uDCDA\uD865\uDDD7\uD862\uDF50\uD852\uDE67\uD862\uDF64\uD862\uDE45\uD85E\uDF06\uD862\uDF65\uD856\uDCC8\uD866\uDCF1\uD866\uDD48\uD844\uDF02\uD852\uDDB8"],["96a1","\uD845\uDCE8\uD849\uDF1F\uD84F\uDDB8\uD849\uDF81\uD84A\uDD6B\uD867\uDE2D\uD868\uDDF5\uD868\uDCFE\uD850\uDD04\uD868\uDDB4\uD868\uDCED\uD868\uDCF3\uD866\uDD2F\uD85B\uDE12\uD85B\uDFDF\uD85A\uDF82\uD85B\uDDA4\uD85B\uDE84\uD85B\uDDF0\uD85B\uDE00\uD84D\uDFD7\uD858\uDC64\uD84D\uDD9C\uD84D\uDE40\uD852\uDDDE\uD840\uDEBF\uD855\uDD5D\uD845\uDF57\uD84C\uDDC9\uD852\uDD41\uD850\uDDB5\uD850\uDDAC\uD85B\uDC40\uD853\uDF97\uD845\uDFB5\uD862\uDE49"],["9740","\uD851\uDC88\uD862\uDDFC\uD846\uDCD6\uD843\uDF1D\uD85B\uDCC0\uD845\uDC13\uD850\uDEFA\uD84B\uDC26\uD850\uDFC1\uD84F\uDDB7\uD859\uDF41\uD858\uDD5B\uD858\uDCA4\uD852\uDDB9\uD852\uDD8B\uD862\uDDFA\uD862\uDF63\uD846\uDC9F\uD852\uDEB3\uD852\uDE3E\uD852\uDE94\uD845\uDFD9\uD852\uDE66\uD840\uDFA7\uD845\uDC24\uD852\uDDE5\uD852\uDD16\uD852\uDD76\uD841\uDCFE\uD862\uDECE\uD862\uDE16\uD862\uDFE7\uD855\uDDD5\uD862\uDE82"],["97a1","\uD852\uDD43\uD843\uDCFF\uD841\uDE1A\uD842\uDFEB\uD843\uDCB8\uD845\uDFFA\uD845\uDEC2\uD852\uDE50\uD846\uDC52\uD862\uDEC0\uD852\uDDAD\uD846\uDCBF\uD846\uDC83\uD85D\uDC84\uD84F\uDD5B\uD862\uDE81\uD846\uDC62\uD842\uDEB4\uD844\uDF9C\uD860\uDE18\uD864\uDCE4\uD85F\uDE4F\uD84F\uDFED\uD84F\uDE2D\uD840\uDFF5\uD863\uDC1C\uD85A\uDFC0\uD845\uDC52\uD850\uDF62\uD852\uDE71\uD84B\uDFE3\uD844\uDEB0\uD848\uDFBD\uD844\uDF98\uD84D\uDCE5\uD85E\uDFF4\uD84D\uDEDF\uD862\uDE83\uD84D\uDFD6\uD84C\uDFFA\uD853\uDC9F\uD84D\uDEAD\uD85B\uDCB7"],["9840","\uD85B\uDD26\uD85B\uDD51\uD85B\uDC82\uD85B\uDFDE\uD85C\uDD09\uD845\uDF3A\uD85B\uDC80\uD85C\uDC53\uD845\uDFDB\uD845\uDFB3\uD846\uDD05\uD850\uDDFC\uD845\uDF3C\uD850\uDEA5\uD850\uDE93\uD84F\uDEF9\uD85D\uDF36\uD851\uDC5B\uD850\uDECA\uD850\uDE59\uD862\uDDE1\uD85B\uDD28\uD851\uDCCE\uD85F\uDE4D\uD850\uDFBD\uD850\uDE56\uD844\uDF04\uD850\uDFE9\uD87E\uDC25\uD852\uDE4F\uD852\uDE5D\uD845\uDFDF"],["98a1","\uD84E\uDEFA\uD84C\uDF00\uD840\uDE14\uD842\uDCD5\uD841\uDE19\uD847\uDF9E\uD868\uDEB6\uD864\uDD5B\uD862\uDE59\uD865\uDC20\uD85E\uDEF4\uD855\uDEF6\uD85E\uDF18\uD852\uDCF2\uD853\uDF5C\uD855\uDD35"],["9940","\uD843\uDCCF"],["99a1","\uD85E\uDD67"],["9a40","\uD846\uDFC2"],["9aa1","\uD840\uDC94\uD840\uDEB7\uD840\uDFA0\uD841\uDCD7\uD841\uDDD5\uD841\uDE15\uD841\uDE76\uD845\uDEBA\uD842\uDEC2\uD842\uDECD\uD842\uDFBF\uD87E\uDC3B\uD842\uDFCB\uD842\uDFFB\uD843\uDC3B\uD843\uDC53\uD843\uDC65\uD843\uDC7C\uD843\uDC8D\uD843\uDCB5\uD843\uDCDD\uD843\uDCED\uD843\uDD6F\uD843\uDDB2\uD843\uDDC8\uD843\uDE04\uD843\uDE0E\uD843\uDED7\uD843\uDF90\uD843\uDF2D\uD843\uDE73\uD843\uDFBC\uD844\uDC5C\uD844\uDC4F\uD844\uDC76\uD844\uDC7B\uD844\uDC88\uD844\uDC96\uD844\uDCBF\uD844\uDCD3\uD844\uDD2F\uD844\uDD3B\uD844\uDEE3\uD844\uDF75\uD844\uDF36\uD845\uDD77\uD845\uDE19\uD845\uDFC3\uD845\uDFC7\uD846\uDC2D\uD846\uDD6A"],["9b40","\uD846\uDE2D\uD846\uDE45\uD847\uDC2A\uD847\uDC70\uD847\uDCAC\uD847\uDEC8\uD847\uDED5\uD847\uDF15\uD848\uDC45\uD848\uDE7C\uD848\uDFD7\uD848\uDFFA\uD849\uDF2A\uD84A\uDC71\uD84A\uDD4F\uD84A\uDD67\uD84A\uDD93\uD84A\uDED5\uD84A\uDEE8\uD84A\uDF0E\uD84A\uDF3F\uD84B\uDC4C"],["9b62","\uD84B\uDC88\uD84B\uDCB7\uD856\uDFE8\uD84B\uDD08\uD84B\uDD12\uD84B\uDDB7\uD84B\uDD95\uD84B\uDE42\uD84B\uDF74\uD84B\uDFCC\uD84C\uDC33\uD84C\uDC66\uD84C\uDF1F\uD84C\uDFDE\uD85E\uDE79\uD84D\uDD67\uD84D\uDDF3\uD852\uDDBA\uD84D\uDE1A\uD84D\uDF16\uD840\uDF46"],["9ba1","\uD84E\uDEA7\uD85D\uDE57\uD857\uDFE2\uD84F\uDE11\uD84F\uDEB9\uD85D\uDDFE\uD848\uDC9A\uD850\uDD19\uD862\uDE9A\uD850\uDEEE\uD850\uDF0D\uD850\uDC3B\uD850\uDF34\uD850\uDF96\uD852\uDE45\uD841\uDDCA\uD841\uDE11\uD847\uDEA8\uD84F\uDCFF\uD851\uDC04\uD851\uDCD6\uD851\uDE74\uD851\uDF2F\uD861\uDDE8\uD866\uDDC9\uD848\uDDC3\uD862\uDF4E\uD852\uDC12\uD852\uDCFB\uD852\uDE15\uD852\uDEC0\uD843\uDC78\uD853\uDEA5\uD853\uDF86\uD841\uDF79\uD854\uDC2C\uD854\uDE99\uD855\uDC19\uD84F\uDF4A\uD852\uDEA7\uD855\uDC46\uD855\uDC6E\uD85A\uDF52\uD855\uDD3F\uD85D\uDE32\uD855\uDD5E\uD855\uDD62\uD855\uDD66\uD855\uDFC7\uD852\uDD3F\uD856\uDC5D\uD84C\uDFCC\uD856\uDD03\uD862\uDD48\uD856\uDEAE\uD856\uDF89\uD857\uDC06\uD847\uDD90\uD858\uDD02\uD85F\uDC12\uD858\uDDB2\uD853\uDF9A\uD859\uDC02\uD859\uDC4A"],["9c40","\uD85A\uDFF7\uD859\uDC84\uD846\uDD1C\uD852\uDDF6\uD859\uDC88\uD84F\uDFEF\uD859\uDD12\uD859\uDDBF\uD859\uDEB5\uD849\uDF1B\uD855\uDFE1\uD87E\uDCCD\uD851\uDD21\uD859\uDEFC\uD852\uDD34\uD85B\uDCBD\uD859\uDF99\uD85A\uDC6E\uD859\uDC11\uD85A\uDC5E\uD85A\uDCC7\uD864\uDCC0\uD842\uDE11\uD85A\uDD26\uD85A\uDD39\uD85A\uDDFA\uD85A\uDE2D\uD859\uDC69\uD840\uDC21\uD85A\uDE34\uD85A\uDF5B\uD84D\uDD19\uD85A\uDF9D\uD85B\uDCA4\uD85B\uDDAE"],["9ca1","\uD849\uDD8D\uD85C\uDC4B\uD85C\uDDCD\uD85C\uDE80\uD85C\uDE85\uD848\uDD7A\uD85C\uDE8B\uD85C\uDEE6\uD852\uDDD0\uD85D\uDC50\uD843\uDEF8\uD84A\uDD26\uD861\uDC73\uD845\uDFB1\uD852\uDE2A\uD846\uDC20\uD867\uDCAD\uD866\uDCA4\uD85D\uDFCC\uD85E\uDC58\uD845\uDE0A\uD84D\uDF2F\uD860\uDCE8\uD844\uDFC5\uD85E\uDDDD\uD864\uDDA8\uD85C\uDCAF\uD862\uDDAB\uD85E\uDDFD\uD85E\uDE0A\uD85E\uDF0B\uD85F\uDD66\uD850\uDD7A\uD860\uDC09\uD868\uDEDF\uD860\uDF18\uD85B\uDE07\uD860\uDD6F\uD860\uDC23\uD85A\uDDB5\uD844\uDFED\uD84C\uDE2F\uD860\uDC48\uD863\uDC30\uD860\uDC83\uD862\uDD49\uD852\uDD88\uD852\uDEA5\uD84F\uDF81\uD860\uDC90\uD860\uDCF4\uD860\uDD2E\uD847\uDFA1\uD860\uDD4F"],["9d40","\uD860\uDD89\uD860\uDDAF\uD860\uDE1A\uD860\uDF06\uD860\uDF2F\uD860\uDF8A\uD861\uDC68\uD861\uDEAA\uD862\uDD56\uD862\uDDB8\uD862\uDDE7\uD862\uDDE8\uD862\uDF46\uD862\uDFD4\uD863\uDC09\uD863\uDFC5\uD864\uDCEC\uD864\uDD10\uD864\uDD3C\uD864\uDD5E\uD852\uDECA\uD865\uDCE7\uD865\uDDE9\uD865\uDDB0\uD865\uDDB8\uD865\uDF32\uD866\uDCD1\uD866\uDD49\uD866\uDD6A\uD866\uDDC3\uD866\uDE28\uD866\uDF0E\uD867\uDD5A\uD867\uDD9B\uD867\uDEF8\uD867\uDF23\uD868\uDE93\uD868\uDEFF\uD869\uDDCB\uD843\uDC9C"],["9da1","\uD849\uDCB0\uD852\uDE93\uD862\uDF2C\uD85E\uDC9D\uD845\uDFF5\uD860\uDC24\uD862\uDF6C\uD862\uDF99\uD85E\uDE3E\uD859\uDEAF\uD85D\uDE55\uD84F\uDCB7\uD855\uDE35\uD856\uDD56\uD857\uDE81\uD858\uDE58\uD843\uDE6D\uD84F\uDE88\uD853\uDC9E\uD845\uDFF6\uD846\uDC7B\uD857\uDC4A\uD854\uDF11\uD867\uDD98\uD857\uDED8\uD84F\uDD40\uD843\uDFEA\uD843\uDD49\uD84D\uDEBA\uD843\uDE9D\uD860\uDEE2\uD843\uDC41\uD843\uDC96\uD854\uDD48\uD843\uDE76\uD84B\uDC62"],["9e40","\uD843\uDEA2\uD844\uDC75\uD84A\uDF43\uD84B\uDEB3\uD843\uDDA7\uD85A\uDC8A\uD844\uDCC1\uD851\uDF06\uD85A\uDC93\uD849\uDEF4\uD85F\uDD2F\uD850\uDDA3\uD85F\uDD73\uD85B\uDED0\uD85C\uDEB6\uD844\uDDD9\uD84F\uDCFC\uD869\uDEA9\uD843\uDEAC\uD843\uDEF9\uD847\uDCA2\uD853\uDFC2\uD85F\uDFF9\uD843\uDFEB"],["9ea1","\uD84B\uDDA0\uD851\uDFE0\uD867\uDD7C\uD843\uDFEC\uD843\uDE0A\uD85D\uDDA3\uD843\uDFED"],["9ead","\uD858\uDC48\uD844\uDD87\uD851\uDE18\uD852\uDF6E\uD856\uDE95\uD842\uDD79"],["9ec5","\uD849\uDC65\uD867\uDEAC\uD84F\uDCFE\uD867\uDF30\uD853\uDFA9\uD865\uDD9E\uD867\uDFDE\uD84F\uDDB6\uD85C\uDEB2\uD859\uDFB3\uD84D\uDF20\uD84F\uDEF7\uD84F\uDE2C\uD841\uDC8E\uD843\uDEB6\uD85F\uDF2E\uD869\uDC34\uD84C\uDCDA\uD850\uDFF2"],["9ef5","\uD844\uDEA9\uD852\uDD63\uD867\uDE06\uD85C\uDCAE"],["9f40","\uD845\uDF6C\uD865\uDCD0\uD858\uDF35\uD85C\uDD64\uD843\uDD28\uD85B\uDD22\uD852\uDEE2\uD843\uDD71"],["9f4f","\uD847\uDF0F\uD847\uDDD1\uD852\uDD3E"],["9fa1","\uD845\uDF6D"],["9fae",""],["9fb2","\uD863\uDE97\uD85B\uDD23\uD840\uDFFC\uD857\uDC21\uD84F\uDCFD"],["9fc1","\uD852\uDD19\uD843\uDCD4"],["9fc9","\uD840\uDDF2"],["9fdb",""],["9fe7",""],["9feb","\uD869\uDE4A"],["9ff0","\uD860\uDF7D\uD852\uDE77"],["a040","\uD862\uDE5A\uD868\uDEB2\uD87E\uDC40\uD852\uDEBB"],["a055","\uD846\uDC3B\uD85B\uDE05"],["a058","\uD849\uDD1B"],["a05b",""],["a063","\uD858\uDD59"],["a073","\uD84C\uDFF5"],["a0a1","\uD862\uDFC2\uD863\uDE39"],["a0a6","\uD847\uDD46\uD843\uDF3B"],["a0ae",""],["a0b0","\uD857\uDF1A\uD85D\uDC86\uD859\uDFCC\uD85B\uDED1"],["a0d4","\uD850\uDC11"],["a0e2","\uD862\uDF2D\uD84F\uDCC7\uD857\uDED7\uD85D\uDE56\uD855\uDD31\uD846\uDD44\uD844\uDEFE\uD866\uDD03\uD85B\uDDDC\uD85C\uDCAD\uD858\uDDAD\uD862\uDE0F\uD84D\uDE77\uD840\uDCEE\uD85A\uDC46\uD853\uDF0E\uD858\uDF4C\uD858\uDE6B"],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"\xa8",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,"\uD840\uDCCC\uD840\uDC8A"],["c8a1","\uD85D\uDE07"],["c8cd",""],["c8f5","\xf8"],["f9fe",""],["fa40","\uD841\uDD47\uD841\uDDDF\uD84F\uDFC5\uD852\uDD42\uD862\uDDE4\uD846\uDDDB\uD84F\uDCC8\uD852\uDD33\uD862\uDDAA\uD840\uDEA0\uD85A\uDFB3\uD844\uDF05\uD849\uDCED\uD85B\uDD29\uD85E\uDE84\uD84D\uDE00\uD852\uDEB1\uD849\uDD13\uD840\uDF7E\uD840\uDF80\uD840\uDF47\uD841\uDC1F\uD852\uDDA4\uD841\uDC87\uD84C\uDFB4\uD842\uDFFF\uD848\uDCFC\uD840\uDEE5\uD849\uDD30\uD841\uDD8E\uD84C\uDE33\uD846\uDD83\uD841\uDDB3\uD84F\uDC99"],["faa1","\uD852\uDEA6\uD84D\uDF2D\uD85A\uDF13\uD862\uDEDE\uD84F\uDF80\uD842\uDD54\uD84F\uDFEC\uD842\uDFE2\uD845\uDF26\uD845\uDEE8\uD861\uDEAB\uD845\uDD96\uD845\uDE13\uD862\uDE9B\uD855\uDF72\uD842\uDF8F\uD84F\uDFEB\uD84B\uDDA3\uD843\uDC77\uD85A\uDF53\uD843\uDD74\uD845\uDF0D\uD843\uDEDD\uD843\uDD4D"],["fb40","\uD862\uDDBC\uD849\uDE98\uD846\uDCD7\uD850\uDC3A\uD851\uDC35\uD844\uDCB4\uD84C\uDE8A\uD862\uDF66\uD844\uDE4F\uD850\uDDA5\uD85B\uDC7E\uD845\uDC16\uD845\uDC54\uD850\uDF63\uD852\uDFF5\uD844\uDE3C\uD868\uDD50\uD850\uDE78"],["fba1","\uD845\uDE3E\uD845\uDE92\uD843\uDD4E\uD85B\uDC81\uD85B\uDD2A\uD845\uDFDC\uD845\uDFFB\uD845\uDFB2\uD85B\uDDA6\uD846\uDC28\uD845\uDED5\uD85B\uDE45\uD852\uDDA9\uD85B\uDFA1\uD849\uDD54\uD846\uDD11\uD845\uDEB8\uD85E\uDE0E\uD840\uDE04\uD846\uDE34\uD856\uDDCC\uD841\uDDA5\uD846\uDF44\uD847\uDCA5\uD85A\uDF28\uD847\uDDF9\uD847\uDE37\uD847\uDEA4\uD852\uDD01\uD848\uDC49\uD848\uDD73\uD851\uDCBC\uD843\uDCD3\uD845\uDF71\uD861\uDC82"],["fc40","\uD840\uDDC1\uD87E\uDC94\uD844\uDF3A\uD85A\uDC88\uD848\uDFD0\uD849\uDC71\uD85B\uDE6E\uD862\uDE36\uD854\uDE50\uD847\uDF6A\uD85C\uDCF8\uD849\uDE68\uD840\uDE9E\uD862\uDE29\uD846\uDC77\uD849\uDFB4\uD852\uDD82\uD852\uDD8F\uD85E\uDE53\uD87E\uDCA6\uD85B\uDED2\uD841\uDE56\uD84F\uDFB7"],["fca1","\uD84A\uDC5F\uD862\uDF9D\uD866\uDD5D\uD84A\uDD80\uD84A\uDCC1\uD840\uDD18\uD845\uDF70\uD84B\uDE0D\uD852\uDDDF\uD844\uDF8E\uD845\uDFFC\uD84B\uDE36\uD850\uDC8C\uD855\uDF1D\uD852\uDE28\uD852\uDE23\uD84C\uDC7E\uD852\uDD40\uD846\uDC29\uD84D\uDC00\uD84C\uDDF7\uD84C\uDDF8\uD84C\uDDA4\uD84C\uDDA5\uD843\uDE75\uD854\uDDE6\uD847\uDE3D\uD84C\uDE31\uD861\uDDF4\uD84C\uDDC8\uD854\uDF13\uD84A\uDCF7\uD850\uDF9C\uD852\uDE21\uD84D\uDFC2\uD850\uDDCD\uD864\uDCED\uD84C\uDFE6\uD85B\uDDA0"],["fd40","\uD84D\uDC6F\uD862\uDEDF\uD84D\uDDCD\uD84D\uDE3C\uD862\uDE4A\uD840\uDFC9\uD84D\uDE59\uD848\uDD2A\uD84D\uDF03\uD864\uDD9C\uD842\uDD23\uD849\uDFCD\uD84E\uDEDB\uD840\uDFB5\uD846\uDD58\uD84E\uDF5A\uD84F\uDEFC\uD849\uDC8B\uD852\uDCF1\uD85A\uDF51\uD84F\uDDBC\uD84F\uDDBD\uD850\uDDA4\uD852\uDD0C\uD852\uDD00"],["fda1","\uD84F\uDCC9\uD843\uDD32\uD84C\uDDF9\uD849\uDC91\uD85B\uDD25\uD85B\uDDA1\uD85B\uDDEB\uD852\uDD7F\uD850\uDC85\uD85B\uDE72\uD85B\uDF74\uD862\uDF21\uD84F\uDE2F\uD84F\uDF82\uD84C\uDC4B\uD84F\uDE30\uD845\uDC97\uD850\uDC3D\uD864\uDD70\uD850\uDD44\uD850\uDC91\uD850\uDD55\uD850\uDC39\uD84F\uDFF0\uD84F\uDFB4\uD850\uDD3F\uD850\uDD56\uD850\uDD57\uD850\uDD40\uD858\uDDDD\uD850\uDE77\uD850\uDF65\uD850\uDEC1\uD851\uDC5A\uD852\uDE27\uD852\uDE22\uD862\uDFE8"],["fe40","\uD855\uDE05\uD852\uDD74\uD84C\uDC44\uD852\uDC23\uD862\uDC2B\uD862\uDC04\uD843\uDC3A\uD85A\uDE2E\uD850\uDDE2\uD845\uDEE7\uD852\uDE24\uD852\uDDB7\uD852\uDD8D\uD852\uDDFB\uD852\uDE26\uD841\uDDC3\uD84A\uDCAD\uD863\uDEB2\uD852\uDE8C"],["fea1","\uD850\uDD5F\uD852\uDE79\uD862\uDF8F\uD863\uDC03\uD846\uDC9E\uD846\uDD88\uD863\uDED9\uD846\uDE4B\uD863\uDEAC\uD853\uDF82\uD853\uDD13\uD858\uDFF5\uD85A\uDD11\uD85A\uDD0E\uD85B\uDF9F\uD854\uDC9D\uD854\uDD7D\uD847\uDE1C\uD854\uDE20\uD84C\uDEAC\uD862\uDD64\uD862\uDD68\uD845\uDEC1\uD844\uDF76\uD852\uDE12\uD855\uDDE0\uD85D\uDE0C\uD862\uDF2B\uD858\uDC83\uD849\uDE1C\uD856\uDC57\uD85E\uDF39\uD85C\uDD26\uD864\uDD0D"]]');

});



parcelRequire.register("euIxF", function(module, exports) {
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $a8d66b204e92bca1$require$Buffer = $xaL3N.Buffer;
// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
// we opt to dependency-inject it instead of creating a hard dependency.
module.exports = function(stream_module) {
    var Transform = stream_module.Transform;
    // == Encoder stream =======================================================
    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: {
            value: IconvLiteEncoderStream
        }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string") return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        } catch (e) {
            done(e);
        }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        } catch (e) {
            done(e);
        }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
            chunks.push(chunk);
        });
        this.on("end", function() {
            cb(null, $a8d66b204e92bca1$require$Buffer.concat(chunks));
        });
        return this;
    };
    // == Decoder stream =======================================================
    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8"; // We output strings.
        Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: {
            value: IconvLiteDecoderStream
        }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!$a8d66b204e92bca1$require$Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        } catch (e) {
            done(e);
        }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);
            done();
        } catch (e) {
            done(e);
        }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
            res += chunk;
        });
        this.on("end", function() {
            cb(null, res);
        });
        return this;
    };
    return {
        IconvLiteEncoderStream: IconvLiteEncoderStream,
        IconvLiteDecoderStream: IconvLiteDecoderStream
    };
};

});

parcelRequire.register("lb6jJ", function(module, exports) {
"use strict";

});

parcelRequire.register("1xCGA", function(module, exports) {
"use strict";

var $fxI7A = parcelRequire("fxI7A");

var $381AU = parcelRequire("381AU");

var $lqji5 = parcelRequire("lqji5");

var $emsfP = parcelRequire("emsfP");
const $11f6e1bf559d811f$var$isObject = (val)=>val && typeof val === "object" && !Array.isArray(val);
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */ const $11f6e1bf559d811f$var$picomatch = (glob, options, returnState = false)=>{
    if (Array.isArray(glob)) {
        const fns = glob.map((input)=>$11f6e1bf559d811f$var$picomatch(input, options, returnState));
        const arrayMatcher = (str)=>{
            for (const isMatch of fns){
                const state = isMatch(str);
                if (state) return state;
            }
            return false;
        };
        return arrayMatcher;
    }
    const isState = $11f6e1bf559d811f$var$isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) throw new TypeError("Expected pattern to be a non-empty string");
    const opts = options || {};
    const posix = opts.windows;
    const regex = isState ? $11f6e1bf559d811f$var$picomatch.compileRe(glob, options) : $11f6e1bf559d811f$var$picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = ()=>false;
    if (opts.ignore) {
        const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null
        };
        isIgnored = $11f6e1bf559d811f$var$picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false)=>{
        const { isMatch: isMatch, match: match, output: output } = $11f6e1bf559d811f$var$picomatch.test(input, regex, options, {
            glob: glob,
            posix: posix
        });
        const result = {
            glob: glob,
            state: state,
            regex: regex,
            posix: posix,
            input: input,
            output: output,
            match: match,
            isMatch: isMatch
        };
        if (typeof opts.onResult === "function") opts.onResult(result);
        if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") opts.onIgnore(result);
            result.isMatch = false;
            return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") opts.onMatch(result);
        return returnObject ? result : true;
    };
    if (returnState) matcher.state = state;
    return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.test = (input, regex, options, { glob: glob, posix: posix } = {})=>{
    if (typeof input !== "string") throw new TypeError("Expected input to be a string");
    if (input === "") return {
        isMatch: false,
        output: ""
    };
    const opts = options || {};
    const format = opts.format || (posix ? $lqji5.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
    }
    if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) match = $11f6e1bf559d811f$var$picomatch.matchBase(input, regex, options, posix);
        else match = regex.exec(output);
    }
    return {
        isMatch: Boolean(match),
        match: match,
        output: output
    };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.matchBase = (input, glob, options)=>{
    const regex = glob instanceof RegExp ? glob : $11f6e1bf559d811f$var$picomatch.makeRe(glob, options);
    return regex.test($lqji5.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.isMatch = (str, patterns, options)=>$11f6e1bf559d811f$var$picomatch(patterns, options)(str);
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.parse = (pattern, options)=>{
    if (Array.isArray(pattern)) return pattern.map((p)=>$11f6e1bf559d811f$var$picomatch.parse(p, options));
    return $381AU(pattern, {
        ...options,
        fastpaths: false
    });
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.scan = (input, options)=>$fxI7A(input, options);
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.compileRe = (state, options, returnOutput = false, returnState = false)=>{
    if (returnOutput === true) return state.output;
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) source = `^(?!${source}).*$`;
    const regex = $11f6e1bf559d811f$var$picomatch.toRegex(source, options);
    if (returnState === true) regex.state = state;
    return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false)=>{
    if (!input || typeof input !== "string") throw new TypeError("Expected a non-empty string");
    let parsed = {
        negated: false,
        fastpaths: true
    };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) parsed.output = $381AU.fastpaths(input, options);
    if (!parsed.output) parsed = $381AU(input, options);
    return $11f6e1bf559d811f$var$picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */ $11f6e1bf559d811f$var$picomatch.toRegex = (source, options)=>{
    try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
    }
};
/**
 * Picomatch constants.
 * @return {Object}
 */ $11f6e1bf559d811f$var$picomatch.constants = $emsfP;
/**
 * Expose "picomatch"
 */ module.exports = $11f6e1bf559d811f$var$picomatch;

});
parcelRequire.register("fxI7A", function(module, exports) {
"use strict";

var $lqji5 = parcelRequire("lqji5");

var $emsfP = parcelRequire("emsfP");
var $b50c29a82fde2666$require$CHAR_ASTERISK = $emsfP.CHAR_ASTERISK;
var $b50c29a82fde2666$require$CHAR_AT = $emsfP.CHAR_AT;
var $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH = $emsfP.CHAR_BACKWARD_SLASH;
var $b50c29a82fde2666$require$CHAR_COMMA = $emsfP.CHAR_COMMA;
var $b50c29a82fde2666$require$CHAR_DOT = $emsfP.CHAR_DOT;
var $b50c29a82fde2666$require$CHAR_EXCLAMATION_MARK = $emsfP.CHAR_EXCLAMATION_MARK;
var $b50c29a82fde2666$require$CHAR_FORWARD_SLASH = $emsfP.CHAR_FORWARD_SLASH;
var $b50c29a82fde2666$require$CHAR_LEFT_CURLY_BRACE = $emsfP.CHAR_LEFT_CURLY_BRACE;
var $b50c29a82fde2666$require$CHAR_LEFT_PARENTHESES = $emsfP.CHAR_LEFT_PARENTHESES;
var $b50c29a82fde2666$require$CHAR_LEFT_SQUARE_BRACKET = $emsfP.CHAR_LEFT_SQUARE_BRACKET;
var $b50c29a82fde2666$require$CHAR_PLUS = $emsfP.CHAR_PLUS;
var $b50c29a82fde2666$require$CHAR_QUESTION_MARK = $emsfP.CHAR_QUESTION_MARK;
var $b50c29a82fde2666$require$CHAR_RIGHT_CURLY_BRACE = $emsfP.CHAR_RIGHT_CURLY_BRACE;
var $b50c29a82fde2666$require$CHAR_RIGHT_PARENTHESES = $emsfP.CHAR_RIGHT_PARENTHESES;
var $b50c29a82fde2666$require$CHAR_RIGHT_SQUARE_BRACKET = $emsfP.CHAR_RIGHT_SQUARE_BRACKET;
const $b50c29a82fde2666$var$isPathSeparator = (code)=>{
    return code === $b50c29a82fde2666$require$CHAR_FORWARD_SLASH || code === $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH;
};
const $b50c29a82fde2666$var$depth = (token)=>{
    if (token.isPrefix !== true) token.depth = token.isGlobstar ? Infinity : 1;
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */ const $b50c29a82fde2666$var$scan = (input, options)=>{
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = {
        value: "",
        depth: 0,
        isGlob: false
    };
    const eos = ()=>index >= length;
    const peek = ()=>str.charCodeAt(index + 1);
    const advance = ()=>{
        prev = code;
        return str.charCodeAt(++index);
    };
    while(index < length){
        code = advance();
        let next;
        if (code === $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === $b50c29a82fde2666$require$CHAR_LEFT_CURLY_BRACE) braceEscaped = true;
            continue;
        }
        if (braceEscaped === true || code === $b50c29a82fde2666$require$CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while(eos() !== true && (code = advance())){
                if (code === $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === $b50c29a82fde2666$require$CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === $b50c29a82fde2666$require$CHAR_DOT && (code = advance()) === $b50c29a82fde2666$require$CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (braceEscaped !== true && code === $b50c29a82fde2666$require$CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) continue;
                    break;
                }
                if (code === $b50c29a82fde2666$require$CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $b50c29a82fde2666$require$CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = {
                value: "",
                depth: 0,
                isGlob: false
            };
            if (finished === true) continue;
            if (prev === $b50c29a82fde2666$require$CHAR_DOT && index === start + 1) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            const isExtglobChar = code === $b50c29a82fde2666$require$CHAR_PLUS || code === $b50c29a82fde2666$require$CHAR_AT || code === $b50c29a82fde2666$require$CHAR_ASTERISK || code === $b50c29a82fde2666$require$CHAR_QUESTION_MARK || code === $b50c29a82fde2666$require$CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === $b50c29a82fde2666$require$CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === $b50c29a82fde2666$require$CHAR_EXCLAMATION_MARK && index === start) negatedExtglob = true;
                if (scanToEnd === true) {
                    while(eos() !== true && (code = advance())){
                        if (code === $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === $b50c29a82fde2666$require$CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === $b50c29a82fde2666$require$CHAR_ASTERISK) {
            if (prev === $b50c29a82fde2666$require$CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $b50c29a82fde2666$require$CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
        if (code === $b50c29a82fde2666$require$CHAR_LEFT_SQUARE_BRACKET) {
            while(eos() !== true && (next = advance())){
                if (next === $b50c29a82fde2666$require$CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === $b50c29a82fde2666$require$CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) continue;
            break;
        }
        if (opts.nonegate !== true && code === $b50c29a82fde2666$require$CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === $b50c29a82fde2666$require$CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while(eos() !== true && (code = advance())){
                    if (code === $b50c29a82fde2666$require$CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === $b50c29a82fde2666$require$CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) continue;
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    } else if (isGlob === true) {
        base = "";
        glob = str;
    } else base = str;
    if (base && base !== "" && base !== "/" && base !== str) {
        if ($b50c29a82fde2666$var$isPathSeparator(base.charCodeAt(base.length - 1))) base = base.slice(0, -1);
    }
    if (opts.unescape === true) {
        if (glob) glob = $lqji5.removeBackslashes(glob);
        if (base && backslashes === true) base = $lqji5.removeBackslashes(base);
    }
    const state = {
        prefix: prefix,
        input: input,
        start: start,
        base: base,
        glob: glob,
        isBrace: isBrace,
        isBracket: isBracket,
        isGlob: isGlob,
        isExtglob: isExtglob,
        isGlobstar: isGlobstar,
        negated: negated,
        negatedExtglob: negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!$b50c29a82fde2666$var$isPathSeparator(code)) tokens.push(token);
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for(let idx = 0; idx < slashes.length; idx++){
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                } else tokens[idx].value = value;
                $b50c29a82fde2666$var$depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") parts.push(value);
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value;
                $b50c29a82fde2666$var$depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = $b50c29a82fde2666$var$scan;

});
parcelRequire.register("lqji5", function(module, exports) {

$parcel$export(module.exports, "hasRegexChars", () => $f98afd6d618589fd$export$6540a013a39bb50d, (v) => $f98afd6d618589fd$export$6540a013a39bb50d = v);
$parcel$export(module.exports, "escapeRegex", () => $f98afd6d618589fd$export$104ed90cc1a13451, (v) => $f98afd6d618589fd$export$104ed90cc1a13451 = v);
$parcel$export(module.exports, "toPosixSlashes", () => $f98afd6d618589fd$export$e610e037975797ee, (v) => $f98afd6d618589fd$export$e610e037975797ee = v);
$parcel$export(module.exports, "removeBackslashes", () => $f98afd6d618589fd$export$f403de0a7ba7a743, (v) => $f98afd6d618589fd$export$f403de0a7ba7a743 = v);
$parcel$export(module.exports, "escapeLast", () => $f98afd6d618589fd$export$13d0f4185f159c8, (v) => $f98afd6d618589fd$export$13d0f4185f159c8 = v);
$parcel$export(module.exports, "removePrefix", () => $f98afd6d618589fd$export$f2888183a34644d4, (v) => $f98afd6d618589fd$export$f2888183a34644d4 = v);
$parcel$export(module.exports, "wrapOutput", () => $f98afd6d618589fd$export$25bddda26836484b, (v) => $f98afd6d618589fd$export$25bddda26836484b = v);
$parcel$export(module.exports, "basename", () => $f98afd6d618589fd$export$9bf319d8f74f51d1, (v) => $f98afd6d618589fd$export$9bf319d8f74f51d1 = v);
var $f98afd6d618589fd$export$a6cdc56e425d0d0a;
var $f98afd6d618589fd$export$6540a013a39bb50d;
var $f98afd6d618589fd$export$a92319f7ab133839;
var $f98afd6d618589fd$export$104ed90cc1a13451;
var $f98afd6d618589fd$export$e610e037975797ee;
var $f98afd6d618589fd$export$f403de0a7ba7a743;
var $f98afd6d618589fd$export$13d0f4185f159c8;
var $f98afd6d618589fd$export$f2888183a34644d4;
var $f98afd6d618589fd$export$25bddda26836484b;
var $f98afd6d618589fd$export$9bf319d8f74f51d1;
"use strict";

var $emsfP = parcelRequire("emsfP");
var $f98afd6d618589fd$require$REGEX_BACKSLASH = $emsfP.REGEX_BACKSLASH;
var $f98afd6d618589fd$require$REGEX_REMOVE_BACKSLASH = $emsfP.REGEX_REMOVE_BACKSLASH;
var $f98afd6d618589fd$require$REGEX_SPECIAL_CHARS = $emsfP.REGEX_SPECIAL_CHARS;
var $f98afd6d618589fd$require$REGEX_SPECIAL_CHARS_GLOBAL = $emsfP.REGEX_SPECIAL_CHARS_GLOBAL;
$f98afd6d618589fd$export$a6cdc56e425d0d0a = (val)=>val !== null && typeof val === "object" && !Array.isArray(val);
$f98afd6d618589fd$export$6540a013a39bb50d = (str)=>$f98afd6d618589fd$require$REGEX_SPECIAL_CHARS.test(str);
$f98afd6d618589fd$export$a92319f7ab133839 = (str)=>str.length === 1 && $f98afd6d618589fd$export$6540a013a39bb50d(str);
$f98afd6d618589fd$export$104ed90cc1a13451 = (str)=>str.replace($f98afd6d618589fd$require$REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
$f98afd6d618589fd$export$e610e037975797ee = (str)=>str.replace($f98afd6d618589fd$require$REGEX_BACKSLASH, "/");
$f98afd6d618589fd$export$f403de0a7ba7a743 = (str)=>{
    return str.replace($f98afd6d618589fd$require$REGEX_REMOVE_BACKSLASH, (match)=>{
        return match === "\\" ? "" : match;
    });
};
$f98afd6d618589fd$export$13d0f4185f159c8 = (input, char, lastIdx)=>{
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1) return input;
    if (input[idx - 1] === "\\") return $f98afd6d618589fd$export$13d0f4185f159c8(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};
$f98afd6d618589fd$export$f2888183a34644d4 = (input, state = {})=>{
    let output = input;
    if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
    }
    return output;
};
$f98afd6d618589fd$export$25bddda26836484b = (input, state = {}, options = {})=>{
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) output = `(?:^(?!${output}).*$)`;
    return output;
};
$f98afd6d618589fd$export$9bf319d8f74f51d1 = (path, { windows: windows } = {})=>{
    const segs = path.split(windows ? /[\\/]/ : "/");
    const last = segs[segs.length - 1];
    if (last === "") return segs[segs.length - 2];
    return last;
};

});
parcelRequire.register("emsfP", function(module, exports) {
"use strict";
const $a749097ad8937d36$var$WIN_SLASH = "\\\\/";
const $a749097ad8937d36$var$WIN_NO_SLASH = `[^${$a749097ad8937d36$var$WIN_SLASH}]`;
/**
 * Posix glob regex
 */ const $a749097ad8937d36$var$DOT_LITERAL = "\\.";
const $a749097ad8937d36$var$PLUS_LITERAL = "\\+";
const $a749097ad8937d36$var$QMARK_LITERAL = "\\?";
const $a749097ad8937d36$var$SLASH_LITERAL = "\\/";
const $a749097ad8937d36$var$ONE_CHAR = "(?=.)";
const $a749097ad8937d36$var$QMARK = "[^/]";
const $a749097ad8937d36$var$END_ANCHOR = `(?:${$a749097ad8937d36$var$SLASH_LITERAL}|$)`;
const $a749097ad8937d36$var$START_ANCHOR = `(?:^|${$a749097ad8937d36$var$SLASH_LITERAL})`;
const $a749097ad8937d36$var$DOTS_SLASH = `${$a749097ad8937d36$var$DOT_LITERAL}{1,2}${$a749097ad8937d36$var$END_ANCHOR}`;
const $a749097ad8937d36$var$NO_DOT = `(?!${$a749097ad8937d36$var$DOT_LITERAL})`;
const $a749097ad8937d36$var$NO_DOTS = `(?!${$a749097ad8937d36$var$START_ANCHOR}${$a749097ad8937d36$var$DOTS_SLASH})`;
const $a749097ad8937d36$var$NO_DOT_SLASH = `(?!${$a749097ad8937d36$var$DOT_LITERAL}{0,1}${$a749097ad8937d36$var$END_ANCHOR})`;
const $a749097ad8937d36$var$NO_DOTS_SLASH = `(?!${$a749097ad8937d36$var$DOTS_SLASH})`;
const $a749097ad8937d36$var$QMARK_NO_DOT = `[^.${$a749097ad8937d36$var$SLASH_LITERAL}]`;
const $a749097ad8937d36$var$STAR = `${$a749097ad8937d36$var$QMARK}*?`;
const $a749097ad8937d36$var$SEP = "/";
const $a749097ad8937d36$var$POSIX_CHARS = {
    DOT_LITERAL: $a749097ad8937d36$var$DOT_LITERAL,
    PLUS_LITERAL: $a749097ad8937d36$var$PLUS_LITERAL,
    QMARK_LITERAL: $a749097ad8937d36$var$QMARK_LITERAL,
    SLASH_LITERAL: $a749097ad8937d36$var$SLASH_LITERAL,
    ONE_CHAR: $a749097ad8937d36$var$ONE_CHAR,
    QMARK: $a749097ad8937d36$var$QMARK,
    END_ANCHOR: $a749097ad8937d36$var$END_ANCHOR,
    DOTS_SLASH: $a749097ad8937d36$var$DOTS_SLASH,
    NO_DOT: $a749097ad8937d36$var$NO_DOT,
    NO_DOTS: $a749097ad8937d36$var$NO_DOTS,
    NO_DOT_SLASH: $a749097ad8937d36$var$NO_DOT_SLASH,
    NO_DOTS_SLASH: $a749097ad8937d36$var$NO_DOTS_SLASH,
    QMARK_NO_DOT: $a749097ad8937d36$var$QMARK_NO_DOT,
    STAR: $a749097ad8937d36$var$STAR,
    START_ANCHOR: $a749097ad8937d36$var$START_ANCHOR,
    SEP: $a749097ad8937d36$var$SEP
};
/**
 * Windows glob regex
 */ const $a749097ad8937d36$var$WINDOWS_CHARS = {
    ...$a749097ad8937d36$var$POSIX_CHARS,
    SLASH_LITERAL: `[${$a749097ad8937d36$var$WIN_SLASH}]`,
    QMARK: $a749097ad8937d36$var$WIN_NO_SLASH,
    STAR: `${$a749097ad8937d36$var$WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${$a749097ad8937d36$var$DOT_LITERAL}{1,2}(?:[${$a749097ad8937d36$var$WIN_SLASH}]|$)`,
    NO_DOT: `(?!${$a749097ad8937d36$var$DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${$a749097ad8937d36$var$WIN_SLASH}])${$a749097ad8937d36$var$DOT_LITERAL}{1,2}(?:[${$a749097ad8937d36$var$WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${$a749097ad8937d36$var$DOT_LITERAL}{0,1}(?:[${$a749097ad8937d36$var$WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${$a749097ad8937d36$var$DOT_LITERAL}{1,2}(?:[${$a749097ad8937d36$var$WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${$a749097ad8937d36$var$WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${$a749097ad8937d36$var$WIN_SLASH}])`,
    END_ANCHOR: `(?:[${$a749097ad8937d36$var$WIN_SLASH}]|$)`,
    SEP: "\\"
};
/**
 * POSIX Bracket Regex
 */ const $a749097ad8937d36$var$POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
};
module.exports = {
    MAX_LENGTH: 65536,
    POSIX_REGEX_SOURCE: $a749097ad8937d36$var$POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */ CHAR_9: 57,
    /* 9 */ // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */ CHAR_LOWERCASE_A: 97,
    /* a */ CHAR_UPPERCASE_Z: 90,
    /* Z */ CHAR_LOWERCASE_Z: 122,
    /* z */ CHAR_LEFT_PARENTHESES: 40,
    /* ( */ CHAR_RIGHT_PARENTHESES: 41,
    /* ) */ CHAR_ASTERISK: 42,
    /* * */ // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */ CHAR_AT: 64,
    /* @ */ CHAR_BACKWARD_SLASH: 92,
    /* \ */ CHAR_CARRIAGE_RETURN: 13,
    /* \r */ CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */ CHAR_COLON: 58,
    /* : */ CHAR_COMMA: 44,
    /* , */ CHAR_DOT: 46,
    /* . */ CHAR_DOUBLE_QUOTE: 34,
    /* " */ CHAR_EQUAL: 61,
    /* = */ CHAR_EXCLAMATION_MARK: 33,
    /* ! */ CHAR_FORM_FEED: 12,
    /* \f */ CHAR_FORWARD_SLASH: 47,
    /* / */ CHAR_GRAVE_ACCENT: 96,
    /* ` */ CHAR_HASH: 35,
    /* # */ CHAR_HYPHEN_MINUS: 45,
    /* - */ CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */ CHAR_LEFT_CURLY_BRACE: 123,
    /* { */ CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */ CHAR_LINE_FEED: 10,
    /* \n */ CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */ CHAR_PERCENT: 37,
    /* % */ CHAR_PLUS: 43,
    /* + */ CHAR_QUESTION_MARK: 63,
    /* ? */ CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */ CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */ CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */ CHAR_SEMICOLON: 59,
    /* ; */ CHAR_SINGLE_QUOTE: 39,
    /* ' */ CHAR_SPACE: 32,
    /*   */ CHAR_TAB: 9,
    /* \t */ CHAR_UNDERSCORE: 95,
    /* _ */ CHAR_VERTICAL_LINE: 124,
    /* | */ CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */ /**
   * Create EXTGLOB_CHARS
   */ extglobChars (chars) {
        return {
            "!": {
                type: "negate",
                open: "(?:(?!(?:",
                close: `))${chars.STAR})`
            },
            "?": {
                type: "qmark",
                open: "(?:",
                close: ")?"
            },
            "+": {
                type: "plus",
                open: "(?:",
                close: ")+"
            },
            "*": {
                type: "star",
                open: "(?:",
                close: ")*"
            },
            "@": {
                type: "at",
                open: "(?:",
                close: ")"
            }
        };
    },
    /**
   * Create GLOB_CHARS
   */ globChars (win32) {
        return win32 === true ? $a749097ad8937d36$var$WINDOWS_CHARS : $a749097ad8937d36$var$POSIX_CHARS;
    }
};

});



parcelRequire.register("381AU", function(module, exports) {
"use strict";

var $emsfP = parcelRequire("emsfP");

var $lqji5 = parcelRequire("lqji5");
/**
 * Constants
 */ const { MAX_LENGTH: $24735b10edf6186b$var$MAX_LENGTH, POSIX_REGEX_SOURCE: $24735b10edf6186b$var$POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS: $24735b10edf6186b$var$REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF: $24735b10edf6186b$var$REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS: $24735b10edf6186b$var$REPLACEMENTS } = $emsfP;
/**
 * Helpers
 */ const $24735b10edf6186b$var$expandRange = (args, options)=>{
    if (typeof options.expandRange === "function") return options.expandRange(...args, options);
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
        /* eslint-disable-next-line no-new */ new RegExp(value);
    } catch (ex) {
        return args.map((v)=>$lqji5.escapeRegex(v)).join("..");
    }
    return value;
};
/**
 * Create the message for a syntax error
 */ const $24735b10edf6186b$var$syntaxError = (type, char)=>{
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */ const $24735b10edf6186b$var$parse = (input, options)=>{
    if (typeof input !== "string") throw new TypeError("Expected a string");
    input = $24735b10edf6186b$var$REPLACEMENTS[input] || input;
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($24735b10edf6186b$var$MAX_LENGTH, opts.maxLength) : $24735b10edf6186b$var$MAX_LENGTH;
    let len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    const bos = {
        type: "bos",
        value: "",
        output: opts.prepend || ""
    };
    const tokens = [
        bos
    ];
    const capture = opts.capture ? "" : "?:";
    // create constants based on platform, for windows or posix
    const PLATFORM_CHARS = $emsfP.globChars(opts.windows);
    const EXTGLOB_CHARS = $emsfP.extglobChars(PLATFORM_CHARS);
    const { DOT_LITERAL: DOT_LITERAL, PLUS_LITERAL: PLUS_LITERAL, SLASH_LITERAL: SLASH_LITERAL, ONE_CHAR: ONE_CHAR, DOTS_SLASH: DOTS_SLASH, NO_DOT: NO_DOT, NO_DOT_SLASH: NO_DOT_SLASH, NO_DOTS_SLASH: NO_DOTS_SLASH, QMARK: QMARK, QMARK_NO_DOT: QMARK_NO_DOT, STAR: STAR, START_ANCHOR: START_ANCHOR } = PLATFORM_CHARS;
    const globstar = (opts)=>{
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) star = `(${star})`;
    // minimatch options support
    if (typeof opts.noext === "boolean") opts.noextglob = opts.noext;
    const state = {
        input: input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens: tokens
    };
    input = $lqji5.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    /**
   * Tokenizing helpers
   */ const eos = ()=>state.index === len - 1;
    const peek = state.peek = (n = 1)=>input[state.index + n];
    const advance = state.advance = ()=>input[++state.index] || "";
    const remaining = ()=>input.slice(state.index + 1);
    const consume = (value = "", num = 0)=>{
        state.consumed += value;
        state.index += num;
    };
    const append = (token)=>{
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
    };
    const negate = ()=>{
        let count = 1;
        while(peek() === "!" && (peek(2) !== "(" || peek(3) === "?")){
            advance();
            state.start++;
            count++;
        }
        if (count % 2 === 0) return false;
        state.negated = true;
        state.start++;
        return true;
    };
    const increment = (type)=>{
        state[type]++;
        stack.push(type);
    };
    const decrement = (type)=>{
        state[type]--;
        stack.pop();
    };
    /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */ const push = (tok)=>{
        if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
                state.output = state.output.slice(0, -prev.output.length);
                prev.type = "star";
                prev.value = "*";
                prev.output = star;
                state.output += prev.output;
            }
        }
        if (extglobs.length && tok.type !== "paren") extglobs[extglobs.length - 1].inner += tok.value;
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
            prev.output = (prev.output || prev.value) + tok.value;
            prev.value += tok.value;
            return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
    };
    const extglobOpen = (type, value)=>{
        const token = {
            ...EXTGLOB_CHARS[value],
            conditions: 1,
            inner: ""
        };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({
            type: type,
            value: value,
            output: state.output ? "" : ONE_CHAR
        });
        push({
            type: "paren",
            extglob: true,
            value: advance(),
            output: output
        });
        extglobs.push(token);
    };
    const extglobClose = (token)=>{
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) extglobStar = globstar(opts);
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) output = token.close = `)$))${extglobStar}`;
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
                // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
                // In this case, we need to parse the string and use it in the output of the original pattern.
                // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
                //
                // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
                const expression = $24735b10edf6186b$var$parse(rest, {
                    ...options,
                    fastpaths: false
                }).output;
                output = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === "bos") state.negatedExtglob = true;
        }
        push({
            type: "paren",
            extglob: true,
            value: value,
            output: output
        });
        decrement("parens");
    };
    /**
   * Fast paths
   */ if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace($24735b10edf6186b$var$REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index)=>{
            if (first === "\\") {
                backslashes = true;
                return m;
            }
            if (first === "?") {
                if (esc) return esc + first + (rest ? QMARK.repeat(rest.length) : "");
                if (index === 0) return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
                return QMARK.repeat(chars.length);
            }
            if (first === ".") return DOT_LITERAL.repeat(chars.length);
            if (first === "*") {
                if (esc) return esc + first + (rest ? star : "");
                return star;
            }
            return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
            if (opts.unescape === true) output = output.replace(/\\/g, "");
            else output = output.replace(/\\+/g, (m)=>{
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
        }
        if (output === input && opts.contains === true) {
            state.output = input;
            return state;
        }
        state.output = $lqji5.wrapOutput(output, state, options);
        return state;
    }
    /**
   * Tokenize input until we reach end-of-string
   */ while(!eos()){
        value = advance();
        if (value === "\x00") continue;
        /**
     * Escaped characters
     */ if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) continue;
            if (next === "." || next === ";") continue;
            if (!next) {
                value += "\\";
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
                slashes = match[0].length;
                state.index += slashes;
                if (slashes % 2 !== 0) value += "\\";
            }
            if (opts.unescape === true) value = advance();
            else value += advance();
            if (state.brackets === 0) {
                push({
                    type: "text",
                    value: value
                });
                continue;
            }
        }
        /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */ if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
                const inner = prev.value.slice(1);
                if (inner.includes("[")) {
                    prev.posix = true;
                    if (inner.includes(":")) {
                        const idx = prev.value.lastIndexOf("[");
                        const pre = prev.value.slice(0, idx);
                        const rest = prev.value.slice(idx + 2);
                        const posix = $24735b10edf6186b$var$POSIX_REGEX_SOURCE[rest];
                        if (posix) {
                            prev.value = pre + posix;
                            state.backtrack = true;
                            advance();
                            if (!bos.output && tokens.indexOf(prev) === 1) bos.output = ONE_CHAR;
                            continue;
                        }
                    }
                }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") value = `\\${value}`;
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) value = `\\${value}`;
            if (opts.posix === true && value === "!" && prev.value === "[") value = "^";
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */ if (state.quotes === 1 && value !== '"') {
            value = $lqji5.escapeRegex(value);
            prev.value += value;
            append({
                value: value
            });
            continue;
        }
        /**
     * Double quotes
     */ if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Parentheses
     */ if (value === "(") {
            increment("parens");
            push({
                type: "paren",
                value: value
            });
            continue;
        }
        if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("opening", "("));
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
                extglobClose(extglobs.pop());
                continue;
            }
            push({
                type: "paren",
                value: value,
                output: state.parens ? ")" : "\\)"
            });
            decrement("parens");
            continue;
        }
        /**
     * Square brackets
     */ if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
                if (opts.nobracket !== true && opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("closing", "]"));
                value = `\\${value}`;
            } else increment("brackets");
            push({
                type: "bracket",
                value: value
            });
            continue;
        }
        if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            if (state.brackets === 0) {
                if (opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("opening", "["));
                push({
                    type: "text",
                    value: value,
                    output: `\\${value}`
                });
                continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) value = `/${value}`;
            prev.value += value;
            append({
                value: value
            });
            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (opts.literalBrackets === false || $lqji5.hasRegexChars(prevValue)) continue;
            const escaped = $lqji5.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
                state.output += escaped;
                prev.value = escaped;
                continue;
            }
            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
        }
        /**
     * Braces
     */ if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
                type: "brace",
                value: value,
                output: "(",
                outputIndex: state.output.length,
                tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
        }
        if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
                push({
                    type: "text",
                    value: value,
                    output: value
                });
                continue;
            }
            let output = ")";
            if (brace.dots === true) {
                const arr = tokens.slice();
                const range = [];
                for(let i = arr.length - 1; i >= 0; i--){
                    tokens.pop();
                    if (arr[i].type === "brace") break;
                    if (arr[i].type !== "dots") range.unshift(arr[i].value);
                }
                output = $24735b10edf6186b$var$expandRange(range, opts);
                state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
                const out = state.output.slice(0, brace.outputIndex);
                const toks = state.tokens.slice(brace.tokensIndex);
                brace.value = brace.output = "\\{";
                value = output = "\\}";
                state.output = out;
                for (const t of toks)state.output += t.output || t.value;
            }
            push({
                type: "brace",
                value: value,
                output: output
            });
            decrement("braces");
            braces.pop();
            continue;
        }
        /**
     * Pipes
     */ if (value === "|") {
            if (extglobs.length > 0) extglobs[extglobs.length - 1].conditions++;
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Commas
     */ if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
                brace.comma = true;
                output = "|";
            }
            push({
                type: "comma",
                value: value,
                output: output
            });
            continue;
        }
        /**
     * Slashes
     */ if (value === "/") {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === "dot" && state.index === state.start + 1) {
                state.start = state.index + 1;
                state.consumed = "";
                state.output = "";
                tokens.pop();
                prev = bos; // reset "prev" to the first token
                continue;
            }
            push({
                type: "slash",
                value: value,
                output: SLASH_LITERAL
            });
            continue;
        }
        /**
     * Dots
     */ if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
                if (prev.value === ".") prev.output = DOT_LITERAL;
                const brace = braces[braces.length - 1];
                prev.type = "dots";
                prev.output += value;
                prev.value += value;
                brace.dots = true;
                continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
                push({
                    type: "text",
                    value: value,
                    output: DOT_LITERAL
                });
                continue;
            }
            push({
                type: "dot",
                value: value,
                output: DOT_LITERAL
            });
            continue;
        }
        /**
     * Question marks
     */ if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("qmark", value);
                continue;
            }
            if (prev && prev.type === "paren") {
                const next = peek();
                let output = value;
                if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) output = `\\${value}`;
                push({
                    type: "text",
                    value: value,
                    output: output
                });
                continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
                push({
                    type: "qmark",
                    value: value,
                    output: QMARK_NO_DOT
                });
                continue;
            }
            push({
                type: "qmark",
                value: value,
                output: QMARK
            });
            continue;
        }
        /**
     * Exclamation
     */ if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
                if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                    extglobOpen("negate", value);
                    continue;
                }
            }
            if (opts.nonegate !== true && state.index === 0) {
                negate();
                continue;
            }
        }
        /**
     * Plus
     */ if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                extglobOpen("plus", value);
                continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
                push({
                    type: "plus",
                    value: value,
                    output: PLUS_LITERAL
                });
                continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
                push({
                    type: "plus",
                    value: value
                });
                continue;
            }
            push({
                type: "plus",
                value: PLUS_LITERAL
            });
            continue;
        }
        /**
     * Plain text
     */ if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
                push({
                    type: "at",
                    extglob: true,
                    value: value,
                    output: ""
                });
                continue;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Plain text
     */ if (value !== "*") {
            if (value === "$" || value === "^") value = `\\${value}`;
            const match = $24735b10edf6186b$var$REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
                value += match[0];
                state.index += match[0].length;
            }
            push({
                type: "text",
                value: value
            });
            continue;
        }
        /**
     * Stars
     */ if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
        }
        if (prev.type === "star") {
            if (opts.noglobstar === true) {
                consume(value);
                continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
                push({
                    type: "star",
                    value: value,
                    output: ""
                });
                continue;
            }
            // strip consecutive `/**/`
            while(rest.slice(0, 3) === "/**"){
                const after = input[state.index + 4];
                if (after && after !== "/") break;
                rest = rest.slice(3);
                consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
                prev.type = "globstar";
                prev.value += value;
                prev.output = globstar(opts);
                state.output = prev.output;
                state.globstar = true;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
                prev.value += value;
                state.globstar = true;
                state.output += prior.output + prev.output;
                consume(value);
                continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
                const end = rest[1] !== void 0 ? "|$" : "";
                state.output = state.output.slice(0, -(prior.output + prev.output).length);
                prior.output = `(?:${prior.output}`;
                prev.type = "globstar";
                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
                prev.value += value;
                state.output += prior.output + prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
                prev.type = "globstar";
                prev.value += value;
                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
                state.output = prev.output;
                state.globstar = true;
                consume(value + advance());
                push({
                    type: "slash",
                    value: "/",
                    output: ""
                });
                continue;
            }
            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length);
            // reset previous token to globstar
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            // reset output with globstar
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
        }
        const token = {
            type: "star",
            value: value,
            output: star
        };
        if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") token.output = nodot + token.output;
            push(token);
            continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
                state.output += NO_DOT_SLASH;
                prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
                state.output += NO_DOTS_SLASH;
                prev.output += NO_DOTS_SLASH;
            } else {
                state.output += nodot;
                prev.output += nodot;
            }
            if (peek() !== "*") {
                state.output += ONE_CHAR;
                prev.output += ONE_CHAR;
            }
        }
        push(token);
    }
    while(state.brackets > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("closing", "]"));
        state.output = $lqji5.escapeLast(state.output, "[");
        decrement("brackets");
    }
    while(state.parens > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("closing", ")"));
        state.output = $lqji5.escapeLast(state.output, "(");
        decrement("parens");
    }
    while(state.braces > 0){
        if (opts.strictBrackets === true) throw new SyntaxError($24735b10edf6186b$var$syntaxError("closing", "}"));
        state.output = $lqji5.escapeLast(state.output, "{");
        decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) push({
        type: "maybe_slash",
        value: "",
        output: `${SLASH_LITERAL}?`
    });
    // rebuild the output if we had to backtrack at any point
    if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens){
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) state.output += token.suffix;
        }
    }
    return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */ $24735b10edf6186b$var$parse.fastpaths = (input, options)=>{
    const opts = {
        ...options
    };
    const max = typeof opts.maxLength === "number" ? Math.min($24735b10edf6186b$var$MAX_LENGTH, opts.maxLength) : $24735b10edf6186b$var$MAX_LENGTH;
    const len = input.length;
    if (len > max) throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    input = $24735b10edf6186b$var$REPLACEMENTS[input] || input;
    // create constants based on platform, for windows or posix
    const { DOT_LITERAL: DOT_LITERAL, SLASH_LITERAL: SLASH_LITERAL, ONE_CHAR: ONE_CHAR, DOTS_SLASH: DOTS_SLASH, NO_DOT: NO_DOT, NO_DOTS: NO_DOTS, NO_DOTS_SLASH: NO_DOTS_SLASH, STAR: STAR, START_ANCHOR: START_ANCHOR } = $emsfP.globChars(opts.windows);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {
        negated: false,
        prefix: ""
    };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) star = `(${star})`;
    const globstar = (opts)=>{
        if (opts.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str)=>{
        switch(str){
            case "*":
                return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
                return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
                return nodot + globstar(opts);
            case "**/*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default:
                {
                    const match = /^(.*?)\.(\w+)$/.exec(str);
                    if (!match) return;
                    const source = create(match[1]);
                    if (!source) return;
                    return source + DOT_LITERAL + match[2];
                }
        }
    };
    const output = $lqji5.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) source += `${SLASH_LITERAL}?`;
    return source;
};
module.exports = $24735b10edf6186b$var$parse;

});


/*global globalObject, virtualfs*/ 
var $kznHi = parcelRequire("kznHi");
var $3132870559d60e53$require$Buffer = $kznHi.Buffer;
var $8adf1cfaed2eb5b1$exports = {};
parcelRequire = function(e, r, t, n) {
    var i, o = "function" == typeof parcelRequire && parcelRequire, u = undefined;
    function f(t, n) {
        if (!r[t]) {
            if (!e[t]) {
                var i = "function" == typeof parcelRequire && parcelRequire;
                if (!n && i) return i(t, !0);
                if (o) return o(t, !0);
                if (u && "string" == typeof t) return u(t);
                var c = new Error("Cannot find module '" + t + "'");
                throw c.code = "MODULE_NOT_FOUND", c;
            }
            p.resolve = function(r) {
                return e[t][1][r] || r;
            }, p.cache = {};
            var l = r[t] = new f.Module(t);
            e[t][0].call(l.exports, p, l, l.exports, this);
        }
        return r[t].exports;
        function p(e) {
            return f(p.resolve(e));
        }
    }
    f.isParcelRequire = !0, f.Module = function(e) {
        this.id = e, this.bundle = f, this.exports = {};
    }, f.modules = e, f.cache = r, f.parent = o, f.register = function(r, t) {
        e[r] = [
            function(e, r) {
                r.exports = t;
            },
            {}
        ];
    };
    for(var c = 0; c < t.length; c++)try {
        f(t[c]);
    } catch (e) {
        i || (i = e);
    }
    if (t.length) {
        var l = f(t[t.length - 1]);
        $8adf1cfaed2eb5b1$exports = l;
    }
    if (parcelRequire = f, i) throw i;
    return f;
}({
    "b1ZG": [
        function(require1, module1, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.promisify = e;
            var r = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
            function e(o) {
                if ("function" != typeof o) throw new TypeError("Argument to promisify must be a function");
                var n = o[r], t = e.Promise || Promise;
                if ("function" != typeof t) throw new Error("No Promise implementation found; do you need a polyfill?");
                return function() {
                    for(var r = this, e = arguments.length, i = Array(e), f = 0; f < e; f++)i[f] = arguments[f];
                    return new t(function(e, t) {
                        i.push(function(r) {
                            if (r) return t(r);
                            for(var o = arguments.length, i = Array(1 < o ? o - 1 : 0), f = 1; f < o; f++)i[f - 1] = arguments[f];
                            if (1 === i.length || !n) return e(i[0]);
                            var u = {};
                            i.forEach(function(r, e) {
                                var o = n[e];
                                o && (u[o] = r);
                            }), e(u);
                        }), o.apply(r, i);
                    });
                };
            }
            e.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", e.Promise = void 0;
        },
        {}
    ],
    "pBGv": [
        function(require1, module1, exports) {
            var t, e, n = module1.exports = {};
            function r() {
                throw new Error("setTimeout has not been defined");
            }
            function o() {
                throw new Error("clearTimeout has not been defined");
            }
            function i(e) {
                if (t === setTimeout) return setTimeout(e, 0);
                if ((t === r || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);
                try {
                    return t(e, 0);
                } catch (n) {
                    try {
                        return t.call(null, e, 0);
                    } catch (n) {
                        return t.call(this, e, 0);
                    }
                }
            }
            function u(t) {
                if (e === clearTimeout) return clearTimeout(t);
                if ((e === o || !e) && clearTimeout) return e = clearTimeout, clearTimeout(t);
                try {
                    return e(t);
                } catch (n) {
                    try {
                        return e.call(null, t);
                    } catch (n) {
                        return e.call(this, t);
                    }
                }
            }
            !function() {
                try {
                    t = "function" == typeof setTimeout ? setTimeout : r;
                } catch (n) {
                    t = r;
                }
                try {
                    e = "function" == typeof clearTimeout ? clearTimeout : o;
                } catch (n) {
                    e = o;
                }
            }();
            var c, s = [], l = !1, a = -1;
            function f() {
                l && c && (l = !1, c.length ? s = c.concat(s) : a = -1, s.length && h());
            }
            function h() {
                if (!l) {
                    var t = i(f);
                    l = !0;
                    for(var e = s.length; e;){
                        for(c = s, s = []; ++a < e;)c && c[a].run();
                        a = -1, e = s.length;
                    }
                    c = null, l = !1, u(t);
                }
            }
            function m(t, e) {
                this.fun = t, this.array = e;
            }
            function p() {}
            n.nextTick = function(t) {
                var e = new Array(arguments.length - 1);
                if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n];
                s.push(new m(t, e)), 1 !== s.length || l || i(h);
            }, m.prototype.run = function() {
                this.fun.apply(null, this.array);
            }, n.title = "browser", n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function(t) {
                return [];
            }, n.binding = function(t) {
                throw new Error("process.binding is not supported");
            }, n.cwd = function() {
                return "/";
            }, n.chdir = function(t) {
                throw new Error("process.chdir is not supported");
            }, n.umask = function() {
                return 0;
            };
        },
        {}
    ],
    "UUq2": [
        function(require1, module1, exports) {
            var process = require1("process");
            var r = require1("process");
            function t(r, t) {
                for(var e = 0, n = r.length - 1; n >= 0; n--){
                    var o = r[n];
                    "." === o ? r.splice(n, 1) : ".." === o ? (r.splice(n, 1), e++) : e && (r.splice(n, 1), e--);
                }
                if (t) for(; e--; e)r.unshift("..");
                return r;
            }
            function e(r) {
                "string" != typeof r && (r += "");
                var t, e = 0, n = -1, o = !0;
                for(t = r.length - 1; t >= 0; --t)if (47 === r.charCodeAt(t)) {
                    if (!o) {
                        e = t + 1;
                        break;
                    }
                } else -1 === n && (o = !1, n = t + 1);
                return -1 === n ? "" : r.slice(e, n);
            }
            function n(r, t) {
                if (r.filter) return r.filter(t);
                for(var e = [], n = 0; n < r.length; n++)t(r[n], n, r) && e.push(r[n]);
                return e;
            }
            exports.resolve = function() {
                for(var e = "", o = !1, s = arguments.length - 1; s >= -1 && !o; s--){
                    var i = s >= 0 ? arguments[s] : r.cwd();
                    if ("string" != typeof i) throw new TypeError("Arguments to path.resolve must be strings");
                    i && (e = i + "/" + e, o = "/" === i.charAt(0));
                }
                return (o ? "/" : "") + (e = t(n(e.split("/"), function(r) {
                    return !!r;
                }), !o).join("/")) || ".";
            }, exports.normalize = function(r) {
                var e = exports.isAbsolute(r), s = "/" === o(r, -1);
                return (r = t(n(r.split("/"), function(r) {
                    return !!r;
                }), !e).join("/")) || e || (r = "."), r && s && (r += "/"), (e ? "/" : "") + r;
            }, exports.isAbsolute = function(r) {
                return "/" === r.charAt(0);
            }, exports.join = function() {
                var r = Array.prototype.slice.call(arguments, 0);
                return exports.normalize(n(r, function(r, t) {
                    if ("string" != typeof r) throw new TypeError("Arguments to path.join must be strings");
                    return r;
                }).join("/"));
            }, exports.relative = function(r, t) {
                function e(r) {
                    for(var t = 0; t < r.length && "" === r[t]; t++);
                    for(var e = r.length - 1; e >= 0 && "" === r[e]; e--);
                    return t > e ? [] : r.slice(t, e - t + 1);
                }
                r = exports.resolve(r).substr(1), t = exports.resolve(t).substr(1);
                for(var n = e(r.split("/")), o = e(t.split("/")), s = Math.min(n.length, o.length), i = s, u = 0; u < s; u++)if (n[u] !== o[u]) {
                    i = u;
                    break;
                }
                var f = [];
                for(u = i; u < n.length; u++)f.push("..");
                return (f = f.concat(o.slice(i))).join("/");
            }, exports.sep = "/", exports.delimiter = ":", exports.dirname = function(r) {
                if ("string" != typeof r && (r += ""), 0 === r.length) return ".";
                for(var t = r.charCodeAt(0), e = 47 === t, n = -1, o = !0, s = r.length - 1; s >= 1; --s)if (47 === (t = r.charCodeAt(s))) {
                    if (!o) {
                        n = s;
                        break;
                    }
                } else o = !1;
                return -1 === n ? e ? "/" : "." : e && 1 === n ? "/" : r.slice(0, n);
            }, exports.basename = function(r, t) {
                var n = e(r);
                return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n;
            }, exports.extname = function(r) {
                "string" != typeof r && (r += "");
                for(var t = -1, e = 0, n = -1, o = !0, s = 0, i = r.length - 1; i >= 0; --i){
                    var u = r.charCodeAt(i);
                    if (47 !== u) -1 === n && (o = !1, n = i + 1), 46 === u ? -1 === t ? t = i : 1 !== s && (s = 1) : -1 !== t && (s = -1);
                    else if (!o) {
                        e = i + 1;
                        break;
                    }
                }
                return -1 === t || -1 === n || 0 === s || 1 === s && t === n - 1 && t === e + 1 ? "" : r.slice(t, n);
            };
            var o = "b" === "ab".substr(-1) ? function(r, t, e) {
                return r.substr(t, e);
            } : function(r, t, e) {
                return t < 0 && (t = r.length + t), r.substr(t, e);
            };
        },
        {
            "process": "pBGv"
        }
    ],
    "UzoP": [
        function(require1, module1, exports) {
            var process = require1("process");
            var r = require1("process");
            r.cwd = function() {
                return "/";
            };
            var e = require1("path"), n = Object.assign({}, e);
            n.basename = function(r, n) {
                var i = e.basename(r, n);
                return "" === i ? "/" : i;
            }, n.normalize = function(r) {
                return "/" === (r = e.normalize(r)) ? r : n.removeTrailing(r);
            }, n.isNull = function(r) {
                return -1 !== ("" + r).indexOf("\x00");
            }, n.addTrailing = function(r) {
                return r.replace(/\/*$/, "/");
            }, n.removeTrailing = function(r) {
                return "" === (r = r.replace(/\/*$/, "")) ? "/" : r;
            }, module1.exports = n;
        },
        {
            "path": "UUq2",
            "process": "pBGv"
        }
    ],
    "iJA9": [
        function(require1, module1, exports) {
            var _ = "READ", E = "WRITE", O = "CREATE", R = "EXCLUSIVE", I = "TRUNCATE", S = "APPEND", T = "CREATE", N = "REPLACE";
            module1.exports = {
                FILE_SYSTEM_NAME: "local",
                FILE_STORE_NAME: "files",
                IDB_RO: "readonly",
                IDB_RW: "readwrite",
                WSQL_VERSION: "1",
                WSQL_SIZE: 5242880,
                WSQL_DESC: "FileSystem Storage",
                NODE_TYPE_FILE: "FILE",
                NODE_TYPE_DIRECTORY: "DIRECTORY",
                NODE_TYPE_SYMBOLIC_LINK: "SYMLINK",
                NODE_TYPE_META: "META",
                DEFAULT_DIR_PERMISSIONS: 493,
                DEFAULT_FILE_PERMISSIONS: 420,
                FULL_READ_WRITE_EXEC_PERMISSIONS: 511,
                READ_WRITE_PERMISSIONS: 438,
                SYMLOOP_MAX: 10,
                BINARY_MIME_TYPE: "application/octet-stream",
                JSON_MIME_TYPE: "application/json",
                ROOT_DIRECTORY_NAME: "/",
                FS_FORMAT: "FORMAT",
                FS_NOCTIME: "NOCTIME",
                FS_NOMTIME: "NOMTIME",
                FS_NODUPEIDCHECK: "FS_NODUPEIDCHECK",
                O_READ: _,
                O_WRITE: E,
                O_CREATE: O,
                O_EXCLUSIVE: R,
                O_TRUNCATE: I,
                O_APPEND: S,
                O_FLAGS: {
                    r: [
                        _
                    ],
                    "r+": [
                        _,
                        E
                    ],
                    w: [
                        E,
                        O,
                        I
                    ],
                    "w+": [
                        E,
                        _,
                        O,
                        I
                    ],
                    wx: [
                        E,
                        O,
                        R,
                        I
                    ],
                    "wx+": [
                        E,
                        _,
                        O,
                        R,
                        I
                    ],
                    a: [
                        E,
                        O,
                        S
                    ],
                    "a+": [
                        E,
                        _,
                        O,
                        S
                    ],
                    ax: [
                        E,
                        O,
                        R,
                        S
                    ],
                    "ax+": [
                        E,
                        _,
                        O,
                        R,
                        S
                    ]
                },
                XATTR_CREATE: T,
                XATTR_REPLACE: N,
                FS_READY: "READY",
                FS_PENDING: "PENDING",
                FS_ERROR: "ERROR",
                SUPER_NODE_ID: "00000000-0000-0000-0000-000000000000",
                STDIN: 0,
                STDOUT: 1,
                STDERR: 2,
                FIRST_DESCRIPTOR: 3,
                ENVIRONMENT: {
                    TMP: "/tmp",
                    PATH: ""
                },
                fsConstants: {
                    O_RDONLY: 0,
                    O_WRONLY: 1,
                    O_RDWR: 2,
                    S_IFMT: 61440,
                    S_IFREG: 32768,
                    S_IFDIR: 16384,
                    S_IFCHR: 8192,
                    S_IFBLK: 24576,
                    S_IFIFO: 4096,
                    S_IFLNK: 40960,
                    S_IFSOCK: 49152,
                    O_CREAT: 512,
                    O_EXCL: 2048,
                    O_NOCTTY: 131072,
                    O_TRUNC: 1024,
                    O_APPEND: 8,
                    O_DIRECTORY: 1048576,
                    O_NOFOLLOW: 256,
                    O_SYNC: 128,
                    O_DSYNC: 4194304,
                    O_SYMLINK: 2097152,
                    O_NONBLOCK: 4,
                    S_IRWXU: 448,
                    S_IRUSR: 256,
                    S_IWUSR: 128,
                    S_IXUSR: 64,
                    S_IRWXG: 56,
                    S_IRGRP: 32,
                    S_IWGRP: 16,
                    S_IXGRP: 8,
                    S_IRWXO: 7,
                    S_IROTH: 4,
                    S_IWOTH: 2,
                    S_IXOTH: 1,
                    F_OK: 0,
                    R_OK: 4,
                    W_OK: 2,
                    X_OK: 1,
                    UV_FS_COPYFILE_EXCL: 1,
                    COPYFILE_EXCL: 1
                }
            };
        },
        {}
    ],
    "yh9p": [
        function(require1, module1, exports) {
            "use strict";
            exports.byteLength = u, exports.toByteArray = i, exports.fromByteArray = d;
            for(var r = [], t = [], e = "undefined" != typeof Uint8Array ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = n.length; o < a; ++o)r[o] = n[o], t[n.charCodeAt(o)] = o;
            function h(r) {
                var t = r.length;
                if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var e = r.indexOf("=");
                return -1 === e && (e = t), [
                    e,
                    e === t ? 0 : 4 - e % 4
                ];
            }
            function u(r) {
                var t = h(r), e = t[0], n = t[1];
                return 3 * (e + n) / 4 - n;
            }
            function c(r, t, e) {
                return 3 * (t + e) / 4 - e;
            }
            function i(r) {
                var n, o, a = h(r), u = a[0], i = a[1], f = new e(c(r, u, i)), A = 0, d = i > 0 ? u - 4 : u;
                for(o = 0; o < d; o += 4)n = t[r.charCodeAt(o)] << 18 | t[r.charCodeAt(o + 1)] << 12 | t[r.charCodeAt(o + 2)] << 6 | t[r.charCodeAt(o + 3)], f[A++] = n >> 16 & 255, f[A++] = n >> 8 & 255, f[A++] = 255 & n;
                return 2 === i && (n = t[r.charCodeAt(o)] << 2 | t[r.charCodeAt(o + 1)] >> 4, f[A++] = 255 & n), 1 === i && (n = t[r.charCodeAt(o)] << 10 | t[r.charCodeAt(o + 1)] << 4 | t[r.charCodeAt(o + 2)] >> 2, f[A++] = n >> 8 & 255, f[A++] = 255 & n), f;
            }
            function f(t) {
                return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t];
            }
            function A(r, t, e) {
                for(var n, o = [], a = t; a < e; a += 3)n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (255 & r[a + 2]), o.push(f(n));
                return o.join("");
            }
            function d(t) {
                for(var e, n = t.length, o = n % 3, a = [], h = 0, u = n - o; h < u; h += 16383)a.push(A(t, h, h + 16383 > u ? u : h + 16383));
                return 1 === o ? (e = t[n - 1], a.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === o && (e = (t[n - 2] << 8) + t[n - 1], a.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), a.join("");
            }
            t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
        },
        {}
    ],
    "JgNJ": [
        function(require1, module1, exports) {
            exports.read = function(a, o, t, r, h) {
                var M, p, w = 8 * h - r - 1, f = (1 << w) - 1, e = f >> 1, i = -7, N = t ? h - 1 : 0, n = t ? -1 : 1, s = a[o + N];
                for(N += n, M = s & (1 << -i) - 1, s >>= -i, i += w; i > 0; M = 256 * M + a[o + N], N += n, i -= 8);
                for(p = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; p = 256 * p + a[o + N], N += n, i -= 8);
                if (0 === M) M = 1 - e;
                else {
                    if (M === f) return p ? NaN : 1 / 0 * (s ? -1 : 1);
                    p += Math.pow(2, r), M -= e;
                }
                return (s ? -1 : 1) * p * Math.pow(2, M - r);
            }, exports.write = function(a, o, t, r, h, M) {
                var p, w, f, e = 8 * M - h - 1, i = (1 << e) - 1, N = i >> 1, n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0, s = r ? 0 : M - 1, u = r ? 1 : -1, l = o < 0 || 0 === o && 1 / o < 0 ? 1 : 0;
                for(o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, p = i) : (p = Math.floor(Math.log(o) / Math.LN2), o * (f = Math.pow(2, -p)) < 1 && (p--, f *= 2), (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >= 2 && (p++, f /= 2), p + N >= i ? (w = 0, p = i) : p + N >= 1 ? (w = (o * f - 1) * Math.pow(2, h), p += N) : (w = o * Math.pow(2, N - 1) * Math.pow(2, h), p = 0)); h >= 8; a[t + s] = 255 & w, s += u, w /= 256, h -= 8);
                for(p = p << h | w, e += h; e > 0; a[t + s] = 255 & p, s += u, p /= 256, e -= 8);
                a[t + s - u] |= 128 * l;
            };
        },
        {}
    ],
    "REa7": [
        function(require1, module1, exports) {
            var r = {}.toString;
            module1.exports = Array.isArray || function(t) {
                return "[object Array]" == r.call(t);
            };
        },
        {}
    ],
    "dskh": [
        function(require1, module1, exports) {
            var global = arguments[3];
            var t = arguments[3], r = require1("base64-js"), e = require1("ieee754"), n = require1("isarray");
            function i() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42;
                        }
                    }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;
                } catch (r) {
                    return !1;
                }
            }
            function o() {
                return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
            }
            function u(t, r) {
                if (o() < r) throw new RangeError("Invalid typed array length");
                return f.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = f.prototype : (null === t && (t = new f(r)), t.length = r), t;
            }
            function f(t, r, e) {
                if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f)) return new f(t, r, e);
                if ("number" == typeof t) {
                    if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string");
                    return c(this, t);
                }
                return s(this, t, r, e);
            }
            function s(t, r, e, n) {
                if ("number" == typeof r) throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? g(t, r, e, n) : "string" == typeof r ? l(t, r, e) : y(t, r);
            }
            function h(t) {
                if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
                if (t < 0) throw new RangeError('"size" argument must not be negative');
            }
            function a(t, r, e, n) {
                return h(r), r <= 0 ? u(t, r) : void 0 !== e ? "string" == typeof n ? u(t, r).fill(e, n) : u(t, r).fill(e) : u(t, r);
            }
            function c(t, r) {
                if (h(r), t = u(t, r < 0 ? 0 : 0 | w(r)), !f.TYPED_ARRAY_SUPPORT) for(var e = 0; e < r; ++e)t[e] = 0;
                return t;
            }
            function l(t, r, e) {
                if ("string" == typeof e && "" !== e || (e = "utf8"), !f.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding');
                var n = 0 | v(r, e), i = (t = u(t, n)).write(r, e);
                return i !== n && (t = t.slice(0, i)), t;
            }
            function p(t, r) {
                var e = r.length < 0 ? 0 : 0 | w(r.length);
                t = u(t, e);
                for(var n = 0; n < e; n += 1)t[n] = 255 & r[n];
                return t;
            }
            function g(t, r, e, n) {
                if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds");
                if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds");
                return r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n), f.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = f.prototype : t = p(t, r), t;
            }
            function y(t, r) {
                if (f.isBuffer(r)) {
                    var e = 0 | w(r.length);
                    return 0 === (t = u(t, e)).length ? t : (r.copy(t, 0, 0, e), t);
                }
                if (r) {
                    if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || W(r.length) ? u(t, 0) : p(t, r);
                    if ("Buffer" === r.type && n(r.data)) return p(t, r.data);
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            }
            function w(t) {
                if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes");
                return 0 | t;
            }
            function d(t) {
                return +t != t && (t = 0), f.alloc(+t);
            }
            function v(t, r) {
                if (f.isBuffer(t)) return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var e = t.length;
                if (0 === e) return 0;
                for(var n = !1;;)switch(r){
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return e;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return $(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * e;
                    case "hex":
                        return e >>> 1;
                    case "base64":
                        return K(t).length;
                    default:
                        if (n) return $(t).length;
                        r = ("" + r).toLowerCase(), n = !0;
                }
            }
            function E(t, r, e) {
                var n = !1;
                if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
                if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
                if ((e >>>= 0) <= (r >>>= 0)) return "";
                for(t || (t = "utf8");;)switch(t){
                    case "hex":
                        return x(this, r, e);
                    case "utf8":
                    case "utf-8":
                        return Y(this, r, e);
                    case "ascii":
                        return L(this, r, e);
                    case "latin1":
                    case "binary":
                        return D(this, r, e);
                    case "base64":
                        return S(this, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return C(this, r, e);
                    default:
                        if (n) throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(), n = !0;
                }
            }
            function b(t, r, e) {
                var n = t[r];
                t[r] = t[e], t[e] = n;
            }
            function R(t, r, e, n, i) {
                if (0 === t.length) return -1;
                if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
                    if (i) return -1;
                    e = t.length - 1;
                } else if (e < 0) {
                    if (!i) return -1;
                    e = 0;
                }
                if ("string" == typeof r && (r = f.from(r, n)), f.isBuffer(r)) return 0 === r.length ? -1 : _(t, r, e, n, i);
                if ("number" == typeof r) return r &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : _(t, [
                    r
                ], e, n, i);
                throw new TypeError("val must be string, number or Buffer");
            }
            function _(t, r, e, n, i) {
                var o, u = 1, f = t.length, s = r.length;
                if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                    if (t.length < 2 || r.length < 2) return -1;
                    u = 2, f /= 2, s /= 2, e /= 2;
                }
                function h(t, r) {
                    return 1 === u ? t[r] : t.readUInt16BE(r * u);
                }
                if (i) {
                    var a = -1;
                    for(o = e; o < f; o++)if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                        if (-1 === a && (a = o), o - a + 1 === s) return a * u;
                    } else -1 !== a && (o -= o - a), a = -1;
                } else for(e + s > f && (e = f - s), o = e; o >= 0; o--){
                    for(var c = !0, l = 0; l < s; l++)if (h(t, o + l) !== h(r, l)) {
                        c = !1;
                        break;
                    }
                    if (c) return o;
                }
                return -1;
            }
            function A(t, r, e, n) {
                e = Number(e) || 0;
                var i = t.length - e;
                n ? (n = Number(n)) > i && (n = i) : n = i;
                var o = r.length;
                if (o % 2 != 0) throw new TypeError("Invalid hex string");
                n > o / 2 && (n = o / 2);
                for(var u = 0; u < n; ++u){
                    var f = parseInt(r.substr(2 * u, 2), 16);
                    if (isNaN(f)) return u;
                    t[e + u] = f;
                }
                return u;
            }
            function m(t, r, e, n) {
                return Q($(r, t.length - e), t, e, n);
            }
            function P(t, r, e, n) {
                return Q(G(r), t, e, n);
            }
            function T(t, r, e, n) {
                return P(t, r, e, n);
            }
            function B(t, r, e, n) {
                return Q(K(r), t, e, n);
            }
            function U(t, r, e, n) {
                return Q(H(r, t.length - e), t, e, n);
            }
            function S(t, e, n) {
                return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n));
            }
            function Y(t, r, e) {
                e = Math.min(t.length, e);
                for(var n = [], i = r; i < e;){
                    var o, u, f, s, h = t[i], a = null, c = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                    if (i + c <= e) switch(c){
                        case 1:
                            h < 128 && (a = h);
                            break;
                        case 2:
                            128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                            break;
                        case 3:
                            o = t[i + 1], u = t[i + 2], 128 == (192 & o) && 128 == (192 & u) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & u) > 2047 && (s < 55296 || s > 57343) && (a = s);
                            break;
                        case 4:
                            o = t[i + 1], u = t[i + 2], f = t[i + 3], 128 == (192 & o) && 128 == (192 & u) && 128 == (192 & f) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & u) << 6 | 63 & f) > 65535 && s < 1114112 && (a = s);
                    }
                    null === a ? (a = 65533, c = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += c;
                }
                return O(n);
            }
            exports.Buffer = f, exports.SlowBuffer = d, exports.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : i(), exports.kMaxLength = o(), f.poolSize = 8192, f._augment = function(t) {
                return t.__proto__ = f.prototype, t;
            }, f.from = function(t, r, e) {
                return s(null, t, r, e);
            }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, {
                value: null,
                configurable: !0
            })), f.alloc = function(t, r, e) {
                return a(null, t, r, e);
            }, f.allocUnsafe = function(t) {
                return c(null, t);
            }, f.allocUnsafeSlow = function(t) {
                return c(null, t);
            }, f.isBuffer = function(t) {
                return !(null == t || !t._isBuffer);
            }, f.compare = function(t, r) {
                if (!f.isBuffer(t) || !f.isBuffer(r)) throw new TypeError("Arguments must be Buffers");
                if (t === r) return 0;
                for(var e = t.length, n = r.length, i = 0, o = Math.min(e, n); i < o; ++i)if (t[i] !== r[i]) {
                    e = t[i], n = r[i];
                    break;
                }
                return e < n ? -1 : n < e ? 1 : 0;
            }, f.isEncoding = function(t) {
                switch(String(t).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1;
                }
            }, f.concat = function(t, r) {
                if (!n(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length) return f.alloc(0);
                var e;
                if (void 0 === r) for(r = 0, e = 0; e < t.length; ++e)r += t[e].length;
                var i = f.allocUnsafe(r), o = 0;
                for(e = 0; e < t.length; ++e){
                    var u = t[e];
                    if (!f.isBuffer(u)) throw new TypeError('"list" argument must be an Array of Buffers');
                    u.copy(i, o), o += u.length;
                }
                return i;
            }, f.byteLength = v, f.prototype._isBuffer = !0, f.prototype.swap16 = function() {
                var t = this.length;
                if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for(var r = 0; r < t; r += 2)b(this, r, r + 1);
                return this;
            }, f.prototype.swap32 = function() {
                var t = this.length;
                if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for(var r = 0; r < t; r += 4)b(this, r, r + 3), b(this, r + 1, r + 2);
                return this;
            }, f.prototype.swap64 = function() {
                var t = this.length;
                if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for(var r = 0; r < t; r += 8)b(this, r, r + 7), b(this, r + 1, r + 6), b(this, r + 2, r + 5), b(this, r + 3, r + 4);
                return this;
            }, f.prototype.toString = function() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? Y(this, 0, t) : E.apply(this, arguments);
            }, f.prototype.equals = function(t) {
                if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === f.compare(this, t);
            }, f.prototype.inspect = function() {
                var t = "", r = exports.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">";
            }, f.prototype.compare = function(t, r, e, n, i) {
                if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length) throw new RangeError("out of range index");
                if (n >= i && r >= e) return 0;
                if (n >= i) return -1;
                if (r >= e) return 1;
                if (this === t) return 0;
                for(var o = (i >>>= 0) - (n >>>= 0), u = (e >>>= 0) - (r >>>= 0), s = Math.min(o, u), h = this.slice(n, i), a = t.slice(r, e), c = 0; c < s; ++c)if (h[c] !== a[c]) {
                    o = h[c], u = a[c];
                    break;
                }
                return o < u ? -1 : u < o ? 1 : 0;
            }, f.prototype.includes = function(t, r, e) {
                return -1 !== this.indexOf(t, r, e);
            }, f.prototype.indexOf = function(t, r, e) {
                return R(this, t, r, e, !0);
            }, f.prototype.lastIndexOf = function(t, r, e) {
                return R(this, t, r, e, !1);
            }, f.prototype.write = function(t, r, e, n) {
                if (void 0 === r) n = "utf8", e = this.length, r = 0;
                else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
                else {
                    if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0);
                }
                var i = this.length - r;
                if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                n || (n = "utf8");
                for(var o = !1;;)switch(n){
                    case "hex":
                        return A(this, t, r, e);
                    case "utf8":
                    case "utf-8":
                        return m(this, t, r, e);
                    case "ascii":
                        return P(this, t, r, e);
                    case "latin1":
                    case "binary":
                        return T(this, t, r, e);
                    case "base64":
                        return B(this, t, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return U(this, t, r, e);
                    default:
                        if (o) throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), o = !0;
                }
            }, f.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            var I = 4096;
            function O(t) {
                var r = t.length;
                if (r <= I) return String.fromCharCode.apply(String, t);
                for(var e = "", n = 0; n < r;)e += String.fromCharCode.apply(String, t.slice(n, n += I));
                return e;
            }
            function L(t, r, e) {
                var n = "";
                e = Math.min(t.length, e);
                for(var i = r; i < e; ++i)n += String.fromCharCode(127 & t[i]);
                return n;
            }
            function D(t, r, e) {
                var n = "";
                e = Math.min(t.length, e);
                for(var i = r; i < e; ++i)n += String.fromCharCode(t[i]);
                return n;
            }
            function x(t, r, e) {
                var n = t.length;
                (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
                for(var i = "", o = r; o < e; ++o)i += Z(t[o]);
                return i;
            }
            function C(t, r, e) {
                for(var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2)i += String.fromCharCode(n[o] + 256 * n[o + 1]);
                return i;
            }
            function M(t, r, e) {
                if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                if (t + r > e) throw new RangeError("Trying to access beyond buffer length");
            }
            function k(t, r, e, n, i, o) {
                if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > i || r < o) throw new RangeError('"value" argument is out of bounds');
                if (e + n > t.length) throw new RangeError("Index out of range");
            }
            function N(t, r, e, n) {
                r < 0 && (r = 65535 + r + 1);
                for(var i = 0, o = Math.min(t.length - e, 2); i < o; ++i)t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i);
            }
            function z(t, r, e, n) {
                r < 0 && (r = 4294967295 + r + 1);
                for(var i = 0, o = Math.min(t.length - e, 4); i < o; ++i)t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255;
            }
            function F(t, r, e, n, i, o) {
                if (e + n > t.length) throw new RangeError("Index out of range");
                if (e < 0) throw new RangeError("Index out of range");
            }
            function j(t, r, n, i, o) {
                return o || F(t, r, n, 4, 3.4028234663852886e38, -340282346638528860000000000000000000000), e.write(t, r, n, i, 23, 4), n + 4;
            }
            function q(t, r, n, i, o) {
                return o || F(t, r, n, 8, 1.7976931348623157e308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), e.write(t, r, n, i, 52, 8), n + 8;
            }
            f.prototype.slice = function(t, r) {
                var e, n = this.length;
                if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t), f.TYPED_ARRAY_SUPPORT) (e = this.subarray(t, r)).__proto__ = f.prototype;
                else {
                    var i = r - t;
                    e = new f(i, void 0);
                    for(var o = 0; o < i; ++o)e[o] = this[o + t];
                }
                return e;
            }, f.prototype.readUIntLE = function(t, r, e) {
                t |= 0, r |= 0, e || M(t, r, this.length);
                for(var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)n += this[t + o] * i;
                return n;
            }, f.prototype.readUIntBE = function(t, r, e) {
                t |= 0, r |= 0, e || M(t, r, this.length);
                for(var n = this[t + --r], i = 1; r > 0 && (i *= 256);)n += this[t + --r] * i;
                return n;
            }, f.prototype.readUInt8 = function(t, r) {
                return r || M(t, 1, this.length), this[t];
            }, f.prototype.readUInt16LE = function(t, r) {
                return r || M(t, 2, this.length), this[t] | this[t + 1] << 8;
            }, f.prototype.readUInt16BE = function(t, r) {
                return r || M(t, 2, this.length), this[t] << 8 | this[t + 1];
            }, f.prototype.readUInt32LE = function(t, r) {
                return r || M(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
            }, f.prototype.readUInt32BE = function(t, r) {
                return r || M(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
            }, f.prototype.readIntLE = function(t, r, e) {
                t |= 0, r |= 0, e || M(t, r, this.length);
                for(var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)n += this[t + o] * i;
                return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n;
            }, f.prototype.readIntBE = function(t, r, e) {
                t |= 0, r |= 0, e || M(t, r, this.length);
                for(var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)o += this[t + --n] * i;
                return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o;
            }, f.prototype.readInt8 = function(t, r) {
                return r || M(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
            }, f.prototype.readInt16LE = function(t, r) {
                r || M(t, 2, this.length);
                var e = this[t] | this[t + 1] << 8;
                return 32768 & e ? 4294901760 | e : e;
            }, f.prototype.readInt16BE = function(t, r) {
                r || M(t, 2, this.length);
                var e = this[t + 1] | this[t] << 8;
                return 32768 & e ? 4294901760 | e : e;
            }, f.prototype.readInt32LE = function(t, r) {
                return r || M(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
            }, f.prototype.readInt32BE = function(t, r) {
                return r || M(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
            }, f.prototype.readFloatLE = function(t, r) {
                return r || M(t, 4, this.length), e.read(this, t, !0, 23, 4);
            }, f.prototype.readFloatBE = function(t, r) {
                return r || M(t, 4, this.length), e.read(this, t, !1, 23, 4);
            }, f.prototype.readDoubleLE = function(t, r) {
                return r || M(t, 8, this.length), e.read(this, t, !0, 52, 8);
            }, f.prototype.readDoubleBE = function(t, r) {
                return r || M(t, 8, this.length), e.read(this, t, !1, 52, 8);
            }, f.prototype.writeUIntLE = function(t, r, e, n) {
                (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                var i = 1, o = 0;
                for(this[r] = 255 & t; ++o < e && (i *= 256);)this[r + o] = t / i & 255;
                return r + e;
            }, f.prototype.writeUIntBE = function(t, r, e, n) {
                (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
                var i = e - 1, o = 1;
                for(this[r + i] = 255 & t; --i >= 0 && (o *= 256);)this[r + i] = t / o & 255;
                return r + e;
            }, f.prototype.writeUInt8 = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1;
            }, f.prototype.writeUInt16LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2;
            }, f.prototype.writeUInt16BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2;
            }, f.prototype.writeUInt32LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : z(this, t, r, !0), r + 4;
            }, f.prototype.writeUInt32BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4;
            }, f.prototype.writeIntLE = function(t, r, e, n) {
                if (t = +t, r |= 0, !n) {
                    var i = Math.pow(2, 8 * e - 1);
                    k(this, t, r, e, i - 1, -i);
                }
                var o = 0, u = 1, f = 0;
                for(this[r] = 255 & t; ++o < e && (u *= 256);)t < 0 && 0 === f && 0 !== this[r + o - 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
                return r + e;
            }, f.prototype.writeIntBE = function(t, r, e, n) {
                if (t = +t, r |= 0, !n) {
                    var i = Math.pow(2, 8 * e - 1);
                    k(this, t, r, e, i - 1, -i);
                }
                var o = e - 1, u = 1, f = 0;
                for(this[r + o] = 255 & t; --o >= 0 && (u *= 256);)t < 0 && 0 === f && 0 !== this[r + o + 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
                return r + e;
            }, f.prototype.writeInt8 = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1;
            }, f.prototype.writeInt16LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2;
            }, f.prototype.writeInt16BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2;
            }, f.prototype.writeInt32LE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : z(this, t, r, !0), r + 4;
            }, f.prototype.writeInt32BE = function(t, r, e) {
                return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4;
            }, f.prototype.writeFloatLE = function(t, r, e) {
                return j(this, t, r, !0, e);
            }, f.prototype.writeFloatBE = function(t, r, e) {
                return j(this, t, r, !1, e);
            }, f.prototype.writeDoubleLE = function(t, r, e) {
                return q(this, t, r, !0, e);
            }, f.prototype.writeDoubleBE = function(t, r, e) {
                return q(this, t, r, !1, e);
            }, f.prototype.copy = function(t, r, e, n) {
                if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (r < 0) throw new RangeError("targetStart out of bounds");
                if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds");
                if (n < 0) throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e);
                var i, o = n - e;
                if (this === t && e < r && r < n) for(i = o - 1; i >= 0; --i)t[i + r] = this[i + e];
                else if (o < 1e3 || !f.TYPED_ARRAY_SUPPORT) for(i = 0; i < o; ++i)t[i + r] = this[i + e];
                else Uint8Array.prototype.set.call(t, this.subarray(e, e + o), r);
                return o;
            }, f.prototype.fill = function(t, r, e, n) {
                if ("string" == typeof t) {
                    if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) {
                        var i = t.charCodeAt(0);
                        i < 256 && (t = i);
                    }
                    if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                    if ("string" == typeof n && !f.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
                } else "number" == typeof t && (t &= 255);
                if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index");
                if (e <= r) return this;
                var o;
                if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t) for(o = r; o < e; ++o)this[o] = t;
                else {
                    var u = f.isBuffer(t) ? t : $(new f(t, n).toString()), s = u.length;
                    for(o = 0; o < e - r; ++o)this[o + r] = u[o % s];
                }
                return this;
            };
            var V = /[^+\/0-9A-Za-z-_]/g;
            function X(t) {
                if ((t = J(t).replace(V, "")).length < 2) return "";
                for(; t.length % 4 != 0;)t += "=";
                return t;
            }
            function J(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
            }
            function Z(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16);
            }
            function $(t, r) {
                var e;
                r = r || 1 / 0;
                for(var n = t.length, i = null, o = [], u = 0; u < n; ++u){
                    if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
                        if (!i) {
                            if (e > 56319) {
                                (r -= 3) > -1 && o.push(239, 191, 189);
                                continue;
                            }
                            if (u + 1 === n) {
                                (r -= 3) > -1 && o.push(239, 191, 189);
                                continue;
                            }
                            i = e;
                            continue;
                        }
                        if (e < 56320) {
                            (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                            continue;
                        }
                        e = 65536 + (i - 55296 << 10 | e - 56320);
                    } else i && (r -= 3) > -1 && o.push(239, 191, 189);
                    if (i = null, e < 128) {
                        if ((r -= 1) < 0) break;
                        o.push(e);
                    } else if (e < 2048) {
                        if ((r -= 2) < 0) break;
                        o.push(e >> 6 | 192, 63 & e | 128);
                    } else if (e < 65536) {
                        if ((r -= 3) < 0) break;
                        o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128);
                    } else {
                        if (!(e < 1114112)) throw new Error("Invalid code point");
                        if ((r -= 4) < 0) break;
                        o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128);
                    }
                }
                return o;
            }
            function G(t) {
                for(var r = [], e = 0; e < t.length; ++e)r.push(255 & t.charCodeAt(e));
                return r;
            }
            function H(t, r) {
                for(var e, n, i, o = [], u = 0; u < t.length && !((r -= 2) < 0); ++u)n = (e = t.charCodeAt(u)) >> 8, i = e % 256, o.push(i), o.push(n);
                return o;
            }
            function K(t) {
                return r.toByteArray(X(t));
            }
            function Q(t, r, e, n) {
                for(var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)r[i + e] = t[i];
                return i;
            }
            function W(t) {
                return t != t;
            }
        },
        {
            "base64-js": "yh9p",
            "ieee754": "JgNJ",
            "isarray": "REa7",
            "buffer": "dskh"
        }
    ],
    "QO4x": [
        function(require1, module1, exports) {
            var Buffer = require1("buffer").Buffer;
            var global = arguments[3];
            var t = require1("buffer").Buffer, e = arguments[3], r = require1("../constants.js").FILE_SYSTEM_NAME, n = require1("../constants.js").FILE_STORE_NAME, o = require1("../constants.js").IDB_RW, u = require1("../constants.js").IDB_RO;
            function c(t, e) {
                this.db = t, this.mode = e;
            }
            function i(t) {
                this.name = t || r, this.db = null;
            }
            c.prototype._getObjectStore = function() {
                if (this.objectStore) return this.objectStore;
                var t = this.db.transaction(n, this.mode);
                return this.objectStore = t.objectStore(n), this.objectStore;
            }, c.prototype.clear = function(t) {
                try {
                    var e = this._getObjectStore().clear();
                    e.onsuccess = function() {
                        t();
                    }, e.onerror = function(e) {
                        e.preventDefault(), t(e.error);
                    };
                } catch (r) {
                    t(r);
                }
            }, c.prototype._get = function(t, e) {
                try {
                    var r = this._getObjectStore().get(t);
                    r.onsuccess = function(t) {
                        var r = t.target.result;
                        e(null, r);
                    }, r.onerror = function(t) {
                        t.preventDefault(), e(t.error);
                    };
                } catch (n) {
                    e(n);
                }
            }, c.prototype.getObject = function(t, e) {
                this._get(t, e);
            }, c.prototype.getBuffer = function(e, r) {
                this._get(e, function(e, n) {
                    if (e) return r(e);
                    r(null, t.from(n));
                });
            }, c.prototype._put = function(t, e, r) {
                try {
                    var n = this._getObjectStore().put(e, t);
                    n.onsuccess = function(t) {
                        var e = t.target.result;
                        r(null, e);
                    }, n.onerror = function(t) {
                        t.preventDefault(), r(t.error);
                    };
                } catch (o) {
                    r(o);
                }
            }, c.prototype.putObject = function(t, e, r) {
                this._put(t, e, r);
            }, c.prototype.putBuffer = function(t, e, r) {
                var n = e.buffer;
                this._put(t, n, r);
            }, c.prototype.delete = function(t, e) {
                try {
                    var r = this._getObjectStore().delete(t);
                    r.onsuccess = function(t) {
                        var r = t.target.result;
                        e(null, r);
                    }, r.onerror = function(t) {
                        t.preventDefault(), e(t.error);
                    };
                } catch (n) {
                    e(n);
                }
            }, i.isSupported = function() {
                return !!(e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB);
            }, i.prototype.open = function(t) {
                var r = this;
                if (r.db) return t();
                try {
                    var o = (e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB).open(r.name);
                    o.onupgradeneeded = function(t) {
                        var e = t.target.result;
                        e.objectStoreNames.contains(n) && e.deleteObjectStore(n), e.createObjectStore(n);
                    }, o.onsuccess = function(e) {
                        r.db = e.target.result, t();
                    }, o.onerror = function(e) {
                        e.preventDefault(), t(e.error);
                    };
                } catch (u) {
                    t(u);
                }
            }, i.prototype.getReadOnlyContext = function() {
                return new c(this.db, u);
            }, i.prototype.getReadWriteContext = function() {
                return new c(this.db, o);
            }, module1.exports = i;
        },
        {
            "../constants.js": "iJA9",
            "buffer": "dskh"
        }
    ],
    "u4Zs": [
        function(require1, module1, exports) {
            var process = require1("process");
            var define;
            var e, t = require1("process");
            !function() {
                var n = {};
                void 0 !== t && t.nextTick ? (n.nextTick = t.nextTick, "undefined" != typeof setImmediate ? n.setImmediate = function(e) {
                    setImmediate(e);
                } : n.setImmediate = n.nextTick) : "function" == typeof setImmediate ? (n.nextTick = function(e) {
                    setImmediate(e);
                }, n.setImmediate = n.nextTick) : (n.nextTick = function(e) {
                    setTimeout(e, 0);
                }, n.setImmediate = n.nextTick), n.eachSeries = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var i = 0;
                    !function o() {
                        t(e[i], function(t) {
                            t ? (n(t), n = function() {}) : (i += 1) >= e.length ? n() : o();
                        });
                    }();
                }, n.forEachSeries = n.eachSeries, void 0 !== e && e.amd ? e([], function() {
                    return n;
                }) : "undefined" != typeof module1 && module1.exports ? module1.exports = n : root.async = n;
            }();
        },
        {
            "process": "pBGv"
        }
    ],
    "OWym": [
        function(require1, module1, exports) {
            var t = require1("../constants.js").FILE_SYSTEM_NAME, e = require1("../../lib/async.js").setImmediate, o = function() {
                var t = {};
                return function(e) {
                    return Object.prototype.hasOwnProperty.call(t, e) || (t[e] = {}), t[e];
                };
            }();
            function n(t, e) {
                this.readOnly = e, this.objectStore = t;
            }
            function r(e) {
                this.name = e || t;
            }
            n.prototype.clear = function(t) {
                if (this.readOnly) e(function() {
                    t("[MemoryContext] Error: write operation on read only context");
                });
                else {
                    var o = this.objectStore;
                    Object.keys(o).forEach(function(t) {
                        delete o[t];
                    }), e(t);
                }
            }, n.prototype.getObject = n.prototype.getBuffer = function(t, o) {
                var n = this;
                e(function() {
                    o(null, n.objectStore[t]);
                });
            }, n.prototype.putObject = n.prototype.putBuffer = function(t, o, n) {
                this.readOnly ? e(function() {
                    n("[MemoryContext] Error: write operation on read only context");
                }) : (this.objectStore[t] = o, e(n));
            }, n.prototype.delete = function(t, o) {
                this.readOnly ? e(function() {
                    o("[MemoryContext] Error: write operation on read only context");
                }) : (delete this.objectStore[t], e(o));
            }, r.isSupported = function() {
                return !0;
            }, r.prototype.open = function(t) {
                this.db = o(this.name), e(t);
            }, r.prototype.getReadOnlyContext = function() {
                return new n(this.db, !0);
            }, r.prototype.getReadWriteContext = function() {
                return new n(this.db, !1);
            }, module1.exports = r;
        },
        {
            "../constants.js": "iJA9",
            "../../lib/async.js": "u4Zs"
        }
    ],
    "AiW7": [
        function(require1, module1, exports) {
            var e = require1("./indexeddb.js"), r = require1("./memory.js");
            module1.exports = {
                IndexedDB: e,
                Default: e,
                Memory: r
            };
        },
        {
            "./indexeddb.js": "QO4x",
            "./memory.js": "OWym"
        }
    ],
    "p8GN": [
        function(require1, module1, exports) {
            var t = {};
            [
                "3:EACCES:permission denied",
                "9:EBADF:bad file descriptor",
                "10:EBUSY:resource busy or locked",
                "18:EINVAL:invalid argument",
                "27:ENOTDIR:not a directory",
                "28:EISDIR:illegal operation on a directory",
                "34:ENOENT:no such file or directory",
                "47:EEXIST:file already exists",
                "50:EPERM:operation not permitted",
                "51:ELOOP:too many symbolic links encountered",
                "53:ENOTEMPTY:directory not empty",
                "55:EIO:i/o error",
                "1000:ENOTMOUNTED:not mounted",
                "1001:EFILESYSTEMERROR:missing super node, use 'FORMAT' flag to format filesystem.",
                "1002:ENOATTR:attribute does not exist"
            ].forEach(function(e) {
                var o = +(e = e.split(":"))[0], r = e[1], i = e[2];
                function s(t, e) {
                    Error.call(this), this.name = r, this.code = r, this.errno = o, this.message = t || i, e && (this.path = e), this.stack = new Error(this.message).stack;
                }
                s.prototype = Object.create(Error.prototype), s.prototype.constructor = s, s.prototype.toString = function() {
                    var t = this.path ? ", '" + this.path + "'" : "";
                    return this.name + ": " + this.message + t;
                }, t[r] = t[o] = s;
            }), module1.exports = t;
        },
        {}
    ],
    "QMiB": [
        function(require1, module1, exports) {
            "use strict";
            var t = require1("../constants.js").ENVIRONMENT;
            module1.exports = function(n) {
                (n = n || {}).TMP = n.TMP || t.TMP, n.PATH = n.PATH || t.PATH, this.get = function(t) {
                    return n[t];
                }, this.set = function(t, s) {
                    n[t] = s;
                };
            };
        },
        {
            "../constants.js": "iJA9"
        }
    ],
    "bQx9": [
        function(require1, module1, exports) {
            module1.exports = function(t, o) {
                for(var a = [], e = 0; e < t.length; e++){
                    var n = o(t[e], e);
                    r(n) ? a.push.apply(a, n) : a.push(n);
                }
                return a;
            };
            var r = Array.isArray || function(r) {
                return "[object Array]" === Object.prototype.toString.call(r);
            };
        },
        {}
    ],
    "D9yG": [
        function(require1, module1, exports) {
            "use strict";
            function e(e, r, i) {
                e instanceof RegExp && (e = n(e, i)), r instanceof RegExp && (r = n(r, i));
                var o = t(e, r, i);
                return o && {
                    start: o[0],
                    end: o[1],
                    pre: i.slice(0, o[0]),
                    body: i.slice(o[0] + e.length, o[1]),
                    post: i.slice(o[1] + r.length)
                };
            }
            function n(e, n) {
                var t = n.match(e);
                return t ? t[0] : null;
            }
            function t(e, n, t) {
                var r, i, o, f, l, s = t.indexOf(e), c = t.indexOf(n, s + 1), p = s;
                if (s >= 0 && c > 0) {
                    for(r = [], o = t.length; p >= 0 && !l;)p == s ? (r.push(p), s = t.indexOf(e, p + 1)) : 1 == r.length ? l = [
                        r.pop(),
                        c
                    ] : ((i = r.pop()) < o && (o = i, f = c), c = t.indexOf(n, p + 1)), p = s < c && s >= 0 ? s : c;
                    r.length && (l = [
                        o,
                        f
                    ]);
                }
                return l;
            }
            module1.exports = e, e.range = t;
        },
        {}
    ],
    "dwXQ": [
        function(require1, module1, exports) {
            var t = require1("concat-map"), r = require1("balanced-match");
            module1.exports = f;
            var n = "\x00SLASH" + Math.random() + "\x00", e = "\x00OPEN" + Math.random() + "\x00", i = "\x00CLOSE" + Math.random() + "\x00", o = "\x00COMMA" + Math.random() + "\x00", a = "\x00PERIOD" + Math.random() + "\x00";
            function s(t) {
                return parseInt(t, 10) == t ? parseInt(t, 10) : t.charCodeAt(0);
            }
            function p(t) {
                return t.split("\\\\").join(n).split("\\{").join(e).split("\\}").join(i).split("\\,").join(o).split("\\.").join(a);
            }
            function u(t) {
                return t.split(n).join("\\").split(e).join("{").split(i).join("}").split(o).join(",").split(a).join(".");
            }
            function l(t) {
                if (!t) return [
                    ""
                ];
                var n = [], e = r("{", "}", t);
                if (!e) return t.split(",");
                var i = e.pre, o = e.body, a = e.post, s = i.split(",");
                s[s.length - 1] += "{" + o + "}";
                var p = l(a);
                return a.length && (s[s.length - 1] += p.shift(), s.push.apply(s, p)), n.push.apply(n, s), n;
            }
            function f(t) {
                return t ? ("{}" === t.substr(0, 2) && (t = "\\{\\}" + t.substr(2)), m(p(t), !0).map(u)) : [];
            }
            function h(t) {
                return t;
            }
            function d(t) {
                return "{" + t + "}";
            }
            function c(t) {
                return /^-?0\d/.test(t);
            }
            function v(t, r) {
                return t <= r;
            }
            function g(t, r) {
                return t >= r;
            }
            function m(n, e) {
                var o = [], a = r("{", "}", n);
                if (!a || /\$$/.test(a.pre)) return [
                    n
                ];
                var p, u = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(a.body), f = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(a.body), h = u || f, b = a.body.indexOf(",") >= 0;
                if (!h && !b) return a.post.match(/,.*\}/) ? m(n = a.pre + "{" + a.body + i + a.post) : [
                    n
                ];
                if (h) p = a.body.split(/\.\./);
                else if (1 === (p = l(a.body)).length && 1 === (p = m(p[0], !1).map(d)).length) return (M = a.post.length ? m(a.post, !1) : [
                    ""
                ]).map(function(t) {
                    return a.pre + p[0] + t;
                });
                var j, y = a.pre, M = a.post.length ? m(a.post, !1) : [
                    ""
                ];
                if (h) {
                    var A = s(p[0]), C = s(p[1]), O = Math.max(p[0].length, p[1].length), S = 3 == p.length ? Math.abs(s(p[2])) : 1, $ = v;
                    C < A && (S *= -1, $ = g);
                    var x = p.some(c);
                    j = [];
                    for(var E = A; $(E, C); E += S){
                        var I;
                        if (f) "\\" === (I = String.fromCharCode(E)) && (I = "");
                        else if (I = String(E), x) {
                            var q = O - I.length;
                            if (q > 0) {
                                var z = new Array(q + 1).join("0");
                                I = E < 0 ? "-" + z + I.slice(1) : z + I;
                            }
                        }
                        j.push(I);
                    }
                } else j = t(p, function(t) {
                    return m(t, !1);
                });
                for(var L = 0; L < j.length; L++)for(var P = 0; P < M.length; P++){
                    var Z = y + j[L] + M[P];
                    (!e || h || Z) && o.push(Z);
                }
                return o;
            }
        },
        {
            "concat-map": "bQx9",
            "balanced-match": "D9yG"
        }
    ],
    "NtKi": [
        function(require1, module1, exports) {
            module1.exports = g, g.Minimatch = l;
            var t = {
                sep: "/"
            };
            try {
                t = require1("path");
            } catch (O) {}
            var e = g.GLOBSTAR = l.GLOBSTAR = {}, n = require1("brace-expansion"), r = {
                "!": {
                    open: "(?:(?!(?:",
                    close: "))[^/]*?)"
                },
                "?": {
                    open: "(?:",
                    close: ")?"
                },
                "+": {
                    open: "(?:",
                    close: ")+"
                },
                "*": {
                    open: "(?:",
                    close: ")*"
                },
                "@": {
                    open: "(?:",
                    close: ")"
                }
            }, i = "[^/]", s = i + "*?", a = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", o = "(?:(?!(?:\\/|^)\\.).)*?", h = c("().*{}+?[]^$\\!");
            function c(t) {
                return t.split("").reduce(function(t, e) {
                    return t[e] = !0, t;
                }, {});
            }
            var u = /\/+/;
            function p(t, e) {
                return e = e || {}, function(n, r, i) {
                    return g(n, t, e);
                };
            }
            function f(t, e) {
                t = t || {}, e = e || {};
                var n = {};
                return Object.keys(e).forEach(function(t) {
                    n[t] = e[t];
                }), Object.keys(t).forEach(function(e) {
                    n[e] = t[e];
                }), n;
            }
            function g(t, e, n) {
                if ("string" != typeof e) throw new TypeError("glob pattern string required");
                return n || (n = {}), !(!n.nocomment && "#" === e.charAt(0)) && ("" === e.trim() ? "" === t : new l(e, n).match(t));
            }
            function l(e, n) {
                if (!(this instanceof l)) return new l(e, n);
                if ("string" != typeof e) throw new TypeError("glob pattern string required");
                n || (n = {}), e = e.trim(), "/" !== t.sep && (e = e.split(t.sep).join("/")), this.options = n, this.set = [], this.pattern = e, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.make();
            }
            function d() {
                if (!this._made) {
                    var t = this.pattern, e = this.options;
                    if (e.nocomment || "#" !== t.charAt(0)) {
                        if (t) {
                            this.parseNegate();
                            var n = this.globSet = this.braceExpand();
                            e.debug && (this.debug = console.error), this.debug(this.pattern, n), n = this.globParts = n.map(function(t) {
                                return t.split(u);
                            }), this.debug(this.pattern, n), n = n.map(function(t, e, n) {
                                return t.map(this.parse, this);
                            }, this), this.debug(this.pattern, n), n = n.filter(function(t) {
                                return -1 === t.indexOf(!1);
                            }), this.debug(this.pattern, n), this.set = n;
                        } else this.empty = !0;
                    } else this.comment = !0;
                }
            }
            function b() {
                var t = this.pattern, e = !1, n = 0;
                if (!this.options.nonegate) {
                    for(var r = 0, i = t.length; r < i && "!" === t.charAt(r); r++)e = !e, n++;
                    n && (this.pattern = t.substr(n)), this.negate = e;
                }
            }
            function m(t, e) {
                if (e || (e = this instanceof l ? this.options : {}), void 0 === (t = void 0 === t ? this.pattern : t)) throw new TypeError("undefined pattern");
                return e.nobrace || !t.match(/\{.*\}/) ? [
                    t
                ] : n(t);
            }
            g.filter = p, g.defaults = function(t) {
                if (!t || !Object.keys(t).length) return g;
                var e = g, n = function(n, r, i) {
                    return e.minimatch(n, r, f(t, i));
                };
                return n.Minimatch = function(n, r) {
                    return new e.Minimatch(n, f(t, r));
                }, n;
            }, l.defaults = function(t) {
                return t && Object.keys(t).length ? g.defaults(t).Minimatch : l;
            }, l.prototype.debug = function() {}, l.prototype.make = d, l.prototype.parseNegate = b, g.braceExpand = function(t, e) {
                return m(t, e);
            }, l.prototype.braceExpand = m, l.prototype.parse = y;
            var v = {};
            function y(t, n) {
                if (t.length > 65536) throw new TypeError("pattern is too long");
                var a = this.options;
                if (!a.noglobstar && "**" === t) return e;
                if ("" === t) return "";
                var o, c = "", u = !!a.nocase, p = !1, f = [], g = [], l = !1, d = -1, b = -1, m = "." === t.charAt(0) ? "" : a.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", y = this;
                function w() {
                    if (o) {
                        switch(o){
                            case "*":
                                c += s, u = !0;
                                break;
                            case "?":
                                c += i, u = !0;
                                break;
                            default:
                                c += "\\" + o;
                        }
                        y.debug("clearStateChar %j %j", o, c), o = !1;
                    }
                }
                for(var x, j = 0, k = t.length; j < k && (x = t.charAt(j)); j++)if (this.debug("%s	%s %s %j", t, j, c, x), p && h[x]) c += "\\" + x, p = !1;
                else switch(x){
                    case "/":
                        return !1;
                    case "\\":
                        w(), p = !0;
                        continue;
                    case "?":
                    case "*":
                    case "+":
                    case "@":
                    case "!":
                        if (this.debug("%s	%s %s %j <-- stateChar", t, j, c, x), l) {
                            this.debug("  in class"), "!" === x && j === b + 1 && (x = "^"), c += x;
                            continue;
                        }
                        y.debug("call clearStateChar %j", o), w(), o = x, a.noext && w();
                        continue;
                    case "(":
                        if (l) {
                            c += "(";
                            continue;
                        }
                        if (!o) {
                            c += "\\(";
                            continue;
                        }
                        f.push({
                            type: o,
                            start: j - 1,
                            reStart: c.length,
                            open: r[o].open,
                            close: r[o].close
                        }), c += "!" === o ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", o, c), o = !1;
                        continue;
                    case ")":
                        if (l || !f.length) {
                            c += "\\)";
                            continue;
                        }
                        w(), u = !0;
                        var A = f.pop();
                        c += A.close, "!" === A.type && g.push(A), A.reEnd = c.length;
                        continue;
                    case "|":
                        if (l || !f.length || p) {
                            c += "\\|", p = !1;
                            continue;
                        }
                        w(), c += "|";
                        continue;
                    case "[":
                        if (w(), l) {
                            c += "\\" + x;
                            continue;
                        }
                        l = !0, b = j, d = c.length, c += x;
                        continue;
                    case "]":
                        if (j === b + 1 || !l) {
                            c += "\\" + x, p = !1;
                            continue;
                        }
                        if (l) {
                            var S = t.substring(b + 1, j);
                            try {
                                RegExp("[" + S + "]");
                            } catch (O) {
                                var $ = this.parse(S, v);
                                c = c.substr(0, d) + "\\[" + $[0] + "\\]", u = u || $[1], l = !1;
                                continue;
                            }
                        }
                        u = !0, l = !1, c += x;
                        continue;
                    default:
                        w(), p ? p = !1 : !h[x] || "^" === x && l || (c += "\\"), c += x;
                }
                for(l && (S = t.substr(b + 1), $ = this.parse(S, v), c = c.substr(0, d) + "\\[" + $[0], u = u || $[1]), A = f.pop(); A; A = f.pop()){
                    var R = c.slice(A.reStart + A.open.length);
                    this.debug("setting tail", c, A), R = R.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(t, e, n) {
                        return n || (n = "\\"), e + e + n + "|";
                    }), this.debug("tail=%j\n   %s", R, R, A, c);
                    var T = "*" === A.type ? s : "?" === A.type ? i : "\\" + A.type;
                    u = !0, c = c.slice(0, A.reStart) + T + "\\(" + R;
                }
                w(), p && (c += "\\\\");
                var C = !1;
                switch(c.charAt(0)){
                    case ".":
                    case "[":
                    case "(":
                        C = !0;
                }
                for(var L = g.length - 1; L > -1; L--){
                    var q = g[L], B = c.slice(0, q.reStart), M = c.slice(q.reStart, q.reEnd - 8), N = c.slice(q.reEnd - 8, q.reEnd), _ = c.slice(q.reEnd);
                    N += _;
                    var G = B.split("(").length - 1, P = _;
                    for(j = 0; j < G; j++)P = P.replace(/\)[+*?]?/, "");
                    var z = "";
                    "" === (_ = P) && n !== v && (z = "$"), c = B + M + _ + z + N;
                }
                if ("" !== c && u && (c = "(?=.)" + c), C && (c = m + c), n === v) return [
                    c,
                    u
                ];
                if (!u) return E(t);
                var D = a.nocase ? "i" : "";
                try {
                    var F = new RegExp("^" + c + "$", D);
                } catch (O) {
                    return new RegExp("$.");
                }
                return F._glob = t, F._src = c, F;
            }
            function w() {
                if (this.regexp || !1 === this.regexp) return this.regexp;
                var t = this.set;
                if (!t.length) return this.regexp = !1, this.regexp;
                var n = this.options, r = n.noglobstar ? s : n.dot ? a : o, i = n.nocase ? "i" : "", h = t.map(function(t) {
                    return t.map(function(t) {
                        return t === e ? r : "string" == typeof t ? j(t) : t._src;
                    }).join("\\/");
                }).join("|");
                h = "^(?:" + h + ")$", this.negate && (h = "^(?!" + h + ").*$");
                try {
                    this.regexp = new RegExp(h, i);
                } catch (c) {
                    this.regexp = !1;
                }
                return this.regexp;
            }
            function x(e, n) {
                if (this.debug("match", e, this.pattern), this.comment) return !1;
                if (this.empty) return "" === e;
                if ("/" === e && n) return !0;
                var r = this.options;
                "/" !== t.sep && (e = e.split(t.sep).join("/")), e = e.split(u), this.debug(this.pattern, "split", e);
                var i, s, a = this.set;
                for(this.debug(this.pattern, "set", a), s = e.length - 1; s >= 0 && !(i = e[s]); s--);
                for(s = 0; s < a.length; s++){
                    var o = a[s], h = e;
                    if (r.matchBase && 1 === o.length && (h = [
                        i
                    ]), this.matchOne(h, o, n)) return !!r.flipNegate || !this.negate;
                }
                return !r.flipNegate && this.negate;
            }
            function E(t) {
                return t.replace(/\\(.)/g, "$1");
            }
            function j(t) {
                return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            }
            g.makeRe = function(t, e) {
                return new l(t, e || {}).makeRe();
            }, l.prototype.makeRe = w, g.match = function(t, e, n) {
                var r = new l(e, n = n || {});
                return t = t.filter(function(t) {
                    return r.match(t);
                }), r.options.nonull && !t.length && t.push(e), t;
            }, l.prototype.match = x, l.prototype.matchOne = function(t, n, r) {
                var i = this.options;
                this.debug("matchOne", {
                    this: this,
                    file: t,
                    pattern: n
                }), this.debug("matchOne", t.length, n.length);
                for(var s = 0, a = 0, o = t.length, h = n.length; s < o && a < h; s++, a++){
                    this.debug("matchOne loop");
                    var c, u = n[a], p = t[s];
                    if (this.debug(n, u, p), !1 === u) return !1;
                    if (u === e) {
                        this.debug("GLOBSTAR", [
                            n,
                            u,
                            p
                        ]);
                        var f = s, g = a + 1;
                        if (g === h) {
                            for(this.debug("** at the end"); s < o; s++)if ("." === t[s] || ".." === t[s] || !i.dot && "." === t[s].charAt(0)) return !1;
                            return !0;
                        }
                        for(; f < o;){
                            var l = t[f];
                            if (this.debug("\nglobstar while", t, f, n, g, l), this.matchOne(t.slice(f), n.slice(g), r)) return this.debug("globstar found match!", f, o, l), !0;
                            if ("." === l || ".." === l || !i.dot && "." === l.charAt(0)) {
                                this.debug("dot detected!", t, f, n, g);
                                break;
                            }
                            this.debug("globstar swallow a segment, and continue"), f++;
                        }
                        return !(!r || (this.debug("\n>>> no match, partial?", t, f, n, g), f !== o));
                    }
                    if ("string" == typeof u ? (c = i.nocase ? p.toLowerCase() === u.toLowerCase() : p === u, this.debug("string match", u, p, c)) : (c = p.match(u), this.debug("pattern match", u, p, c)), !c) return !1;
                }
                if (s === o && a === h) return !0;
                if (s === o) return r;
                if (a === h) return s === o - 1 && "" === t[s];
                throw new Error("wtf?");
            };
        },
        {
            "path": "UUq2",
            "brace-expansion": "dwXQ"
        }
    ],
    "D1Ra": [
        function(require1, module1, exports) {
            var n = require1("es6-promisify"), t = n.promisify, e = require1("../path.js"), i = require1("../errors.js"), r = require1("./environment.js"), o = require1("../../lib/async.js"), u = require1("minimatch");
            function c(n, o) {
                var u = this, c = new r((o = o || {}).env), f = "/";
                Object.defineProperty(this, "fs", {
                    get: function() {
                        return n;
                    },
                    enumerable: !0
                }), Object.defineProperty(this, "env", {
                    get: function() {
                        return c;
                    },
                    enumerable: !0
                }), this.cd = function(t, r) {
                    t = e.resolve(f, t), n.stat(t, function(n, e) {
                        n ? r(new i.ENOTDIR(null, t)) : "DIRECTORY" === e.type ? (f = t, r()) : r(new i.ENOTDIR(null, t));
                    });
                }, this.pwd = function() {
                    return f;
                }, this.promises = {}, [
                    "cd",
                    "exec",
                    "touch",
                    "cat",
                    "ls",
                    "rm",
                    "tempDir",
                    "mkdirp",
                    "find"
                ].forEach(function(n) {
                    u.promises[n] = t(u[n].bind(u));
                });
            }
            c.prototype.exec = function(n, t, i) {
                var r = this.fs;
                "function" == typeof t && (i = t, t = []), t = t || [], i = i || function() {}, n = e.resolve(this.pwd(), n), r.readFile(n, "utf8", function(n, e) {
                    if (n) i(n);
                    else try {
                        new Function("fs", "args", "callback", e)(r, t, i);
                    } catch (o) {
                        i(o);
                    }
                });
            }, c.prototype.touch = function(n, t, i) {
                var r = this.fs;
                "function" == typeof t && (i = t, t = {}), t = t || {}, i = i || function() {}, n = e.resolve(this.pwd(), n), r.stat(n, function(e) {
                    e ? !0 === t.updateOnly ? i() : function(n) {
                        r.writeFile(n, "", i);
                    }(n) : function(n) {
                        var e = Date.now(), o = t.date || e, u = t.date || e;
                        r.utimes(n, o, u, i);
                    }(n);
                });
            }, c.prototype.cat = function(n, t) {
                var r = this, u = r.fs, c = "";
                t = t || function() {}, n ? (n = "string" == typeof n ? [
                    n
                ] : n, o.eachSeries(n, function(n, t) {
                    var i = e.resolve(r.pwd(), n);
                    u.readFile(i, "utf8", function(n, e) {
                        n ? t(n) : (c += e + "\n", t());
                    });
                }, function(n) {
                    n ? t(n) : t(null, c.replace(/\n$/, ""));
                })) : t(new i.EINVAL("Missing files argument"));
            }, c.prototype.ls = function(n, t, r) {
                var u = this, c = u.fs;
                "function" == typeof t && (r = t, t = {}), t = t || {}, r = r || function() {}, n ? function n(i, r) {
                    var f = e.resolve(u.pwd(), i), s = [];
                    c.readdir(f, function(i, u) {
                        i ? r(i) : o.eachSeries(u, function(i, r) {
                            i = e.join(f, i), c.stat(i, function(i, o) {
                                if (i) r(i);
                                else {
                                    var u = o;
                                    t.recursive && "DIRECTORY" === o.type ? n(e.join(f, u.name), function(n, t) {
                                        n ? r(n) : (u.contents = t, s.push(u), r());
                                    }) : (s.push(u), r());
                                }
                            });
                        }, function(n) {
                            r(n, s);
                        });
                    });
                }(n, r) : r(new i.EINVAL("Missing dir argument"));
            }, c.prototype.rm = function(n, t, r) {
                var u = this, c = u.fs;
                "function" == typeof t && (r = t, t = {}), t = t || {}, r = r || function() {}, n ? function n(r, f) {
                    r = e.resolve(u.pwd(), r), c.stat(r, function(u, s) {
                        u ? f(u) : "FILE" !== s.type ? c.readdir(r, function(u, s) {
                            u ? f(u) : 0 !== s.length ? t.recursive ? (s = s.map(function(n) {
                                return e.join(r, n);
                            }), o.eachSeries(s, n, function(n) {
                                n ? f(n) : c.rmdir(r, f);
                            })) : f(new i.ENOTEMPTY(null, r)) : c.rmdir(r, f);
                        }) : c.unlink(r, f);
                    });
                }(n, r) : r(new i.EINVAL("Missing path argument"));
            }, c.prototype.tempDir = function(n) {
                var t = this.fs, e = this.env.get("TMP");
                n = n || function() {}, t.mkdir(e, function() {
                    n(null, e);
                });
            }, c.prototype.mkdirp = function(n, t) {
                var r = this.fs;
                t = t || function() {}, n ? "/" !== (n = e.resolve(this.pwd(), n)) ? function n(t, o) {
                    r.stat(t, function(u, c) {
                        if (c) {
                            if (c.isDirectory()) return void o();
                            if (c.isFile()) return void o(new i.ENOTDIR(null, t));
                        } else {
                            if (u && "ENOENT" !== u.code) return void o(u);
                            var f = e.dirname(t);
                            "/" === f ? r.mkdir(t, function(n) {
                                n && "EEXIST" !== n.code ? o(n) : o();
                            }) : n(f, function(n) {
                                if (n) return o(n);
                                r.mkdir(t, function(n) {
                                    n && "EEXIST" !== n.code ? o(n) : o();
                                });
                            });
                        }
                    });
                }(n, t) : t() : t(new i.EINVAL("Missing path argument"));
            }, c.prototype.find = function(n, t, r) {
                var c = this, f = c.fs;
                "function" == typeof t && (r = t, t = {}), r = r || function() {};
                var s = (t = t || {}).exec || function(n, t) {
                    t();
                }, a = [];
                function p(n, i) {
                    var r = e.removeTrailing(n);
                    !t.regex || t.regex.test(r) ? t.name && !u(e.basename(r), t.name) || t.path && !u(e.dirname(r), t.path) ? i() : function(n, t) {
                        s(n, function(e) {
                            e ? t(e) : (a.push(n), t());
                        });
                    }(n, i) : i();
                }
                function d(n, t) {
                    n = e.resolve(c.pwd(), n), f.readdir(n, function(i, r) {
                        i ? "ENOTDIR" === i.code ? p(n, t) : t(i) : p(e.addTrailing(n), function(i) {
                            i ? t(i) : (r = r.map(function(t) {
                                return e.join(n, t);
                            }), o.eachSeries(r, d, function(n) {
                                t(n, a);
                            }));
                        });
                    });
                }
                n ? f.stat(n, function(t, e) {
                    t ? r(t) : e.isDirectory() ? d(n, r) : r(new i.ENOTDIR(null, n));
                }) : r(new i.EINVAL("Missing path argument"));
            }, module1.exports = c;
        },
        {
            "es6-promisify": "b1ZG",
            "../path.js": "UzoP",
            "../errors.js": "p8GN",
            "./environment.js": "QMiB",
            "../../lib/async.js": "u4Zs",
            "minimatch": "NtKi"
        }
    ],
    "J4Qg": [
        function(require1, module1, exports) {
            function t(t, r) {
                for(var o = r.length - 1; o >= 0; o--)r[o] === t && r.splice(o, 1);
                return r;
            }
            var r = function() {};
            r.createInterface = function(r) {
                var o = {
                    on: function(t, o) {
                        void 0 === this[r] && (this[r] = {}), this[r].hasOwnProperty(t) || (this[r][t] = []), this[r][t].push(o);
                    },
                    off: function(o, e) {
                        void 0 !== this[r] && this[r].hasOwnProperty(o) && t(e, this[r][o]);
                    },
                    trigger: function(t) {
                        if (void 0 !== this[r] && this[r].hasOwnProperty(t)) for(var o = Array.prototype.slice.call(arguments, 1), e = 0; e < this[r][t].length; e++)this[r][t][e].apply(this[r][t][e], o);
                    },
                    removeAllListeners: function(t) {
                        if (void 0 !== this[r]) {
                            var o = this;
                            o[r][t].forEach(function(r) {
                                o.off(t, r);
                            });
                        }
                    }
                };
                return o;
            };
            var o = r.createInterface("_handlers");
            r.prototype._on = o.on, r.prototype._off = o.off, r.prototype._trigger = o.trigger;
            var e = r.createInterface("handlers");
            r.prototype.on = function() {
                e.on.apply(this, arguments), Array.prototype.unshift.call(arguments, "on"), this._trigger.apply(this, arguments);
            }, r.prototype.off = e.off, r.prototype.trigger = e.trigger, r.prototype.removeAllListeners = e.removeAllListeners, module1.exports = r;
        },
        {}
    ],
    "zBMa": [
        function(require1, module1, exports) {
            function x(x) {
                return x.replace(/[xy]/g, function(x) {
                    var n = 16 * Math.random() | 0;
                    return ("x" === x ? n : 3 & n | 8).toString(16);
                });
            }
            function n() {
                return x("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx").toUpperCase();
            }
            function r(n) {
                return x("x".repeat(n = n || 6));
            }
            function t() {}
            module1.exports = {
                guid: n,
                nop: t,
                randomChars: r
            };
        },
        {}
    ],
    "u7Jv": [
        function(require1, module1, exports) {
            var global = arguments[3];
            var t = arguments[3];
            function e(t) {
                return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t;
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                })(t);
            }
            var n = require1("./eventemitter.js"), o = require1("../src/shared.js").guid;
            function r(t, e) {
                var n = 0;
                return function() {
                    var o = Date.now();
                    o - n > t && (n = o, e.apply(this, arguments));
                };
            }
            function i(t, n) {
                if (void 0 !== t && t || (t = {}), "object" === e(n)) for(var o in n)n.hasOwnProperty(o) && (t[o] = n[o]);
                return t;
            }
            var a = function(t) {
                return void 0 === t || void 0 === t.localStorage ? {
                    getItem: function() {},
                    setItem: function() {},
                    removeItem: function() {}
                } : t.localStorage;
            }(t);
            function s() {
                var e = this, n = Date.now();
                this.origin = o(), this.lastMessage = n, this.receivedIDs = {}, this.previousValues = {};
                var r = function() {
                    e._onStorageEvent.apply(e, arguments);
                };
                "undefined" != typeof document && (document.attachEvent ? document.attachEvent("onstorage", r) : t.addEventListener("storage", r, !1));
            }
            s.prototype._transaction = function(t) {
                var e = 1e3, n = 20, o = this, r = !1, i = !1, s = null;
                function c() {
                    if (!r) {
                        var u = Date.now(), f = 0 | a.getItem(p);
                        if (f && u - f < e) return i || (o._on("storage", c), i = !0), void (s = setTimeout(c, n));
                        r = !0, a.setItem(p, u), t(), function() {
                            i && o._off("storage", c);
                            s && clearTimeout(s);
                            a.removeItem(p);
                        }();
                    }
                }
                c();
            }, s.prototype._cleanup_emit = r(100, function() {
                this._transaction(function() {
                    var t, e = Date.now() - f, n = 0;
                    try {
                        t = JSON.parse(a.getItem(c) || "[]");
                    } catch (r) {
                        t = [];
                    }
                    for(var o = t.length - 1; o >= 0; o--)t[o].timestamp < e && (t.splice(o, 1), n++);
                    n > 0 && a.setItem(c, JSON.stringify(t));
                });
            }), s.prototype._cleanup_once = r(100, function() {
                var t = this;
                t._transaction(function() {
                    Date.now();
                    var e, n, o = 0;
                    try {
                        n = JSON.parse(a.getItem(u) || "{}");
                    } catch (r) {
                        n = {};
                    }
                    for(e in n)t._once_expired(e, n) && (delete n[e], o++);
                    o > 0 && a.setItem(u, JSON.stringify(n));
                });
            }), s.prototype._once_expired = function(t, n) {
                if (!n) return !0;
                if (!n.hasOwnProperty(t)) return !0;
                if ("object" !== e(n[t])) return !0;
                var o = n[t].ttl || m, r = Date.now();
                return n[t].timestamp < r - o;
            }, s.prototype._localStorageChanged = function(t, e) {
                if (t && t.key) return t.key === e;
                var n = a.getItem(e);
                return n !== this.previousValues[e] && (this.previousValues[e] = n, !0);
            }, s.prototype._onStorageEvent = function(e) {
                e = e || t.event;
                var n = this;
                this._localStorageChanged(e, c) && this._transaction(function() {
                    var t, e = Date.now(), o = a.getItem(c);
                    try {
                        t = JSON.parse(o || "[]");
                    } catch (i) {
                        t = [];
                    }
                    for(var r = 0; r < t.length; r++)if (t[r].origin !== n.origin && !(t[r].timestamp < n.lastMessage)) {
                        if (t[r].id) {
                            if (n.receivedIDs.hasOwnProperty(t[r].id)) continue;
                            n.receivedIDs[t[r].id] = !0;
                        }
                        n.trigger(t[r].name, t[r].payload);
                    }
                    n.lastMessage = e;
                }), this._trigger("storage", e);
            }, s.prototype._emit = function(t, e, n) {
                if ((n = "string" == typeof n || "number" == typeof n ? String(n) : null) && n.length) {
                    if (this.receivedIDs.hasOwnProperty(n)) return;
                    this.receivedIDs[n] = !0;
                }
                var o = {
                    id: n,
                    name: t,
                    origin: this.origin,
                    timestamp: Date.now(),
                    payload: e
                }, r = this;
                this._transaction(function() {
                    var n = a.getItem(c) || "[]", i = "[]" === n ? "" : ",";
                    n = [
                        n.substring(0, n.length - 1),
                        i,
                        JSON.stringify(o),
                        "]"
                    ].join(""), a.setItem(c, n), r.trigger(t, e), setTimeout(function() {
                        r._cleanup_emit();
                    }, 50);
                });
            }, s.prototype.emit = function(t, e) {
                this._emit.apply(this, arguments), this._trigger("emit", t, e);
            }, s.prototype.once = function(t, e, n) {
                if (s.supported) {
                    var o = this;
                    this._transaction(function() {
                        var r;
                        try {
                            r = JSON.parse(a.getItem(u) || "{}");
                        } catch (i) {
                            r = {};
                        }
                        o._once_expired(t, r) && (r[t] = {}, r[t].timestamp = Date.now(), "number" == typeof n && (r[t].ttl = 1e3 * n), a.setItem(u, JSON.stringify(r)), e(), setTimeout(function() {
                            o._cleanup_once();
                        }, 50));
                    });
                }
            }, i(s.prototype, n.prototype), s.supported = void 0 !== a;
            var c = "intercom", u = "intercom_once", p = "intercom_lock", f = 5e4, m = 36e5;
            s.destroy = function() {
                a.removeItem(p), a.removeItem(c), a.removeItem(u);
            }, s.getInstance = function() {
                var t;
                return function() {
                    return t || (t = new s), t;
                };
            }(), module1.exports = s;
        },
        {
            "./eventemitter.js": "J4Qg",
            "../src/shared.js": "zBMa"
        }
    ],
    "VLEe": [
        function(require1, module1, exports) {
            var e = require1("../lib/eventemitter.js"), t = require1("./path.js"), n = require1("../lib/intercom.js");
            function r() {
                e.call(this);
                var r, i, o = this, s = !1;
                function c(e) {
                    (i === e || s && 0 === e.indexOf(r)) && o.trigger("change", "change", e);
                }
                o.start = function(e, o, a) {
                    if (!i) {
                        if (t.isNull(e)) throw new Error("Path must be a string without null bytes.");
                        i = t.normalize(e), (s = !0 === a) && (r = "/" === i ? "/" : i + "/"), n.getInstance().on("change", c);
                    }
                }, o.close = function() {
                    n.getInstance().off("change", c), o.removeAllListeners("change");
                };
            }
            r.prototype = new e, r.prototype.constructor = r, module1.exports = r;
        },
        {
            "../lib/eventemitter.js": "J4Qg",
            "./path.js": "UzoP",
            "../lib/intercom.js": "u7Jv"
        }
    ],
    "ZECt": [
        function(require1, module1, exports) {
            var t = require1("./constants.js").NODE_TYPE_FILE;
            module1.exports = function(s, e) {
                this.id = s, this.type = e || t;
            };
        },
        {
            "./constants.js": "iJA9"
        }
    ],
    "osLK": [
        function(require1, module1, exports) {
            var r = require1("./constants"), e = r.FIRST_DESCRIPTOR, n = {}, t = function() {
                for(var r = e; o(r);)r++;
                return r;
            }, o = function(r) {
                return n[r];
            }, i = function(r) {
                var e = t();
                return n[e] = r, e;
            }, u = function(r) {
                return delete n[r];
            };
            module1.exports = {
                allocDescriptor: i,
                releaseDescriptor: u,
                getOpenFileDescription: o
            };
        },
        {
            "./constants": "iJA9"
        }
    ],
    "KKNo": [
        function(require1, module1, exports) {
            function t(t, i) {
                if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function");
            }
            function i(t, i) {
                for(var s = 0; s < i.length; s++){
                    var e = i[s];
                    e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(t, e.key, e);
                }
            }
            function s(t, s, e) {
                return s && i(t.prototype, s), e && i(t, e), t;
            }
            var e = require1("./constants"), n = e.NODE_TYPE_FILE, r = e.NODE_TYPE_DIRECTORY, a = e.NODE_TYPE_SYMBOLIC_LINK, o = e.DEFAULT_FILE_PERMISSIONS, u = e.DEFAULT_DIR_PERMISSIONS, h = require1("./constants").fsConstants, c = h.S_IFREG, f = h.S_IFDIR, m = h.S_IFLNK;
            function d(t, i, s) {
                if (t[i]) return s();
                t.guid(function(e, n) {
                    if (e) return s(e);
                    t[i] = n, s();
                });
            }
            function l(t, i) {
                switch(t){
                    case r:
                        return (i || u) | f;
                    case a:
                        return (i || o) | m;
                    case n:
                    default:
                        return (i || o) | c;
                }
            }
            var p = function() {
                function i(s) {
                    t(this, i);
                    var e = Date.now();
                    this.id = s.id, this.data = s.data, this.size = s.size || 0, this.atime = s.atime || e, this.ctime = s.ctime || e, this.mtime = s.mtime || e, this.flags = s.flags || [], this.xattrs = s.xattrs || {}, this.nlinks = s.nlinks || 0, "string" == typeof s.type ? this.type = s.type : "string" == typeof s.mode ? this.type = s.mode : this.type = n, this.permissions = s.permissions || l(this.type), this.uid = s.uid || 0, this.gid = s.gid || 0;
                }
                return s(i, [
                    {
                        key: "toJSON",
                        value: function() {
                            return {
                                id: this.id,
                                data: this.data,
                                size: this.size,
                                atime: this.atime,
                                ctime: this.ctime,
                                mtime: this.ctime,
                                flags: this.flags,
                                xattrs: this.xattrs,
                                nlinks: this.nlinks,
                                mode: this.type,
                                permissions: this.permissions,
                                uid: this.uid,
                                gid: this.gid
                            };
                        }
                    },
                    {
                        key: "mode",
                        get: function() {
                            return l(this.type, this.permissions);
                        },
                        set: function(t) {
                            this.permissions = t;
                        }
                    }
                ]), i;
            }();
            module1.exports.create = function(t, i) {
                d(t, "id", function(s) {
                    if (s) return i(s);
                    d(t, "data", function(s) {
                        if (s) return i(s);
                        i(null, new p(t));
                    });
                });
            };
        },
        {
            "./constants": "iJA9"
        }
    ],
    "XWaV": [
        function(require1, module1, exports) {
            var e = require1("./errors.js"), t = require1("./node");
            function i(e, t, i, r) {
                this.path = e, this.id = t, this.flags = i, this.position = r;
            }
            i.prototype.getNode = function(i, r) {
                var o = this.id, n = this.path;
                i.getObject(o, function(i, o) {
                    return i ? r(i) : o ? void t.create(o, r) : r(new e.EBADF("file descriptor refers to unknown node", n));
                });
            }, module1.exports = i;
        },
        {
            "./errors.js": "p8GN",
            "./node": "KKNo"
        }
    ],
    "JEp0": [
        function(require1, module1, exports) {
            var t = require1("./constants.js");
            function e(e) {
                var i = Date.now();
                this.id = t.SUPER_NODE_ID, this.type = t.NODE_TYPE_META, this.atime = e.atime || i, this.ctime = e.ctime || i, this.mtime = e.mtime || i, this.rnode = e.rnode;
            }
            e.create = function(t, i) {
                t.guid(function(n, o) {
                    n ? i(n) : (t.rnode = t.rnode || o, i(null, new e(t)));
                });
            }, module1.exports = e;
        },
        {
            "./constants.js": "iJA9"
        }
    ],
    "dsCT": [
        function(require1, module1, exports) {
            "use strict";
            var t = require1("./constants.js"), i = require1("./path.js");
            function e(t) {
                return new Date(Number(t));
            }
            function s(t, s, o) {
                this.dev = o, this.node = s.id, this.type = s.type, this.size = s.size, this.nlinks = s.nlinks, this.atime = e(s.atime), this.mtime = e(s.mtime), this.ctime = e(s.ctime), this.atimeMs = s.atime, this.mtimeMs = s.mtime, this.ctimeMs = s.ctime, this.version = s.version, this.mode = s.mode, this.uid = s.uid, this.gid = s.gid, this.name = i.basename(t);
            }
            s.prototype.isFile = function() {
                return this.type === t.NODE_TYPE_FILE;
            }, s.prototype.isDirectory = function() {
                return this.type === t.NODE_TYPE_DIRECTORY;
            }, s.prototype.isSymbolicLink = function() {
                return this.type === t.NODE_TYPE_SYMBOLIC_LINK;
            }, s.prototype.isSocket = s.prototype.isFIFO = s.prototype.isCharacterDevice = s.prototype.isBlockDevice = function() {
                return !1;
            }, module1.exports = s;
        },
        {
            "./constants.js": "iJA9",
            "./path.js": "UzoP"
        }
    ],
    "q4Wu": [
        function(require1, module1, exports) {
            "use strict";
            var t = require1("./stats.js");
            function o(r, s, e) {
                this.constructor = o, t.call(this, r, s, e);
            }
            o.prototype = t.prototype, module1.exports = o;
        },
        {
            "./stats.js": "dsCT"
        }
    ],
    "bsBG": [
        function(require1, module1, exports) {
            var Buffer = require1("buffer").Buffer;
            var e = require1("buffer").Buffer;
            function n(e) {
                return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e;
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                })(e);
            }
            var t = require1("../path.js"), i = t.normalize, o = t.dirname, r = t.basename, u = t.isAbsolute, a = require1("../shared.js"), c = require1("../../lib/async.js"), f = require1("../constants.js"), l = f.NODE_TYPE_FILE, s = f.NODE_TYPE_DIRECTORY, p = f.NODE_TYPE_SYMBOLIC_LINK, d = f.NODE_TYPE_META, m = f.FULL_READ_WRITE_EXEC_PERMISSIONS, E = f.ROOT_DIRECTORY_NAME, g = f.SUPER_NODE_ID, w = f.SYMLOOP_MAX, O = f.O_READ, b = f.O_WRITE, y = f.O_CREATE, v = f.O_EXCLUSIVE, N = f.O_APPEND, h = f.O_FLAGS, I = f.XATTR_CREATE, j = f.XATTR_REPLACE, A = f.FS_NOMTIME, D = f.FS_NOCTIME, T = require1("../errors.js"), L = require1("../directory-entry.js"), R = require1("../open-files.js"), _ = require1("../open-file-description.js"), F = require1("../super-node.js"), S = require1("../node.js"), V = require1("../dirent.js"), B = require1("../stats.js");
            function P(e, n, t, i, o) {
                var r = e.flags;
                r.includes(D) && delete i.ctime, r.includes(A) && delete i.mtime;
                var u = !1;
                function a(t) {
                    e.changes.push({
                        event: "change",
                        path: n
                    }), o(t);
                }
                i.ctime && (t.ctime = i.ctime, t.atime = i.ctime, u = !0), i.atime && (t.atime = i.atime, u = !0), i.mtime && (t.mtime = i.mtime, u = !0), u ? e.putObject(t.id, t, a) : a();
            }
            function x(e, n, t, u) {
                if (t !== s && t !== l) return u(new T.EINVAL("type must be a directory or file", n));
                n = i(n);
                var a, c, f, p = r(n), d = o(n);
                function m(t, i) {
                    !t && i ? u(new T.EEXIST("path name already exists", n)) : !t || t instanceof T.ENOENT ? e.getObject(a.data, E) : u(t);
                }
                function E(n, i) {
                    n ? u(n) : (c = i, S.create({
                        guid: e.guid,
                        type: t
                    }, function(n, t) {
                        n ? u(n) : ((f = t).nlinks += 1, e.putObject(f.id, f, w));
                    }));
                }
                function g(n) {
                    if (n) u(n);
                    else {
                        var t = Date.now();
                        P(e, d, f, {
                            mtime: t,
                            ctime: t
                        }, u);
                    }
                }
                function w(n) {
                    n ? u(n) : (c[p] = new L(f.id, t), e.putObject(a.data, c, g));
                }
                k(e, d, function(t, i) {
                    t ? u(t) : i.type !== s ? u(new T.ENOTDIR("a component of the path prefix is not a directory", n)) : (a = i, k(e, n, m));
                });
            }
            function k(e, n, t) {
                if (!(n = i(n))) return t(new T.ENOENT("path is an empty string"));
                var u = r(n), a = o(n), c = 0;
                function f(n, i) {
                    if (n) return t(n);
                    var o = new F(i);
                    o && o.type === d && o.rnode ? e.getObject(o.rnode, l) : t(new T.EFILESYSTEMERROR);
                }
                function l(e, n) {
                    e ? t(e) : n ? S.create(n, t) : t(new T.ENOENT);
                }
                function m(i, o) {
                    i ? t(i) : o.type === s && o.data ? e.getObject(o.data, O) : t(new T.ENOTDIR("a component of the path prefix is not a directory", n));
                }
                function O(i, o) {
                    if (i) t(i);
                    else if (Object.prototype.hasOwnProperty.call(o, u)) {
                        var r = o[u].id;
                        e.getObject(r, b);
                    } else t(new T.ENOENT(null, n));
                }
                function b(e, n) {
                    if (e) return t(e);
                    S.create(n, y);
                }
                function y(l, s) {
                    var d;
                    l ? t(l) : s.type === p ? ++c > w ? t(new T.ELOOP(null, n)) : (d = s.data, d = i(d), a = o(d), u = r(d), E === u ? e.getObject(g, f) : k(e, a, m)) : t(null, s);
                }
                E === u ? e.getObject(g, f) : k(e, a, m);
            }
            function C(e, n, t, i, o, r, u) {
                var a = t.xattrs;
                r === I && Object.prototype.hasOwnProperty.call(a, i) ? u(new T.EEXIST("attribute already exists", n)) : r !== j || Object.prototype.hasOwnProperty.call(a, i) ? (a[i] = o, e.putObject(t.id, t, function(i) {
                    i ? u(i) : P(e, n, t, {
                        ctime: Date.now()
                    }, u);
                })) : u(new T.ENOATTR(null, n));
            }
            function X(e, n) {
                var t, i, o;
                function r(o) {
                    o ? n(o) : S.create({
                        guid: e.guid,
                        id: t.rnode,
                        type: s
                    }, function(t, o) {
                        t ? n(t) : ((i = o).nlinks += 1, e.putObject(i.id, i, u));
                    });
                }
                function u(t) {
                    t ? n(t) : (o = {}, e.putObject(i.data, o, n));
                }
                e.getObject(g, function(i, o) {
                    !i && o ? n() : !i || i instanceof T.ENOENT ? F.create({
                        guid: e.guid
                    }, function(i, o) {
                        i ? n(i) : (t = o, e.putObject(t.id, t, r));
                    }) : n(i);
                });
            }
            function q(e, n, t) {
                n = i(n);
                var u, a, c, f, l = r(n), p = o(n);
                function d(n, i) {
                    n ? t(n) : (c = i, e.getObject(c.data, m));
                }
                function m(n, i) {
                    n ? t(n) : (f = i, S.create({
                        guid: e.guid,
                        type: s
                    }, function(n, i) {
                        n ? t(n) : ((u = i).nlinks += 1, e.putObject(u.id, u, E));
                    }));
                }
                function E(n) {
                    n ? t(n) : (a = {}, e.putObject(u.data, a, w));
                }
                function g(n) {
                    if (n) t(n);
                    else {
                        var i = Date.now();
                        P(e, p, c, {
                            mtime: i,
                            ctime: i
                        }, t);
                    }
                }
                function w(n) {
                    n ? t(n) : (f[l] = new L(u.id, s), e.putObject(c.data, f, g));
                }
                k(e, n, function(i, o) {
                    !i && o ? t(new T.EEXIST(null, n)) : !i || i instanceof T.ENOENT ? k(e, p, d) : t(i);
                });
            }
            function M(e, n, t, o) {
                var r = f.fsConstants, u = r.F_OK, a = r.R_OK, c = r.W_OK, l = r.X_OK, s = r.S_IXUSR, p = r.S_IXGRP, d = r.S_IXOTH;
                k(e, n = i(n), function(e, i) {
                    if (e) return o(e);
                    if (t === u) return o(null);
                    var r = xe(i.mode, o);
                    return r ? t & (a | c) ? o(null) : t & l && r & (s | p | d) ? o(null) : void o(new T.EACCES("permission denied", n)) : void 0;
                });
            }
            function z(e, n, t) {
                n = i(n);
                var u, a, c, f, l = r(n), p = o(n);
                function d(i, o) {
                    i ? t(i) : E === l ? t(new T.EBUSY(null, n)) : Object.prototype.hasOwnProperty.call(o, l) ? (u = (f = o)[l].id, e.getObject(u, m)) : t(new T.ENOENT(null, n));
                }
                function m(i, o) {
                    i ? t(i) : o.type !== s ? t(new T.ENOTDIR(null, n)) : (u = o, e.getObject(u.data, g));
                }
                function g(i, o) {
                    i ? t(i) : (a = o, Object.keys(a).length > 0 ? t(new T.ENOTEMPTY(null, n)) : (delete f[l], e.putObject(c.data, f, w)));
                }
                function w(n) {
                    if (n) t(n);
                    else {
                        var i = Date.now();
                        P(e, p, c, {
                            mtime: i,
                            ctime: i
                        }, O);
                    }
                }
                function O(n) {
                    n ? t(n) : e.delete(u.id, b);
                }
                function b(n) {
                    n ? t(n) : e.delete(u.data, t);
                }
                k(e, p, function(n, i) {
                    n ? t(n) : (c = i, e.getObject(c.data, d));
                });
            }
            function Y(n, t, u, a, c) {
                "function" == typeof a && (c = a, a = null), t = i(t);
                var f, d, m, g, O, N = r(t), h = o(t), I = 0;
                function j(e, i) {
                    e ? c(e) : i.type !== s ? c(new T.ENOENT(null, t)) : (f = i, n.getObject(f.data, A));
                }
                function A(e, i) {
                    e ? c(e) : (d = i, Object.prototype.hasOwnProperty.call(d, N) ? u.includes(v) ? c(new T.EEXIST("O_CREATE and O_EXCLUSIVE are set, and the named file exists", t)) : (m = d[N]).type === s && u.includes(b) ? c(new T.EISDIR("the named file is a directory and O_WRITE is set", t)) : n.getObject(m.id, D) : u.includes(y) ? S.create({
                        guid: n.guid,
                        type: l
                    }, function(e, t) {
                        e ? c(e) : ((g = t).nlinks += 1, a && (g.mode = a), n.putObject(g.id, g, _));
                    }) : c(new T.ENOENT("O_CREATE is not set and the named file does not exist", t)));
                }
                function D(e, a) {
                    if (e) c(e);
                    else {
                        var f = a;
                        f.type === p ? ++I > w ? c(new T.ELOOP(null, t)) : function(e) {
                            e = i(e), h = o(e), N = r(e), E === N && (u.includes(b) ? c(new T.EISDIR("the named file is a directory and O_WRITE is set", t)) : k(n, t, R));
                            k(n, h, j);
                        }(f.data) : R(void 0, f);
                    }
                }
                function R(e, n) {
                    e ? c(e) : c(null, g = n);
                }
                function _(t) {
                    t ? c(t) : (O = e.alloc(0), n.putBuffer(g.data, O, V));
                }
                function F(e) {
                    if (e) c(e);
                    else {
                        var t = Date.now();
                        P(n, h, f, {
                            mtime: t,
                            ctime: t
                        }, B);
                    }
                }
                function V(e) {
                    e ? c(e) : (d[N] = new L(g.id, l), n.putObject(f.data, d, F));
                }
                function B(e) {
                    e ? c(e) : c(null, g);
                }
                E === N ? u.includes(b) ? c(new T.EISDIR("the named file is a directory and O_WRITE is set", t)) : k(n, t, R) : k(n, h, j);
            }
            function K(n, t, i, o, r, u) {
                var a;
                function c(e) {
                    e ? u(e) : u(null, r);
                }
                function f(e) {
                    if (e) u(e);
                    else {
                        var i = Date.now();
                        P(n, t.path, a, {
                            mtime: i,
                            ctime: i
                        }, c);
                    }
                }
                function l(e) {
                    e ? u(e) : n.putObject(a.id, a, f);
                }
                n.getObject(t.id, function(c, f) {
                    if (c) u(c);
                    else {
                        a = f;
                        var s = e.alloc(r);
                        i.copy(s, 0, o, o + r), t.position = r, a.size = r, a.version += 1, n.putBuffer(a.data, s, l);
                    }
                });
            }
            function U(n, t, i, o, r, u, a) {
                var c, f;
                function l(e) {
                    e ? a(e) : a(null, r);
                }
                function s(e) {
                    if (e) a(e);
                    else {
                        var i = Date.now();
                        P(n, t.path, c, {
                            mtime: i,
                            ctime: i
                        }, l);
                    }
                }
                function p(e) {
                    e ? a(e) : n.putObject(c.id, c, s);
                }
                function d(l, s) {
                    if (l) a(l);
                    else {
                        if (!(f = s)) return a(new T.EIO("Expected Buffer"));
                        var d = null != u ? u : t.position, m = Math.max(f.length, d + r), E = e.alloc(m);
                        f && f.copy(E), i.copy(E, d, o, o + r), void 0 === u && (t.position += r), c.size = m, c.version += 1, n.putBuffer(c.data, E, p);
                    }
                }
                n.getObject(t.id, function(e, t) {
                    e ? a(e) : (c = t, n.getBuffer(c.data, d));
                });
            }
            function W(e, n, t, i, o, r, u) {
                var a, c;
                function f(e, a) {
                    if (e) u(e);
                    else {
                        if (!(c = a)) return u(new T.EIO("Expected Buffer"));
                        var f = null != r ? r : n.position;
                        o = f + o > t.length ? o - f : o, c.copy(t, i, f, f + o), void 0 === r && (n.position += o), u(null, o);
                    }
                }
                e.getObject(n.id, function(t, i) {
                    t ? u(t) : i.type === s ? u(new T.EISDIR("the named file is a directory", n.path)) : (a = i, e.getBuffer(a.data, f));
                });
            }
            function G(e, n, t) {
                k(e, n = i(n), t);
            }
            function H(e, n, t) {
                n.getNode(e, t);
            }
            function $(e, n, t) {
                n = i(n);
                var u, a, c = r(n), f = o(n);
                function l(e, n) {
                    if (e) return t(e);
                    S.create(n, t);
                }
                function s(i, o) {
                    i ? t(i) : (a = o, Object.prototype.hasOwnProperty.call(a, c) ? e.getObject(a[c].id, l) : t(new T.ENOENT("a component of the path does not name an existing file", n)));
                }
                E === c ? k(e, n, t) : k(e, f, function(n, i) {
                    n ? t(n) : (u = i, e.getObject(u.data, s));
                });
            }
            function J(e, n, t, u) {
                n = i(n);
                var a = r(n), c = o(n);
                t = i(t);
                var f, l, p, d, m, E, g = r(t), w = o(t), O = Date.now();
                function b(n) {
                    n ? u(n) : P(e, t, E, {
                        ctime: O
                    }, u);
                }
                function y(n, t) {
                    n ? u(n) : ((E = t).nlinks += 1, e.putObject(E.id, E, b));
                }
                function v(n) {
                    n ? u(n) : e.getObject(m, y);
                }
                function N(n, t) {
                    n ? u(n) : (d = t, Object.prototype.hasOwnProperty.call(d, g) ? u(new T.EEXIST("newpath resolves to an existing file", g)) : (d[g] = l[a], m = d[g].id, e.putObject(p.data, d, v)));
                }
                function h(n, t) {
                    n ? u(n) : (p = t, e.getObject(p.data, N));
                }
                function I(n, t) {
                    n ? u(n) : (l = t, Object.prototype.hasOwnProperty.call(l, a) ? l[a].type === s ? u(new T.EPERM("oldpath refers to a directory")) : k(e, w, h) : u(new T.ENOENT("a component of either path prefix does not exist", a)));
                }
                k(e, c, function(n, t) {
                    n ? u(n) : (f = t, e.getObject(f.data, I));
                });
            }
            function Q(e, n, t) {
                n = i(n);
                var u, a, c, f = r(n), l = o(n);
                function p(n) {
                    n ? t(n) : (delete a[f], e.putObject(u.data, a, function(n) {
                        if (n) t(n);
                        else {
                            var i = Date.now();
                            P(e, l, u, {
                                mtime: i,
                                ctime: i
                            }, t);
                        }
                    }));
                }
                function d(n) {
                    n ? t(n) : e.delete(c.data, p);
                }
                function m(i, o) {
                    i ? t(i) : o.type === s ? t(new T.EPERM("unlink not permitted on directories", f)) : function(i, o) {
                        i ? t(i) : ((c = o).nlinks -= 1, c.nlinks < 1 ? e.delete(c.id, d) : e.putObject(c.id, c, function(i) {
                            i ? t(i) : P(e, n, c, {
                                ctime: Date.now()
                            }, p);
                        }));
                    }(null, o);
                }
                function E(n, i) {
                    n ? t(n) : (a = i, Object.prototype.hasOwnProperty.call(a, f) ? e.getObject(a[f].id, m) : t(new T.ENOENT("a component of the path does not name an existing file", f)));
                }
                k(e, l, function(n, i) {
                    n ? t(n) : (u = i, e.getObject(u.data, E));
                });
            }
            function Z(n, o, r, u) {
                var a, f;
                function l(i, a) {
                    if (i) u(i);
                    else {
                        f = a;
                        var l = Object.keys(f);
                        if (r.encoding) {
                            var s = l.map(function(n) {
                                return e.from(n);
                            });
                            l = "buffer" === r.encoding ? s : s.map(function(e) {
                                return e.toString(r.encoding);
                            });
                        }
                        if (r.withFileTypes) {
                            var p = [];
                            c.eachSeries(l, function(i, u) {
                                var a = e.from(i, r.encoding).toString(), c = t.join(o, a);
                                ee(n, c, function(e, n) {
                                    e && u(e), n.name = i, p.push(n), u();
                                });
                            }, function(e) {
                                u(e, p);
                            });
                        } else u(null, l);
                    }
                }
                o = i(o), "function" == typeof r && (u = r, r = {}), r = ne(r), k(n, o, function(e, t) {
                    e ? u(e) : t.type !== s ? u(new T.ENOTDIR(null, o)) : (a = t, n.getObject(a.data, l));
                });
            }
            function ee(e, n, t) {
                $(e, n, function(i, o) {
                    if (i) t(i);
                    else {
                        var r = new V(n, o, e.name);
                        t(null, r);
                    }
                });
            }
            function ne(e, n) {
                return e ? "function" == typeof e ? e = {
                    encoding: n
                } : "string" == typeof e && (e = {
                    encoding: e
                }) : e = {
                    encoding: n
                }, e;
            }
            function te(e, n, a, c) {
                a = i(a);
                var f, l, s, d = r(a), m = o(a);
                function g(i, o) {
                    i ? c(i) : (l = o, Object.prototype.hasOwnProperty.call(l, d) ? c(new T.EEXIST(null, d)) : S.create({
                        guid: e.guid,
                        type: p
                    }, function(i, o) {
                        i ? c(i) : ((s = o).nlinks += 1, u(n) || (s.symlink_relpath = n, n = t.resolve(m, n)), s.size = n.length, s.data = n, e.putObject(s.id, s, O));
                    }));
                }
                function w(n) {
                    if (n) c(n);
                    else {
                        var t = Date.now();
                        P(e, m, f, {
                            mtime: t,
                            ctime: t
                        }, c);
                    }
                }
                function O(n) {
                    n ? c(n) : (l[d] = new L(s.id, p), e.putObject(f.data, l, w));
                }
                E === d ? c(new T.EEXIST(null, d)) : k(e, m, function(n, t) {
                    n ? c(n) : (f = t, e.getObject(f.data, g));
                });
            }
            function ie(e, n, t) {
                n = i(n);
                var u, a, c = r(n), f = o(n);
                function l(n, i) {
                    n ? t(n) : (a = i, Object.prototype.hasOwnProperty.call(a, c) ? e.getObject(a[c].id, s) : t(new T.ENOENT("a component of the path does not name an existing file", c)));
                }
                function s(e, i) {
                    if (e) t(e);
                    else if (i.type !== p) t(new T.EINVAL("path not a symbolic link", n));
                    else {
                        var o = i.symlink_relpath ? i.symlink_relpath : i.data;
                        t(null, o);
                    }
                }
                k(e, f, function(n, i) {
                    n ? t(n) : (u = i, e.getObject(u.data, l));
                });
            }
            function oe(n, t, o, r) {
                var u;
                function a(t, i) {
                    if (t) r(t);
                    else {
                        if (!i) return r(new T.EIO("Expected Buffer"));
                        var a = e.alloc(o);
                        i && i.copy(a), n.putBuffer(u.data, a, f);
                    }
                }
                function c(e) {
                    if (e) r(e);
                    else {
                        var i = Date.now();
                        P(n, t, u, {
                            mtime: i,
                            ctime: i
                        }, r);
                    }
                }
                function f(e) {
                    e ? r(e) : (u.size = o, u.version += 1, n.putObject(u.id, u, c));
                }
                t = i(t), o < 0 ? r(new T.EINVAL("length cannot be negative")) : k(n, t, function(e, i) {
                    e ? r(e) : i.type === s ? r(new T.EISDIR(null, t)) : (u = i, n.getBuffer(u.data, a));
                });
            }
            function re(n, t, i, o) {
                var r;
                function u(t, u) {
                    if (t) o(t);
                    else {
                        var a;
                        if (!u) return o(new T.EIO("Expected Buffer"));
                        a = u ? u.slice(0, i) : e.alloc(i), n.putBuffer(r.data, a, c);
                    }
                }
                function a(e) {
                    if (e) o(e);
                    else {
                        var i = Date.now();
                        P(n, t.path, r, {
                            mtime: i,
                            ctime: i
                        }, o);
                    }
                }
                function c(e) {
                    e ? o(e) : (r.size = i, r.version += 1, n.putObject(r.id, r, a));
                }
                i < 0 ? o(new T.EINVAL("length cannot be negative")) : t.getNode(n, function(e, t) {
                    e ? o(e) : t.type === s ? o(new T.EISDIR) : (r = t, n.getBuffer(r.data, u));
                });
            }
            function ue(e, n, t, o, r) {
                n = i(n), "number" != typeof t || "number" != typeof o ? r(new T.EINVAL("atime and mtime must be number", n)) : t < 0 || o < 0 ? r(new T.EINVAL("atime and mtime must be positive integers", n)) : k(e, n, function(i, u) {
                    i ? r(i) : P(e, n, u, {
                        atime: t,
                        ctime: o,
                        mtime: o
                    }, r);
                });
            }
            function ae(e, n, t, i, o) {
                "number" != typeof t || "number" != typeof i ? o(new T.EINVAL("atime and mtime must be a number")) : t < 0 || i < 0 ? o(new T.EINVAL("atime and mtime must be positive integers")) : n.getNode(e, function(r, u) {
                    r ? o(r) : P(e, n.path, u, {
                        atime: t,
                        ctime: i,
                        mtime: i
                    }, o);
                });
            }
            function ce(e, n, t, o, r, u) {
                n = i(n), "string" != typeof t ? u(new T.EINVAL("attribute name must be a string", n)) : t ? null !== r && r !== I && r !== j ? u(new T.EINVAL("invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE", n)) : k(e, n, function(i, a) {
                    if (i) return u(i);
                    C(e, n, a, t, o, r, u);
                }) : u(new T.EINVAL("attribute name cannot be an empty string", n));
            }
            function fe(e, n, t, i, o, r) {
                "string" != typeof t ? r(new T.EINVAL("attribute name must be a string")) : t ? null !== o && o !== I && o !== j ? r(new T.EINVAL("invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE")) : n.getNode(e, function(u, a) {
                    if (u) return r(u);
                    C(e, n.path, a, t, i, o, r);
                }) : r(new T.EINVAL("attribute name cannot be an empty string"));
            }
            function le(e, n, t, o) {
                n = i(n), "string" != typeof t ? o(new T.EINVAL("attribute name must be a string", n)) : t ? k(e, n, function(e, i) {
                    if (e) return o(e);
                    var r = i.xattrs;
                    Object.prototype.hasOwnProperty.call(r, t) ? o(null, r[t]) : o(new T.ENOATTR(null, n));
                }) : o(new T.EINVAL("attribute name cannot be an empty string", n));
            }
            function se(e, n, t, i) {
                "string" != typeof t ? i(new T.EINVAL) : t ? n.getNode(e, function(e, n) {
                    if (e) return i(e);
                    var o = n.xattrs;
                    Object.prototype.hasOwnProperty.call(o, t) ? i(null, o[t]) : i(new T.ENOATTR);
                }) : i(new T.EINVAL("attribute name cannot be an empty string"));
            }
            function pe(e, n, t, o) {
                n = i(n), "string" != typeof t ? o(new T.EINVAL("attribute name must be a string", n)) : t ? k(e, n, function(i, r) {
                    if (i) return o(i);
                    var u = r.xattrs;
                    Object.prototype.hasOwnProperty.call(u, t) ? (delete u[t], e.putObject(r.id, r, function(t) {
                        t ? o(t) : P(e, n, r, {
                            ctime: Date.now()
                        }, o);
                    })) : o(new T.ENOATTR(null, n));
                }) : o(new T.EINVAL("attribute name cannot be an empty string", n));
            }
            function de(e, n, t, i) {
                "string" != typeof t ? i(new T.EINVAL("attribute name must be a string")) : t ? n.getNode(e, function(o, r) {
                    if (o) return i(o);
                    var u = r.xattrs;
                    Object.prototype.hasOwnProperty.call(u, t) ? (delete u[t], e.putObject(r.id, r, function(t) {
                        t ? i(t) : P(e, n.path, r, {
                            ctime: Date.now()
                        }, i);
                    })) : i(new T.ENOATTR);
                }) : i(new T.EINVAL("attribute name cannot be an empty string"));
            }
            function me(e) {
                return Object.prototype.hasOwnProperty.call(h, e) ? h[e] : null;
            }
            function Ee(e, n, t) {
                return e ? "function" == typeof e ? e = {
                    encoding: n,
                    flag: t
                } : "string" == typeof e && (e = {
                    encoding: e,
                    flag: t
                }) : e = {
                    encoding: n,
                    flag: t
                }, e;
            }
            function ge(e, n, t, i, o) {
                if (arguments.length < 5 ? (o = arguments[arguments.length - 1], i = 420) : i = xe(i, m, o), !(t = me(t))) return o(new T.EINVAL("flags is not valid"), n);
                Y(e, n, t, i, function(e, i) {
                    if (e) o(e);
                    else {
                        var r;
                        r = t.includes(N) ? i.size : 0;
                        var u = new _(n, i.id, t, r), a = R.allocDescriptor(u);
                        o(null, a);
                    }
                });
            }
            function we(e, n, t) {
                R.getOpenFileDescription(n) ? (R.releaseDescriptor(n), t(null)) : t(new T.EBADF);
            }
            function Oe(e, n, t, i) {
                x(e, n, t, i);
            }
            function be(e, n, t, i) {
                if (arguments.length < 4) i = t, t = m;
                else if (!(t = xe(t, m, i))) return;
                q(e, n, i);
            }
            function ye(e, n, t, i) {
                "function" == typeof t && (i = t, t = f.fsConstants.F_OK), M(e, n, t |= f.fsConstants.F_OK, i);
            }
            function ve(e, n, t, i) {
                if (i = arguments[arguments.length - 1], !n) return i(new Error("filename prefix is required"));
                var o = n + "-" + a.randomChars(6);
                q(e, o, function(e) {
                    i(e, o);
                });
            }
            function Ne(e, n, t) {
                z(e, n, t);
            }
            function he(e, n, t) {
                G(e, n, function(i, o) {
                    if (i) t(i);
                    else {
                        var r = new B(n, o, e.name);
                        t(null, r);
                    }
                });
            }
            function Ie(e, n, t) {
                var i = R.getOpenFileDescription(n);
                i ? H(e, i, function(n, o) {
                    if (n) t(n);
                    else {
                        var r = new B(i.path, o, e.name);
                        t(null, r);
                    }
                }) : t(new T.EBADF);
            }
            function je(e, n, t, i) {
                J(e, n, t, i);
            }
            function Ae(e, n, t) {
                Q(e, n, t);
            }
            function De(e, n, t, i, o, r, u) {
                i = void 0 === i ? 0 : i, o = void 0 === o ? t.length - i : o, u = arguments[arguments.length - 1];
                var a = R.getOpenFileDescription(n);
                a ? a.flags.includes(O) ? W(e, a, t, i, o, r, function(e, n) {
                    u(e, n || 0, t);
                }) : u(new T.EBADF("descriptor does not permit reading")) : u(new T.EBADF);
            }
            function Te(e, n, t) {
                Ve(n, t) === n && (R.getOpenFileDescription(n) ? t() : t(new T.EBADF));
            }
            function Le(n, t, i, o) {
                o = arguments[arguments.length - 1];
                var r = me((i = Ee(i, null, "r")).flag || "r");
                if (!r) return o(new T.EINVAL("flags is not valid", t));
                Y(n, t, r, function(u, a) {
                    if (u) return o(u);
                    var c = new _(t, a.id, r, 0), f = R.allocDescriptor(c);
                    function l() {
                        R.releaseDescriptor(f);
                    }
                    H(n, c, function(r, u) {
                        if (r) return l(), o(r);
                        var a = new B(c.path, u, n.name);
                        if (a.isDirectory()) return l(), o(new T.EISDIR("illegal operation on directory", t));
                        var f = a.size, s = e.alloc(f);
                        W(n, c, s, 0, f, 0, function(e) {
                            if (l(), e) return o(e);
                            var n;
                            n = "utf8" === i.encoding ? s.toString("utf8") : s, o(null, n);
                        });
                    });
                });
            }
            function Re(e, n, t, i, o, r, u) {
                u = arguments[arguments.length - 1], i = void 0 === i ? 0 : i, o = void 0 === o ? t.length - i : o;
                var a = R.getOpenFileDescription(n);
                a ? a.flags.includes(b) ? t.length - i < o ? u(new T.EIO("input buffer is too small")) : U(e, a, t, i, o, r, u) : u(new T.EBADF("descriptor does not permit writing")) : u(new T.EBADF);
            }
            function _e(n, t, i, o, r) {
                r = arguments[arguments.length - 1];
                var u = me((o = Ee(o, "utf8", "w")).flag || "w");
                if (!u) return r(new T.EINVAL("flags is not valid", t));
                e.isBuffer(i) || ("number" == typeof i && (i = "" + i), i = "string" != typeof (i = i || "") ? e.from(i.toString()) : e.from(i || "", o.encoding || "utf8")), Y(n, t, u, function(e, o) {
                    if (e) return r(e);
                    var a = new _(t, o.id, u, 0), c = R.allocDescriptor(a);
                    K(n, a, i, 0, i.length, function(e) {
                        if (R.releaseDescriptor(c), e) return r(e);
                        r(null);
                    });
                });
            }
            function Fe(n, t, i, o, r) {
                r = arguments[arguments.length - 1];
                var u = me((o = Ee(o, "utf8", "a")).flag || "a");
                if (!u) return r(new T.EINVAL("flags is not valid", t));
                "number" == typeof (i = i || "") && (i = "" + i), "string" == typeof i && "utf8" === o.encoding && (i = e.from(i)), Y(n, t, u, function(e, o) {
                    if (e) return r(e);
                    var a = new _(t, o.id, u, o.size), c = R.allocDescriptor(a);
                    U(n, a, i, 0, i.length, a.position, function(e) {
                        if (R.releaseDescriptor(c), e) return r(e);
                        r(null);
                    });
                });
            }
            function Se(e, n, t) {
                he(e, n, function(e) {
                    t(!e);
                });
            }
            function Ve(e, n) {
                if ("number" == typeof e) return e;
                n(new T.EINVAL("Expected integer", e));
            }
            var Be = /^[0-7]+$/;
            function Pe(e) {
                return e === e >>> 0;
            }
            function xe(e, n, t) {
                return "function" == typeof n && (t = n, n = void 0), Pe(e) ? e & m : "number" == typeof e ? (Number.isInteger(e), t(new T.EINVAL("mode not a valid an integer value", e)), !1) : "string" == typeof e ? Be.test(e) ? parseInt(e, 8) & m : (t(new T.EINVAL("mode not a valid octal string", e)), !1) : void 0 !== n ? n : (t(new T.EINVAL("mode not valid", e)), !1);
            }
            function ke(e, n, t, o) {
                n = i(n), "number" != typeof t ? o(new T.EINVAL("mode must be number", n)) : k(e, n, function(i, r) {
                    i ? o(i) : (r.mode = t, P(e, n, r, {
                        mtime: Date.now()
                    }, o));
                });
            }
            function Ce(e, n, t, i) {
                "number" != typeof t ? i(new T.EINVAL("mode must be a number")) : n.getNode(e, function(o, r) {
                    o ? i(o) : (r.mode = t, P(e, n.path, r, {
                        mtime: Date.now()
                    }, i));
                });
            }
            function Xe(e, n, t, o, r) {
                n = i(n), k(e, n, function(i, u) {
                    i ? r(i) : (u.uid = t, u.gid = o, P(e, n, u, {
                        mtime: Date.now()
                    }, r));
                });
            }
            function qe(e, n, t, i, o) {
                n.getNode(e, function(r, u) {
                    r ? o(r) : (u.uid = t, u.gid = i, P(e, n.path, u, {
                        mtime: Date.now()
                    }, o));
                });
            }
            function Me(e, n, t, i) {
                le(e, n, t, i);
            }
            function ze(e, n, t, i) {
                var o = R.getOpenFileDescription(n);
                o ? se(e, o, t, i) : i(new T.EBADF);
            }
            function Ye(e, n, t, i, o, r) {
                "function" == typeof o && (r = o, o = null), ce(e, n, t, i, o, r);
            }
            function Ke(e, n, t, i, o, r) {
                "function" == typeof o && (r = o, o = null);
                var u = R.getOpenFileDescription(n);
                u ? u.flags.includes(b) ? fe(e, u, t, i, o, r) : r(new T.EBADF("descriptor does not permit writing")) : r(new T.EBADF);
            }
            function Ue(e, n, t, i) {
                pe(e, n, t, i);
            }
            function We(e, n, t, i) {
                var o = R.getOpenFileDescription(n);
                o ? o.flags.includes(b) ? de(e, o, t, i) : i(new T.EBADF("descriptor does not permit writing")) : i(new T.EBADF);
            }
            function Ge(e, n, t, i, o) {
                var r = R.getOpenFileDescription(n);
                r || o(new T.EBADF), "SET" === i ? t < 0 ? o(new T.EINVAL("resulting file offset would be negative")) : (r.position = t, o(null, r.position)) : "CUR" === i ? r.position + t < 0 ? o(new T.EINVAL("resulting file offset would be negative")) : (r.position += t, o(null, r.position)) : "END" === i ? H(e, r, function(e, n) {
                    e ? o(e) : n.size + t < 0 ? o(new T.EINVAL("resulting file offset would be negative")) : (r.position = n.size + t, o(null, r.position));
                }) : o(new T.EINVAL("whence argument is not a proper value"));
            }
            function He(e, n, t, i) {
                Z(e, n, t, i);
            }
            function $e(e) {
                return "number" == typeof e ? e : "object" === n(e) && "function" == typeof e.getTime ? e.getTime() : void 0;
            }
            function Je(e, n, t, i, o) {
                var r = Date.now();
                ue(e, n, t = $e(t || r), i = $e(i || r), o);
            }
            function Qe(e, n, t, i, o) {
                var r = Date.now();
                t = $e(t || r), i = $e(i || r);
                var u = R.getOpenFileDescription(n);
                u ? u.flags.includes(b) ? ae(e, u, t, i, o) : o(new T.EBADF("descriptor does not permit writing")) : o(new T.EBADF);
            }
            function Ze(e, n, t, i) {
                (t = xe(t, i)) && ke(e, n, t, i);
            }
            function en(e, n, t, i) {
                if (t = xe(t, i)) {
                    var o = R.getOpenFileDescription(n);
                    o ? o.flags.includes(b) ? Ce(e, o, t, i) : i(new T.EBADF("descriptor does not permit writing")) : i(new T.EBADF);
                }
            }
            function nn(e, n, t, i, o) {
                return Pe(t) ? Pe(i) ? void Xe(e, n, t, i, o) : o(new T.EINVAL("gid must be a valid integer", i)) : o(new T.EINVAL("uid must be a valid integer", t));
            }
            function tn(e, n, t, i, o) {
                if (!Pe(t)) return o(new T.EINVAL("uid must be a valid integer", t));
                if (!Pe(i)) return o(new T.EINVAL("gid must be a valid integer", i));
                var r = R.getOpenFileDescription(n);
                r ? r.flags.includes(b) ? qe(e, r, t, i, o) : o(new T.EBADF("descriptor does not permit writing")) : o(new T.EBADF);
            }
            function on(e, n, o, r) {
                n = i(n), o = i(o);
                var u, a, c, f, l = t.dirname(n), p = t.dirname(o), d = t.basename(n), m = t.basename(o), E = Date.now();
                function g(n, t) {
                    n ? r(n) : P(e, o, t, {
                        ctime: E
                    }, r);
                }
                function w(n) {
                    n ? r(n) : e.getObject(f[m].id, g);
                }
                function O(n) {
                    n ? r(n) : (u.id === c.id && (a = f), delete a[d], e.putObject(u.data, a, w));
                }
                function b(n) {
                    n ? r(n) : (f[m] = a[d], e.putObject(c.data, f, O));
                }
                function y(n, t) {
                    n ? r(n) : (f = t, Object.prototype.hasOwnProperty.call(f, m) ? z(e, o, b) : b());
                }
                function v(n, t) {
                    n ? r(n) : (c = t, e.getObject(c.data, y));
                }
                function N(n, t) {
                    n ? r(n) : (a = t, k(e, p, v));
                }
                function h(n, t) {
                    n ? r(n) : (u = t, e.getObject(t.data, N));
                }
                function I(t) {
                    t ? r(t) : Q(e, n, r);
                }
                k(e, n, function(t, i) {
                    t ? r(t) : i.type === s ? k(e, l, h) : J(e, n, o, I);
                });
            }
            function rn(e, n, t, i, o) {
                te(e, n, t, o = arguments[arguments.length - 1]);
            }
            function un(e, n, t) {
                ie(e, n, t);
            }
            function an(e, n, t) {
                $(e, n, function(i, o) {
                    if (i) t(i);
                    else {
                        var r = new B(n, o, e.name);
                        t(null, r);
                    }
                });
            }
            function cn(e, n, t, i) {
                Ve(t = t || 0, i = arguments[arguments.length - 1]) === t && oe(e, n, t, i);
            }
            function fn(e, n, t, i) {
                i = arguments[arguments.length - 1], t = t || 0;
                var o = R.getOpenFileDescription(n);
                if (o) {
                    if (o.flags.includes(b)) {
                        if (Ve(t, i) !== t) return;
                        re(e, o, t, i);
                    } else i(new T.EBADF("descriptor does not permit writing"));
                } else i(new T.EBADF);
            }
            module1.exports = {
                appendFile: Fe,
                access: ye,
                chown: nn,
                chmod: Ze,
                close: we,
                ensureRootDirectory: X,
                exists: Se,
                fchown: tn,
                fchmod: en,
                fgetxattr: ze,
                fremovexattr: We,
                fsetxattr: Ke,
                fstat: Ie,
                fsync: Te,
                ftruncate: fn,
                futimes: Qe,
                getxattr: Me,
                link: je,
                lseek: Ge,
                lstat: an,
                mkdir: be,
                mkdtemp: ve,
                mknod: Oe,
                open: ge,
                readdir: He,
                read: De,
                readFile: Le,
                readlink: un,
                removexattr: Ue,
                rename: on,
                rmdir: Ne,
                setxattr: Ye,
                stat: he,
                symlink: rn,
                truncate: cn,
                unlink: Ae,
                utimes: Je,
                writeFile: _e,
                write: Re
            };
        },
        {
            "../path.js": "UzoP",
            "../shared.js": "zBMa",
            "../../lib/async.js": "u4Zs",
            "../constants.js": "iJA9",
            "../errors.js": "p8GN",
            "../directory-entry.js": "ZECt",
            "../open-files.js": "osLK",
            "../open-file-description.js": "XWaV",
            "../super-node.js": "JEp0",
            "../node.js": "KKNo",
            "../dirent.js": "q4Wu",
            "../stats.js": "dsCT",
            "buffer": "dskh"
        }
    ],
    "GMi4": [
        function(require1, module1, exports) {
            var Buffer = require1("buffer").Buffer;
            var e = require1("buffer").Buffer, r = require1("es6-promisify"), t = r.promisify, n = require1("../path.js"), a = require1("../providers/index.js"), s = require1("../shell/shell.js"), o = require1("../../lib/intercom.js"), i = require1("../fs-watcher.js"), u = require1("../errors.js"), m = require1("../shared.js"), c = m.nop, f = m.guid, l = require1("../constants.js"), h = l.fsConstants, p = l.FILE_SYSTEM_NAME, d = l.FS_FORMAT, g = l.FS_READY, b = l.FS_PENDING, A = l.FS_ERROR, P = l.FS_NODUPEIDCHECK, v = l.STDIN, y = l.STDOUT, E = l.STDERR, R = require1("./implementation.js");
            function w(e) {
                return "function" == typeof e ? e : function(e) {
                    if (e) throw e;
                };
            }
            function S(e) {
                e && console.error("Filer error: ", e);
            }
            function O(e) {
                if (!(e && e.protocol && e.pathname)) return e;
                if ("file:" !== e.protocol) throw new u.EINVAL("only file: URLs are supported for paths", e);
                for(var r = e.pathname, t = 0; t < r.length; t++)if ("%" === r[t]) {
                    var n = 32 | r.codePointAt(t + 2);
                    if ("2" === r[t + 1] && 102 === n) throw new u.EINVAL("file: URLs must not include encoded / characters", e);
                }
                return decodeURIComponent(r);
            }
            function x(r) {
                return e.isBuffer(r) ? r.toString() : r;
            }
            function F(e, r) {
                return e ? n.isNull(e) ? new u.EINVAL("Path must be a string without null bytes.", e) : r || n.isAbsolute(e) ? void 0 : new u.EINVAL("Path must be absolute.", e) : new u.EINVAL("Path must be a string", e);
            }
            function _(e, r, t) {
                var n = e[r], a = F(n = x(n = O(n)), t);
                if (a) throw a;
                e[r] = n;
            }
            function q(e, r) {
                r = r || S;
                var m = (e = e || {}).flags || [], l = e.guid ? e.guid : f, O = e.provider || new a.Default(e.name || p), x = e.name || O.name, F = m.includes(d), I = this;
                I.readyState = b, I.name = x, I.error = null, I.stdin = v, I.stdout = y, I.stderr = E, I.constants = h, I.F_OK = h.F_OK, I.R_OK = h.R_OK, I.W_OK = h.W_OK, I.X_OK = h.X_OK, this.Shell = s.bind(void 0, this);
                var N = [];
                function j(e) {
                    return function(r) {
                        m.includes(P) ? r(null, l()) : function r(t) {
                            var n = l();
                            e.getObject(n, function(e, a) {
                                e ? t(e) : a ? r(t) : t(null, n);
                            });
                        }(r);
                    };
                }
                this.queueOrRun = function(e) {
                    var r;
                    return g === I.readyState ? e.call(I) : A === I.readyState ? r = new u.EFILESYSTEMERROR("unknown error") : N.push(e), r;
                }, this.watch = function(e, r, t) {
                    if (n.isNull(e)) throw new Error("Path must be a string without null bytes.");
                    "function" == typeof r && (t = r, r = {}), r = r || {}, t = t || c;
                    var a = new i;
                    return a.start(e, !1, r.recursive), a.on("change", t), a;
                }, O.open(function(e) {
                    function t(e) {
                        function t(e) {
                            var r = O[e]();
                            return r.name = x, r.flags = m, r.changes = [], r.guid = j(r), r.close = function() {
                                var e = r.changes;
                                !function(e) {
                                    if (e.length) {
                                        var r = o.getInstance();
                                        e.forEach(function(e) {
                                            r.emit(e.event, e.path);
                                        });
                                    }
                                }(e), e.length = 0;
                            }, r;
                        }
                        I.provider = {
                            openReadWriteContext: function() {
                                return t("getReadWriteContext");
                            },
                            openReadOnlyContext: function() {
                                return t("getReadOnlyContext");
                            }
                        }, I.readyState = e ? A : g, N.forEach((function(e) {
                            e.call(this);
                        }).bind(I)), N = null, r(e, I);
                    }
                    if (e) return t(e);
                    var n = O.getReadWriteContext();
                    n.guid = j(n), F ? n.clear(function(e) {
                        if (e) return t(e);
                        R.ensureRootDirectory(n, t);
                    }) : R.ensureRootDirectory(n, t);
                }), q.prototype.promises = {}, [
                    {
                        name: "appendFile",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "access",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "chown",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "chmod",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "close"
                    },
                    {
                        name: "exists",
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "fchown"
                    },
                    {
                        name: "fchmod"
                    },
                    {
                        name: "fgetxattr"
                    },
                    {
                        name: "fremovexattr"
                    },
                    {
                        name: "fsetxattr"
                    },
                    {
                        name: "fstat"
                    },
                    {
                        name: "fsync"
                    },
                    {
                        name: "ftruncate"
                    },
                    {
                        name: "futimes"
                    },
                    {
                        name: "getxattr",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "link",
                        promises: !0,
                        absPathArgs: [
                            0,
                            1
                        ]
                    },
                    {
                        name: "lseek"
                    },
                    {
                        name: "lstat",
                        promises: !0
                    },
                    {
                        name: "mkdir",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "mkdtemp",
                        promises: !0
                    },
                    {
                        name: "mknod",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "open",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "readdir",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "read"
                    },
                    {
                        name: "readFile",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "readlink",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "removexattr",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "rename",
                        promises: !0,
                        absPathArgs: [
                            0,
                            1
                        ]
                    },
                    {
                        name: "rmdir",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "setxattr",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "stat",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "symlink",
                        promises: !0,
                        relPathArgs: [
                            0
                        ],
                        absPathArgs: [
                            1
                        ]
                    },
                    {
                        name: "truncate",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "unlink",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "utimes",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "writeFile",
                        promises: !0,
                        absPathArgs: [
                            0
                        ]
                    },
                    {
                        name: "write"
                    }
                ].forEach(function(e) {
                    var r = e.name, n = !0 === e.promises;
                    q.prototype[r] = function() {
                        var t = this, n = Array.prototype.slice.call(arguments, 0), a = n.length - 1, s = "function" != typeof n[a], o = w(n[a]);
                        e.absPathArgs && e.absPathArgs.forEach(function(e) {
                            return _(n, e, !1);
                        }), e.relPathArgs && e.relPathArgs.forEach(function(e) {
                            return _(n, e, !0);
                        });
                        var i = t.queueOrRun(function() {
                            var e = t.provider.openReadWriteContext();
                            if (A === t.readyState) {
                                var i = new u.EFILESYSTEMERROR("filesystem unavailable, operation canceled");
                                return o.call(t, i);
                            }
                            function m() {
                                e.close(), o.apply(t, arguments);
                            }
                            s ? n.push(m) : n[a] = m;
                            var c = [
                                e
                            ].concat(n);
                            R[r].apply(null, c);
                        });
                        i && o(i);
                    }, n && (q.prototype.promises[r] = t(q.prototype[r].bind(I)));
                });
            }
            q.providers = a, module1.exports = q;
        },
        {
            "es6-promisify": "b1ZG",
            "../path.js": "UzoP",
            "../providers/index.js": "AiW7",
            "../shell/shell.js": "D1Ra",
            "../../lib/intercom.js": "u7Jv",
            "../fs-watcher.js": "VLEe",
            "../errors.js": "p8GN",
            "../shared.js": "zBMa",
            "../constants.js": "iJA9",
            "./implementation.js": "bsBG",
            "buffer": "dskh"
        }
    ],
    "iIhC": [
        function(require1, module1, exports) {
            "use strict";
            function e(e, t, r) {
                return {
                    dataPath: void 0,
                    schemaPath: void 0,
                    keyword: "absolutePath",
                    params: {
                        absolutePath: r
                    },
                    message: e,
                    parentSchema: t
                };
            }
            function t(t, r, a) {
                return e(t ? "The provided value ".concat(JSON.stringify(a), " is not an absolute path!") : "A relative path is expected. However, the provided value ".concat(JSON.stringify(a), " is an absolute path!"), r, a);
            }
            function r(r) {
                return r.addKeyword("absolutePath", {
                    errors: !0,
                    type: "string",
                    compile: function(r, a) {
                        var o = function o(s) {
                            var n = !0;
                            return s.includes("!") && (o.errors = [
                                e("The provided value ".concat(JSON.stringify(s), " contains exclamation mark (!) which is not allowed because it's reserved for loader syntax."), a, s)
                            ], n = !1), r === /^(?:[A-Za-z]:(\\|\/)|\\\\|\/)/.test(s) || (o.errors = [
                                t(r, a, s)
                            ], n = !1), n;
                        };
                        return o.errors = [], o;
                    }
                }), r;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var a = r;
            exports.default = a;
        },
        {}
    ],
    "GNtl": [
        function(require1, module1, exports) {
            "use strict";
            function t(t, n) {
                return a(t) || o(t, n) || r(t, n) || e();
            }
            function e() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function r(t, e) {
                if (t) {
                    if ("string" == typeof t) return n(t, e);
                    var r = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(r) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(t, e) : void 0;
                }
            }
            function n(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for(var r = 0, n = new Array(e); r < e; r++)n[r] = t[r];
                return n;
            }
            function o(t, e) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                    var r = [], n = !0, o = !1, a = void 0;
                    try {
                        for(var i, u = t[Symbol.iterator](); !(n = (i = u.next()).done) && (r.push(i.value), !e || r.length !== e); n = !0);
                    } catch (f) {
                        o = !0, a = f;
                    } finally{
                        try {
                            n || null == u.return || u.return();
                        } finally{
                            if (o) throw a;
                        }
                    }
                    return r;
                }
            }
            function a(t) {
                if (Array.isArray(t)) return t;
            }
            function i(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            function u(t, e) {
                for(var r = 0; r < e.length; r++){
                    var n = e[r];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
                }
            }
            function f(t, e, r) {
                return e && u(t.prototype, e), r && u(t, r), t;
            }
            var c = function() {
                function e() {
                    i(this, e), this._left = [], this._right = [];
                }
                return f(e, [
                    {
                        key: "left",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            this._left.push([
                                t,
                                e
                            ]);
                        }
                    },
                    {
                        key: "right",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            this._right.push([
                                t,
                                e
                            ]);
                        }
                    },
                    {
                        key: "format",
                        value: function() {
                            var r = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], n = t(e.getRangeValue(this._left, r), 2), o = n[0], a = n[1], i = t(e.getRangeValue(this._right, !r), 2), u = i[0], f = i[1];
                            if (!Number.isFinite(o) && !Number.isFinite(u)) return "";
                            var c = a ? o + 1 : o;
                            return c === (f ? u - 1 : u) ? "should be ".concat(r ? "" : "!", "= ").concat(c) : Number.isFinite(o) && !Number.isFinite(u) ? e.formatLeft(o, r, a) : !Number.isFinite(o) && Number.isFinite(u) ? e.formatRight(u, r, f) : e.formatRange(o, u, a, f, r);
                        }
                    }
                ], [
                    {
                        key: "getOperator",
                        value: function(t, e) {
                            return "left" === t ? e ? ">" : ">=" : e ? "<" : "<=";
                        }
                    },
                    {
                        key: "formatRight",
                        value: function(t, r, n) {
                            return !1 === r ? e.formatLeft(t, !r, !n) : "should be ".concat(e.getOperator("right", n), " ").concat(t);
                        }
                    },
                    {
                        key: "formatLeft",
                        value: function(t, r, n) {
                            return !1 === r ? e.formatRight(t, !r, !n) : "should be ".concat(e.getOperator("left", n), " ").concat(t);
                        }
                    },
                    {
                        key: "formatRange",
                        value: function(t, r, n, o, a) {
                            var i = "should be";
                            return i += " ".concat(e.getOperator(a ? "left" : "right", a ? n : !n), " ").concat(t, " "), i += a ? "and" : "or", i += " ".concat(e.getOperator(a ? "right" : "left", a ? o : !o), " ").concat(r);
                        }
                    },
                    {
                        key: "getRangeValue",
                        value: function(e, r) {
                            for(var n = r ? 1 / 0 : -1 / 0, o = -1, a = r ? function(e) {
                                return t(e, 1)[0] <= n;
                            } : function(e) {
                                return t(e, 1)[0] >= n;
                            }, i = 0; i < e.length; i++)if (a(e[i])) {
                                var u = t(e[i], 1);
                                n = u[0], o = i;
                            }
                            return o > -1 ? e[o] : [
                                1 / 0,
                                !0
                            ];
                        }
                    }
                ]), e;
            }();
            module1.exports = c;
        },
        {}
    ],
    "SqDh": [
        function(require1, module1, exports) {
            "use strict";
            function t(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(t);
                    e && (r = r.filter(function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable;
                    })), n.push.apply(n, r);
                }
                return n;
            }
            function e(e) {
                for(var r = 1; r < arguments.length; r++){
                    var m = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? t(Object(m), !0).forEach(function(t) {
                        n(e, t, m[t]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(m)) : t(Object(m)).forEach(function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(m, t));
                    });
                }
                return e;
            }
            function n(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t;
            }
            var r = require1("./Range");
            module1.exports.stringHints = function(t, n) {
                var r = [], m = "string", i = e({}, t);
                if (!n) {
                    var o = i.minLength, u = i.formatMinimum, a = i.formatExclusiveMaximum;
                    i.minLength = i.maxLength, i.maxLength = o, i.formatMinimum = i.formatMaximum, i.formatMaximum = u, i.formatExclusiveMaximum = !i.formatExclusiveMinimum, i.formatExclusiveMinimum = !a;
                }
                if ("number" == typeof i.minLength) {
                    if (1 === i.minLength) m = "non-empty string";
                    else {
                        var c = Math.max(i.minLength - 1, 0);
                        r.push("should be longer than ".concat(c, " character").concat(c > 1 ? "s" : ""));
                    }
                }
                if ("number" == typeof i.maxLength) {
                    if (0 === i.maxLength) m = "empty string";
                    else {
                        var f = i.maxLength + 1;
                        r.push("should be shorter than ".concat(f, " character").concat(f > 1 ? "s" : ""));
                    }
                }
                return i.pattern && r.push("should".concat(n ? "" : " not", " match pattern ").concat(JSON.stringify(i.pattern))), i.format && r.push("should".concat(n ? "" : " not", " match format ").concat(JSON.stringify(i.format))), i.formatMinimum && r.push("should be ".concat(i.formatExclusiveMinimum ? ">" : ">=", " ").concat(JSON.stringify(i.formatMinimum))), i.formatMaximum && r.push("should be ".concat(i.formatExclusiveMaximum ? "<" : "<=", " ").concat(JSON.stringify(i.formatMaximum))), [
                    m
                ].concat(r);
            }, module1.exports.numberHints = function(t, e) {
                var n = [
                    "integer" === t.type ? "integer" : "number"
                ], m = new r;
                "number" == typeof t.minimum && m.left(t.minimum), "number" == typeof t.exclusiveMinimum && m.left(t.exclusiveMinimum, !0), "number" == typeof t.maximum && m.right(t.maximum), "number" == typeof t.exclusiveMaximum && m.right(t.exclusiveMaximum, !0);
                var i = m.format(e);
                return i && n.push(i), "number" == typeof t.multipleOf && n.push("should".concat(e ? "" : " not", " be multiple of ").concat(t.multipleOf)), n;
            };
        },
        {
            "./Range": "GNtl"
        }
    ],
    "ySUA": [
        function(require1, module1, exports) {
            "use strict";
            function t(t) {
                return n(t) || r(t) || i(t) || e();
            }
            function e() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function n(t) {
                if (Array.isArray(t)) return s(t);
            }
            function a(t) {
                return m(t) || r(t) || i(t) || c();
            }
            function r(t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);
            }
            function o(t, e) {
                return m(t) || u(t, e) || i(t, e) || c();
            }
            function c() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function i(t, e) {
                if (t) {
                    if ("string" == typeof t) return s(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(n) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(t, e) : void 0;
                }
            }
            function s(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for(var n = 0, a = new Array(e); n < e; n++)a[n] = t[n];
                return a;
            }
            function u(t, e) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                    var n = [], a = !0, r = !1, o = void 0;
                    try {
                        for(var c, i = t[Symbol.iterator](); !(a = (c = i.next()).done) && (n.push(c.value), !e || n.length !== e); a = !0);
                    } catch (s) {
                        r = !0, o = s;
                    } finally{
                        try {
                            a || null == i.return || i.return();
                        } finally{
                            if (r) throw o;
                        }
                    }
                    return n;
                }
            }
            function m(t) {
                if (Array.isArray(t)) return t;
            }
            function h(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }
            function p(t, e) {
                for(var n = 0; n < e.length; n++){
                    var a = e[n];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a);
                }
            }
            function l(t, e, n) {
                return e && p(t.prototype, e), n && p(t, n), t;
            }
            function f(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && x(t, e);
            }
            function d(t) {
                return function() {
                    var e, n = O(t);
                    if (S()) {
                        var a = O(this).constructor;
                        e = Reflect.construct(n, arguments, a);
                    } else e = n.apply(this, arguments);
                    return y(this, e);
                };
            }
            function y(t, e) {
                return !e || "object" !== j(e) && "function" != typeof e ? v(t) : e;
            }
            function v(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t;
            }
            function g(t) {
                var e = "function" == typeof Map ? new Map : void 0;
                return (g = function(t) {
                    if (null === t || !P(t)) return t;
                    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== e) {
                        if (e.has(t)) return e.get(t);
                        e.set(t, n);
                    }
                    function n() {
                        return b(t, arguments, O(this).constructor);
                    }
                    return n.prototype = Object.create(t.prototype, {
                        constructor: {
                            value: n,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), x(n, t);
                })(t);
            }
            function b(t, e, n) {
                return (b = S() ? Reflect.construct : function(t, e, n) {
                    var a = [
                        null
                    ];
                    a.push.apply(a, e);
                    var r = new (Function.bind.apply(t, a));
                    return n && x(r, n.prototype), r;
                }).apply(null, arguments);
            }
            function S() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                } catch (t) {
                    return !1;
                }
            }
            function P(t) {
                return -1 !== Function.toString.call(t).indexOf("[native code]");
            }
            function x(t, e) {
                return (x = Object.setPrototypeOf || function(t, e) {
                    return t.__proto__ = e, t;
                })(t, e);
            }
            function O(t) {
                return (O = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                })(t);
            }
            function j(t) {
                return (j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t;
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
                })(t);
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var w = require1("./util/hints"), D = w.stringHints, I = w.numberHints, T = {
                type: 1,
                not: 1,
                oneOf: 1,
                anyOf: 1,
                if: 1,
                enum: 1,
                const: 1,
                instanceof: 1,
                required: 2,
                pattern: 2,
                patternRequired: 2,
                format: 2,
                formatMinimum: 2,
                formatMaximum: 2,
                minimum: 2,
                exclusiveMinimum: 2,
                maximum: 2,
                exclusiveMaximum: 2,
                multipleOf: 2,
                uniqueItems: 2,
                contains: 2,
                minLength: 2,
                maxLength: 2,
                minItems: 2,
                maxItems: 2,
                minProperties: 2,
                maxProperties: 2,
                dependencies: 2,
                propertyNames: 2,
                additionalItems: 2,
                additionalProperties: 2,
                absolutePath: 2
            };
            function k(t, e) {
                var n = t.reduce(function(t, n) {
                    return Math.max(t, e(n));
                }, 0);
                return t.filter(function(t) {
                    return e(t) === n;
                });
            }
            function A(t) {
                var e = t;
                return e = k(e, function(t) {
                    return t.dataPath ? t.dataPath.length : 0;
                }), e = k(e, function(t) {
                    return T[t.keyword] || 2;
                });
            }
            function N(t, e) {
                for(var n = t.length - 1, a = function(e) {
                    return 0 !== t[n].schemaPath.indexOf(e);
                }; n > -1 && !e.every(a);)if ("anyOf" === t[n].keyword || "oneOf" === t[n].keyword) {
                    var r = M(t[n]), o = N(t.slice(0, n), r.concat(t[n].schemaPath));
                    n = o - 1;
                } else n -= 1;
                return n + 1;
            }
            function M(t) {
                var e = t.schema;
                return Array.isArray(e) ? e.map(function(t) {
                    return t.$ref;
                }).filter(function(t) {
                    return t;
                }) : [];
            }
            function E(t) {
                for(var e = [], n = t.length - 1; n > 0;){
                    var a = t[n];
                    if ("anyOf" === a.keyword || "oneOf" === a.keyword) {
                        var r = M(a), o = N(t.slice(0, n), r.concat(a.schemaPath));
                        o !== n ? (e.push(Object.assign({}, a, {
                            children: t.slice(o, n)
                        })), n = o) : e.push(a);
                    } else e.push(a);
                    n -= 1;
                }
                return 0 === n && e.push(t[n]), e.reverse();
            }
            function q(t, e) {
                return t.replace(/\n(?!$)/g, "\n".concat(e));
            }
            function R(t) {
                return !!t.not;
            }
            function J(t) {
                return R(t) ? J(t.not) : t;
            }
            function $(t) {
                var e = J(t);
                return V(e) || F(e) || L(e) || z(e) || B(e);
            }
            function _(t) {
                return "object" === j(t) && null !== t;
            }
            function V(t) {
                return "number" === t.type || void 0 !== t.minimum || void 0 !== t.exclusiveMinimum || void 0 !== t.maximum || void 0 !== t.exclusiveMaximum || void 0 !== t.multipleOf;
            }
            function F(t) {
                return "integer" === t.type || void 0 !== t.minimum || void 0 !== t.exclusiveMinimum || void 0 !== t.maximum || void 0 !== t.exclusiveMaximum || void 0 !== t.multipleOf;
            }
            function L(t) {
                return "string" === t.type || void 0 !== t.minLength || void 0 !== t.maxLength || void 0 !== t.pattern || void 0 !== t.format || void 0 !== t.formatMinimum || void 0 !== t.formatMaximum;
            }
            function B(t) {
                return "boolean" === t.type;
            }
            function C(t) {
                return "array" === t.type || "number" == typeof t.minItems || "number" == typeof t.maxItems || void 0 !== t.uniqueItems || void 0 !== t.items || void 0 !== t.additionalItems || void 0 !== t.contains;
            }
            function H(t) {
                return "object" === t.type || void 0 !== t.minProperties || void 0 !== t.maxProperties || void 0 !== t.required || void 0 !== t.properties || void 0 !== t.patternProperties || void 0 !== t.additionalProperties || void 0 !== t.dependencies || void 0 !== t.propertyNames || void 0 !== t.patternRequired;
            }
            function z(t) {
                return "null" === t.type;
            }
            function K(t) {
                return /^[aeiou]/i.test(t) ? "an" : "a";
            }
            function U(t) {
                if (!t) return "";
                if (!t.type) {
                    if (V(t) || F(t)) return " | should be any non-number";
                    if (L(t)) return " | should be any non-string";
                    if (C(t)) return " | should be any non-array";
                    if (H(t)) return " | should be any non-object";
                }
                return "";
            }
            function G(t) {
                return t.length > 0 ? "(".concat(t.join(", "), ")") : "";
            }
            function Q(t, e) {
                return V(t) || F(t) ? I(t, e) : L(t) ? D(t, e) : [];
            }
            var W = function(e) {
                f(r, g(Error));
                var n = d(r);
                function r(t, e) {
                    var a, c, i, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (h(this, r), (a = n.call(this)).name = "ValidationError", a.errors = t, a.schema = e, e.title && (!s.name || !s.baseDataPath)) {
                        var u = e.title.match(/^(.+) (.+)$/);
                        if (u) {
                            if (!s.name) c = o(u, 2)[1];
                            if (!s.baseDataPath) i = o(u, 3)[2];
                        }
                    }
                    a.headerName = s.name || c || "Object", a.baseDataPath = s.baseDataPath || i || "configuration", a.postFormatter = s.postFormatter || null;
                    var m = "Invalid ".concat(a.baseDataPath, " object. ").concat(a.headerName, " has been initialized using ").concat(K(a.baseDataPath), " ").concat(a.baseDataPath, " object that does not match the API schema.\n");
                    return a.message = "".concat(m).concat(a.formatValidationErrors(t)), Error.captureStackTrace(v(a), a.constructor), a;
                }
                return l(r, [
                    {
                        key: "getSchemaPart",
                        value: function(t) {
                            for(var e = t.split("/"), n = this.schema, a = 1; a < e.length; a++){
                                var r = n[e[a]];
                                if (!r) break;
                                n = r;
                            }
                            return n;
                        }
                    },
                    {
                        key: "formatSchema",
                        value: function(e) {
                            var n = this, r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], c = r, i = function(t, a) {
                                return a ? o.includes(t) ? "(recursive)" : n.formatSchema(t, c, o.concat(e)) : n.formatSchema(t, c, o);
                            };
                            if (R(e) && !H(e)) {
                                if ($(e.not)) return c = !r, i(e.not);
                                var s = !e.not.not;
                                return c = !r, s ? (r ? "" : "non ") + i(e.not) : i(e.not);
                            }
                            if (e.instanceof) {
                                var u = e.instanceof;
                                return (Array.isArray(u) ? u : [
                                    u
                                ]).map(function(t) {
                                    return "Function" === t ? "function" : t;
                                }).join(" | ");
                            }
                            if (e.enum) return e.enum.map(function(t) {
                                return JSON.stringify(t);
                            }).join(" | ");
                            if (void 0 !== e.const) return JSON.stringify(e.const);
                            if (e.oneOf) return e.oneOf.map(function(t) {
                                return i(t, !0);
                            }).join(" | ");
                            if (e.anyOf) return e.anyOf.map(function(t) {
                                return i(t, !0);
                            }).join(" | ");
                            if (e.allOf) return e.allOf.map(function(t) {
                                return i(t, !0);
                            }).join(" & ");
                            if (e.if) {
                                var m = e.if, h = e.then, p = e.else;
                                return "".concat(m ? "if ".concat(i(m)) : "").concat(h ? " then ".concat(i(h)) : "").concat(p ? " else ".concat(i(p)) : "");
                            }
                            if (e.$ref) return i(this.getSchemaPart(e.$ref), !0);
                            if (V(e) || F(e)) {
                                var l = a(Q(e, r)), f = l[0], d = l.slice(1), y = "".concat(f).concat(d.length > 0 ? " ".concat(G(d)) : "");
                                return r ? y : d.length > 0 ? "non-".concat(f, " | ").concat(y) : "non-".concat(f);
                            }
                            if (L(e)) {
                                var v = a(Q(e, r)), g = v[0], b = v.slice(1), S = "".concat(g).concat(b.length > 0 ? " ".concat(G(b)) : "");
                                return r ? S : "string" === S ? "non-string" : "non-string | ".concat(S);
                            }
                            if (B(e)) return "".concat(r ? "" : "non-", "boolean");
                            if (C(e)) {
                                c = !0;
                                var P = [];
                                "number" == typeof e.minItems && P.push("should not have fewer than ".concat(e.minItems, " item").concat(e.minItems > 1 ? "s" : "")), "number" == typeof e.maxItems && P.push("should not have more than ".concat(e.maxItems, " item").concat(e.maxItems > 1 ? "s" : "")), e.uniqueItems && P.push("should not have duplicate items");
                                var x = void 0 === e.additionalItems || Boolean(e.additionalItems), O = "";
                                return e.items ? Array.isArray(e.items) && e.items.length > 0 ? (O = "".concat(e.items.map(function(t) {
                                    return i(t);
                                }).join(", ")), x && e.additionalItems && _(e.additionalItems) && Object.keys(e.additionalItems).length > 0 && P.push("additional items should be ".concat(i(e.additionalItems)))) : O = e.items && Object.keys(e.items).length > 0 ? "".concat(i(e.items)) : "any" : O = "any", e.contains && Object.keys(e.contains).length > 0 && P.push("should contains at least one ".concat(this.formatSchema(e.contains), " item")), "[".concat(O).concat(x ? ", ..." : "", "]").concat(P.length > 0 ? " (".concat(P.join(", "), ")") : "");
                            }
                            if (H(e)) {
                                c = !0;
                                var j = [];
                                if ("number" == typeof e.minProperties && j.push("should not have fewer than ".concat(e.minProperties, " ").concat(e.minProperties > 1 ? "properties" : "property")), "number" == typeof e.maxProperties && j.push("should not have more than ".concat(e.maxProperties, " ").concat(e.minProperties && e.minProperties > 1 ? "properties" : "property")), e.patternProperties && Object.keys(e.patternProperties).length > 0) {
                                    var w = Object.keys(e.patternProperties);
                                    j.push("additional property names should match pattern".concat(w.length > 1 ? "s" : "", " ").concat(w.map(function(t) {
                                        return JSON.stringify(t);
                                    }).join(" | ")));
                                }
                                var D = e.properties ? Object.keys(e.properties) : [], I = e.required ? e.required : [], T = t(new Set([].concat(I).concat(D))).map(function(t) {
                                    var e = I.includes(t);
                                    return "".concat(t).concat(e ? "" : "?");
                                }).concat(void 0 === e.additionalProperties || Boolean(e.additionalProperties) ? e.additionalProperties && _(e.additionalProperties) ? [
                                    "<key>: ".concat(i(e.additionalProperties))
                                ] : [
                                    ""
                                ] : []).join(", "), k = e.dependencies, A = e.propertyNames, N = e.patternRequired;
                                return k && Object.keys(k).forEach(function(t) {
                                    var e = k[t];
                                    Array.isArray(e) ? j.push("should have ".concat(e.length > 1 ? "properties" : "property", " ").concat(e.map(function(t) {
                                        return "'".concat(t, "'");
                                    }).join(", "), " when property '").concat(t, "' is present")) : j.push("should be valid according to the schema ".concat(i(e), " when property '").concat(t, "' is present"));
                                }), A && Object.keys(A).length > 0 && j.push("each property name should match format ".concat(JSON.stringify(e.propertyNames.format))), N && N.length > 0 && j.push("should have property matching pattern ".concat(N.map(function(t) {
                                    return JSON.stringify(t);
                                }))), "object {".concat(T ? " ".concat(T, " ") : "", "}").concat(j.length > 0 ? " (".concat(j.join(", "), ")") : "");
                            }
                            return z(e) ? "".concat(r ? "" : "non-", "null") : Array.isArray(e.type) ? "".concat(e.type.join(" | ")) : JSON.stringify(e, null, 2);
                        }
                    },
                    {
                        key: "getSchemaPartText",
                        value: function(t, e) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                            if (!t) return "";
                            if (Array.isArray(e)) for(var r = 0; r < e.length; r++){
                                var o = t[e[r]];
                                if (!o) break;
                                t = o;
                            }
                            for(; t.$ref;)t = this.getSchemaPart(t.$ref);
                            var c = "".concat(this.formatSchema(t, a)).concat(n ? "." : "");
                            return t.description && (c += "\n-> ".concat(t.description)), t.link && (c += "\n-> Read more at ".concat(t.link)), c;
                        }
                    },
                    {
                        key: "getSchemaPartDescription",
                        value: function(t) {
                            if (!t) return "";
                            for(; t.$ref;)t = this.getSchemaPart(t.$ref);
                            var e = "";
                            return t.description && (e += "\n-> ".concat(t.description)), t.link && (e += "\n-> Read more at ".concat(t.link)), e;
                        }
                    },
                    {
                        key: "formatValidationError",
                        value: function(t) {
                            var e = this, n = t.keyword, r = t.dataPath, o = "".concat(this.baseDataPath).concat(r);
                            switch(n){
                                case "type":
                                    var c = t.parentSchema;
                                    switch(t.params.type){
                                        case "number":
                                            return "".concat(o, " should be a ").concat(this.getSchemaPartText(c, !1, !0));
                                        case "integer":
                                            return "".concat(o, " should be an ").concat(this.getSchemaPartText(c, !1, !0));
                                        case "string":
                                        case "boolean":
                                            return "".concat(o, " should be a ").concat(this.getSchemaPartText(c, !1, !0));
                                        case "array":
                                            return "".concat(o, " should be an array:\n").concat(this.getSchemaPartText(c));
                                        case "object":
                                            return "".concat(o, " should be an object:\n").concat(this.getSchemaPartText(c));
                                        case "null":
                                            return "".concat(o, " should be a ").concat(this.getSchemaPartText(c, !1, !0));
                                        default:
                                            return "".concat(o, " should be:\n").concat(this.getSchemaPartText(c));
                                    }
                                case "instanceof":
                                    var i = t.parentSchema;
                                    return "".concat(o, " should be an instance of ").concat(this.getSchemaPartText(i, !1, !0));
                                case "pattern":
                                    var s = t.params, u = t.parentSchema, m = s.pattern;
                                    return "".concat(o, " should match pattern ").concat(JSON.stringify(m)).concat(U(u), ".").concat(this.getSchemaPartDescription(u));
                                case "format":
                                    var h = t.params, p = t.parentSchema, l = h.format;
                                    return "".concat(o, " should match format ").concat(JSON.stringify(l)).concat(U(p), ".").concat(this.getSchemaPartDescription(p));
                                case "formatMinimum":
                                case "formatMaximum":
                                    var f = t.params, d = t.parentSchema, y = f.comparison, v = f.limit;
                                    return "".concat(o, " should be ").concat(y, " ").concat(JSON.stringify(v)).concat(U(d), ".").concat(this.getSchemaPartDescription(d));
                                case "minimum":
                                case "maximum":
                                case "exclusiveMinimum":
                                case "exclusiveMaximum":
                                    var g = t.parentSchema, b = t.params, S = b.comparison, P = b.limit, x = a(Q(g, !0)).slice(1);
                                    return 0 === x.length && x.push("should be ".concat(S, " ").concat(P)), "".concat(o, " ").concat(x.join(" ")).concat(U(g), ".").concat(this.getSchemaPartDescription(g));
                                case "multipleOf":
                                    var O = t.params, j = t.parentSchema, w = O.multipleOf;
                                    return "".concat(o, " should be multiple of ").concat(w).concat(U(j), ".").concat(this.getSchemaPartDescription(j));
                                case "patternRequired":
                                    var D = t.params, I = t.parentSchema, T = D.missingPattern;
                                    return "".concat(o, " should have property matching pattern ").concat(JSON.stringify(T)).concat(U(I), ".").concat(this.getSchemaPartDescription(I));
                                case "minLength":
                                    var k = t.params, N = t.parentSchema, M = k.limit;
                                    if (1 === M) return "".concat(o, " should be a non-empty string").concat(U(N), ".").concat(this.getSchemaPartDescription(N));
                                    var R = M - 1;
                                    return "".concat(o, " should be longer than ").concat(R, " character").concat(R > 1 ? "s" : "").concat(U(N), ".").concat(this.getSchemaPartDescription(N));
                                case "minItems":
                                    var J = t.params, _ = t.parentSchema, V = J.limit;
                                    return 1 === V ? "".concat(o, " should be a non-empty array").concat(U(_), ".").concat(this.getSchemaPartDescription(_)) : "".concat(o, " should not have fewer than ").concat(V, " items").concat(U(_), ".").concat(this.getSchemaPartDescription(_));
                                case "minProperties":
                                    var F = t.params, L = t.parentSchema, B = F.limit;
                                    return 1 === B ? "".concat(o, " should be a non-empty object").concat(U(L), ".").concat(this.getSchemaPartDescription(L)) : "".concat(o, " should not have fewer than ").concat(B, " properties").concat(U(L), ".").concat(this.getSchemaPartDescription(L));
                                case "maxLength":
                                    var C = t.params, z = t.parentSchema, K = C.limit + 1;
                                    return "".concat(o, " should be shorter than ").concat(K, " character").concat(K > 1 ? "s" : "").concat(U(z), ".").concat(this.getSchemaPartDescription(z));
                                case "maxItems":
                                    var G = t.params, W = t.parentSchema, X = G.limit;
                                    return "".concat(o, " should not have more than ").concat(X, " items").concat(U(W), ".").concat(this.getSchemaPartDescription(W));
                                case "maxProperties":
                                    var Y = t.params, Z = t.parentSchema, tt = Y.limit;
                                    return "".concat(o, " should not have more than ").concat(tt, " properties").concat(U(Z), ".").concat(this.getSchemaPartDescription(Z));
                                case "uniqueItems":
                                    var et = t.params, nt = t.parentSchema, at = et.i;
                                    return "".concat(o, " should not contain the item '").concat(t.data[at], "' twice").concat(U(nt), ".").concat(this.getSchemaPartDescription(nt));
                                case "additionalItems":
                                    var rt = t.params, ot = t.parentSchema, ct = rt.limit;
                                    return "".concat(o, " should not have more than ").concat(ct, " items").concat(U(ot), ". These items are valid:\n").concat(this.getSchemaPartText(ot));
                                case "contains":
                                    var it = t.parentSchema;
                                    return "".concat(o, " should contains at least one ").concat(this.getSchemaPartText(it, [
                                        "contains"
                                    ]), " item").concat(U(it), ".");
                                case "required":
                                    var st = t.parentSchema, ut = t.params.missingProperty.replace(/^\./, ""), mt = st && Boolean(st.properties && st.properties[ut]);
                                    return "".concat(o, " misses the property '").concat(ut, "'").concat(U(st), ".").concat(mt ? " Should be:\n".concat(this.getSchemaPartText(st, [
                                        "properties",
                                        ut
                                    ])) : this.getSchemaPartDescription(st));
                                case "additionalProperties":
                                    var ht = t.params, pt = t.parentSchema, lt = ht.additionalProperty;
                                    return "".concat(o, " has an unknown property '").concat(lt, "'").concat(U(pt), ". These properties are valid:\n").concat(this.getSchemaPartText(pt));
                                case "dependencies":
                                    var ft = t.params, dt = t.parentSchema, yt = ft.property, vt = ft.deps.split(",").map(function(t) {
                                        return "'".concat(t.trim(), "'");
                                    }).join(", ");
                                    return "".concat(o, " should have properties ").concat(vt, " when property '").concat(yt, "' is present").concat(U(dt), ".").concat(this.getSchemaPartDescription(dt));
                                case "propertyNames":
                                    var gt = t.params, bt = t.parentSchema, St = t.schema, Pt = gt.propertyName;
                                    return "".concat(o, " property name '").concat(Pt, "' is invalid").concat(U(bt), ". Property names should be match format ").concat(JSON.stringify(St.format), ".").concat(this.getSchemaPartDescription(bt));
                                case "enum":
                                    var xt = t.parentSchema;
                                    return xt && xt.enum && 1 === xt.enum.length ? "".concat(o, " should be ").concat(this.getSchemaPartText(xt, !1, !0)) : "".concat(o, " should be one of these:\n").concat(this.getSchemaPartText(xt));
                                case "const":
                                    var Ot = t.parentSchema;
                                    return "".concat(o, " should be equal to constant ").concat(this.getSchemaPartText(Ot, !1, !0));
                                case "not":
                                    var jt = H(t.parentSchema) ? "\n".concat(this.getSchemaPartText(t.parentSchema)) : "", wt = this.getSchemaPartText(t.schema, !1, !1, !1);
                                    if ($(t.schema)) return "".concat(o, " should be any ").concat(wt).concat(jt, ".");
                                    var Dt = t.schema, It = t.parentSchema;
                                    return "".concat(o, " should not be ").concat(this.getSchemaPartText(Dt, !1, !0)).concat(It && H(It) ? "\n".concat(this.getSchemaPartText(It)) : "");
                                case "oneOf":
                                case "anyOf":
                                    var Tt = t.parentSchema, kt = t.children;
                                    if (kt && kt.length > 0) {
                                        if (1 === t.schema.length) {
                                            var At = kt[kt.length - 1], Nt = kt.slice(0, kt.length - 1);
                                            return this.formatValidationError(Object.assign({}, At, {
                                                children: Nt,
                                                parentSchema: Object.assign({}, Tt, At.parentSchema)
                                            }));
                                        }
                                        var Mt = A(kt);
                                        return 1 === Mt.length ? this.formatValidationError(Mt[0]) : (Mt = E(Mt), "".concat(o, " should be one of these:\n").concat(this.getSchemaPartText(Tt), "\nDetails:\n").concat(Mt.map(function(t) {
                                            return " * ".concat(q(e.formatValidationError(t), "   "));
                                        }).join("\n")));
                                    }
                                    return "".concat(o, " should be one of these:\n").concat(this.getSchemaPartText(Tt));
                                case "if":
                                    var Et = t.params, qt = t.parentSchema, Rt = Et.failingKeyword;
                                    return "".concat(o, ' should match "').concat(Rt, '" schema:\n').concat(this.getSchemaPartText(qt, [
                                        Rt
                                    ]));
                                case "absolutePath":
                                    var Jt = t.message, $t = t.parentSchema;
                                    return "".concat(o, ": ").concat(Jt).concat(this.getSchemaPartDescription($t));
                                default:
                                    var _t = t.message, Vt = t.parentSchema, Ft = JSON.stringify(t, null, 2);
                                    return "".concat(o, " ").concat(_t, " (").concat(Ft, ").\n").concat(this.getSchemaPartText(Vt, !1));
                            }
                        }
                    },
                    {
                        key: "formatValidationErrors",
                        value: function(t) {
                            var e = this;
                            return t.map(function(t) {
                                var n = e.formatValidationError(t);
                                return e.postFormatter && (n = e.postFormatter(n, t)), " - ".concat(q(n, "   "));
                            }).join("\n");
                        }
                    }
                ]), r;
            }(), X = W;
            exports.default = X;
        },
        {
            "./util/hints": "SqDh"
        }
    ],
    "wWOq": [
        function(require1, module1, exports) {
            var define;
            var global = arguments[3];
            var e, r = arguments[3];
            !function(r, t) {
                "object" == typeof exports && "undefined" != typeof module1 ? t(exports) : "function" == typeof e && e.amd ? e([
                    "exports"
                ], t) : t(r.URI = r.URI || {});
            }(this, function(e) {
                "use strict";
                function r() {
                    for(var e = arguments.length, r = Array(e), t = 0; t < e; t++)r[t] = arguments[t];
                    if (r.length > 1) {
                        r[0] = r[0].slice(0, -1);
                        for(var n = r.length - 1, o = 1; o < n; ++o)r[o] = r[o].slice(1, -1);
                        return r[n] = r[n].slice(1), r.join("");
                    }
                    return r[0];
                }
                function t(e) {
                    return "(?:" + e + ")";
                }
                function n(e) {
                    return void 0 === e ? "undefined" : null === e ? "null" : Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase();
                }
                function o(e) {
                    return e.toUpperCase();
                }
                function a(e) {
                    var n = r("[0-9]", "[A-Fa-f]"), o = t(t("%[EFef]" + n + "%" + n + n + "%" + n + n) + "|" + t("%[89A-Fa-f]" + n + "%" + n + n) + "|" + t("%" + n + n)), a = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", i = r("[\\:\\/\\?\\#\\[\\]\\@]", a), s = e ? "[\\uE000-\\uF8FF]" : "[]", u = r("[A-Za-z]", "[0-9]", "[\\-\\.\\_\\~]", e ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), c = t("[A-Za-z]" + r("[A-Za-z]", "[0-9]", "[\\+\\-\\.]") + "*"), p = t(t(o + "|" + r(u, a, "[\\:]")) + "*"), h = (t(t("25[0-5]") + "|" + t("2[0-4][0-9]") + "|" + t("1[0-9][0-9]") + "|" + t("[1-9][0-9]") + "|[0-9]"), t(t("25[0-5]") + "|" + t("2[0-4][0-9]") + "|" + t("1[0-9][0-9]") + "|" + t("0?[1-9][0-9]") + "|0?0?[0-9]")), f = t(h + "\\." + h + "\\." + h + "\\." + h), l = t(n + "{1,4}"), v = t(t(l + "\\:" + l) + "|" + f), d = t(t(l + "\\:") + "{6}" + v), g = t("\\:\\:" + t(l + "\\:") + "{5}" + v), m = t(t(l) + "?\\:\\:" + t(l + "\\:") + "{4}" + v), E = t(t(t(l + "\\:") + "{0,1}" + l) + "?\\:\\:" + t(l + "\\:") + "{3}" + v), C = t(t(t(l + "\\:") + "{0,2}" + l) + "?\\:\\:" + t(l + "\\:") + "{2}" + v), y = t(t(t(l + "\\:") + "{0,3}" + l) + "?\\:\\:" + l + "\\:" + v), S = t(t(t(l + "\\:") + "{0,4}" + l) + "?\\:\\:" + v), A = t(t(t(l + "\\:") + "{0,5}" + l) + "?\\:\\:" + l), D = t(t(t(l + "\\:") + "{0,6}" + l) + "?\\:\\:"), w = t([
                        d,
                        g,
                        m,
                        E,
                        C,
                        y,
                        S,
                        A,
                        D
                    ].join("|")), b = t(t(u + "|" + o) + "+"), x = (t(w + "\\%25" + b), t(w + t("\\%25|\\%(?!" + n + "{2})") + b)), O = t("[vV]" + n + "+\\." + r(u, a, "[\\:]") + "+"), I = t("\\[" + t(x + "|" + w + "|" + O) + "\\]"), F = t(t(o + "|" + r(u, a)) + "*"), N = t(I + "|" + f + "(?!" + F + ")|" + F), R = t("[0-9]*"), T = t(t(p + "@") + "?" + N + t("\\:" + R) + "?"), _ = t(o + "|" + r(u, a, "[\\:\\@]")), P = t(_ + "*"), U = t(_ + "+"), j = t(t(o + "|" + r(u, a, "[\\@]")) + "+"), q = t(t("\\/" + P) + "*"), H = t("\\/" + t(U + q) + "?"), z = t(j + q), L = t(U + q), $ = "(?!" + _ + ")", V = (t(q + "|" + H + "|" + z + "|" + L + "|" + $), t(t(_ + "|" + r("[\\/\\?]", s)) + "*")), M = t(t(_ + "|[\\/\\?]") + "*"), Z = t(t("\\/\\/" + T + q) + "|" + H + "|" + L + "|" + $), k = t(c + "\\:" + Z + t("\\?" + V) + "?" + t("\\#" + M) + "?"), G = t(t("\\/\\/" + T + q) + "|" + H + "|" + z + "|" + $), Q = t(G + t("\\?" + V) + "?" + t("\\#" + M) + "?");
                    t(k + "|" + Q), t(c + "\\:" + Z + t("\\?" + V) + "?"), t(t("\\/\\/(" + t("(" + p + ")@") + "?(" + N + ")" + t("\\:(" + R + ")") + "?)") + "?(" + q + "|" + H + "|" + L + "|" + $ + ")"), t("\\?(" + V + ")"), t("\\#(" + M + ")"), t(t("\\/\\/(" + t("(" + p + ")@") + "?(" + N + ")" + t("\\:(" + R + ")") + "?)") + "?(" + q + "|" + H + "|" + z + "|" + $ + ")"), t("\\?(" + V + ")"), t("\\#(" + M + ")"), t(t("\\/\\/(" + t("(" + p + ")@") + "?(" + N + ")" + t("\\:(" + R + ")") + "?)") + "?(" + q + "|" + H + "|" + L + "|" + $ + ")"), t("\\?(" + V + ")"), t("\\#(" + M + ")"), t("(" + p + ")@"), t("\\:(" + R + ")");
                    return {
                        NOT_SCHEME: new RegExp(r("[^]", "[A-Za-z]", "[0-9]", "[\\+\\-\\.]"), "g"),
                        NOT_USERINFO: new RegExp(r("[^\\%\\:]", u, a), "g"),
                        NOT_HOST: new RegExp(r("[^\\%\\[\\]\\:]", u, a), "g"),
                        NOT_PATH: new RegExp(r("[^\\%\\/\\:\\@]", u, a), "g"),
                        NOT_PATH_NOSCHEME: new RegExp(r("[^\\%\\/\\@]", u, a), "g"),
                        NOT_QUERY: new RegExp(r("[^\\%]", u, a, "[\\:\\@\\/\\?]", s), "g"),
                        NOT_FRAGMENT: new RegExp(r("[^\\%]", u, a, "[\\:\\@\\/\\?]"), "g"),
                        ESCAPE: new RegExp(r("[^]", u, a), "g"),
                        UNRESERVED: new RegExp(u, "g"),
                        OTHER_CHARS: new RegExp(r("[^\\%]", u, i), "g"),
                        PCT_ENCODED: new RegExp(o, "g"),
                        IPV4ADDRESS: new RegExp("^(" + f + ")$"),
                        IPV6ADDRESS: new RegExp("^\\[?(" + w + ")" + t(t("\\%25|\\%(?!" + n + "{2})") + "(" + b + ")") + "?\\]?$")
                    };
                }
                var i = a(!1), s = a(!0), u = function() {
                    return function(e, r) {
                        if (Array.isArray(e)) return e;
                        if (Symbol.iterator in Object(e)) return function(e, r) {
                            var t = [], n = !0, o = !1, a = void 0;
                            try {
                                for(var i, s = e[Symbol.iterator](); !(n = (i = s.next()).done) && (t.push(i.value), !r || t.length !== r); n = !0);
                            } catch (u) {
                                o = !0, a = u;
                            } finally{
                                try {
                                    !n && s.return && s.return();
                                } finally{
                                    if (o) throw a;
                                }
                            }
                            return t;
                        }(e, r);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    };
                }(), c = 2147483647, p = /^xn--/, h = /[^\0-\x7E]/, f = /[\x2E\u3002\uFF0E\uFF61]/g, l = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, v = Math.floor, d = String.fromCharCode;
                function g(e) {
                    throw new RangeError(l[e]);
                }
                function m(e, r) {
                    var t = e.split("@"), n = "";
                    t.length > 1 && (n = t[0] + "@", e = t[1]);
                    var o = (function(e, r) {
                        for(var t = [], n = e.length; n--;)t[n] = r(e[n]);
                        return t;
                    })((e = e.replace(f, ".")).split("."), r).join(".");
                    return n + o;
                }
                function E(e) {
                    for(var r = [], t = 0, n = e.length; t < n;){
                        var o = e.charCodeAt(t++);
                        if (o >= 55296 && o <= 56319 && t < n) {
                            var a = e.charCodeAt(t++);
                            56320 == (64512 & a) ? r.push(((1023 & o) << 10) + (1023 & a) + 65536) : (r.push(o), t--);
                        } else r.push(o);
                    }
                    return r;
                }
                var C = function(e, r) {
                    return e + 22 + 75 * (e < 26) - ((0 != r) << 5);
                }, y = function(e, r, t) {
                    var n = 0;
                    for(e = t ? v(e / 700) : e >> 1, e += v(e / r); e > 455; n += 36)e = v(e / 35);
                    return v(n + 36 * e / (e + 38));
                }, S = function(e) {
                    var r, t = [], n = e.length, o = 0, a = 128, i = 72, s = e.lastIndexOf("-");
                    s < 0 && (s = 0);
                    for(var u = 0; u < s; ++u)e.charCodeAt(u) >= 128 && g("not-basic"), t.push(e.charCodeAt(u));
                    for(var p = s > 0 ? s + 1 : 0; p < n;){
                        for(var h = o, f = 1, l = 36;; l += 36){
                            p >= n && g("invalid-input");
                            var d = (r = e.charCodeAt(p++)) - 48 < 10 ? r - 22 : r - 65 < 26 ? r - 65 : r - 97 < 26 ? r - 97 : 36;
                            (d >= 36 || d > v((c - o) / f)) && g("overflow"), o += d * f;
                            var m = l <= i ? 1 : l >= i + 26 ? 26 : l - i;
                            if (d < m) break;
                            var E = 36 - m;
                            f > v(c / E) && g("overflow"), f *= E;
                        }
                        var C = t.length + 1;
                        i = y(o - h, C, 0 == h), v(o / C) > c - a && g("overflow"), a += v(o / C), o %= C, t.splice(o++, 0, a);
                    }
                    return String.fromCodePoint.apply(String, t);
                }, A = function(e) {
                    var r = [], t = (e = E(e)).length, n = 128, o = 0, a = 72, i = !0, s = !1, u = void 0;
                    try {
                        for(var p, h = e[Symbol.iterator](); !(i = (p = h.next()).done); i = !0){
                            var f = p.value;
                            f < 128 && r.push(d(f));
                        }
                    } catch (L) {
                        s = !0, u = L;
                    } finally{
                        try {
                            !i && h.return && h.return();
                        } finally{
                            if (s) throw u;
                        }
                    }
                    var l = r.length, m = l;
                    for(l && r.push("-"); m < t;){
                        var S = c, A = !0, D = !1, w = void 0;
                        try {
                            for(var b, x = e[Symbol.iterator](); !(A = (b = x.next()).done); A = !0){
                                var O = b.value;
                                O >= n && O < S && (S = O);
                            }
                        } catch (L) {
                            D = !0, w = L;
                        } finally{
                            try {
                                !A && x.return && x.return();
                            } finally{
                                if (D) throw w;
                            }
                        }
                        var I = m + 1;
                        S - n > v((c - o) / I) && g("overflow"), o += (S - n) * I, n = S;
                        var F = !0, N = !1, R = void 0;
                        try {
                            for(var T, _ = e[Symbol.iterator](); !(F = (T = _.next()).done); F = !0){
                                var P = T.value;
                                if (P < n && ++o > c && g("overflow"), P == n) {
                                    for(var U = o, j = 36;; j += 36){
                                        var q = j <= a ? 1 : j >= a + 26 ? 26 : j - a;
                                        if (U < q) break;
                                        var H = U - q, z = 36 - q;
                                        r.push(d(C(q + H % z, 0))), U = v(H / z);
                                    }
                                    r.push(d(C(U, 0))), a = y(o, I, m == l), o = 0, ++m;
                                }
                            }
                        } catch (L) {
                            N = !0, R = L;
                        } finally{
                            try {
                                !F && _.return && _.return();
                            } finally{
                                if (N) throw R;
                            }
                        }
                        ++o, ++n;
                    }
                    return r.join("");
                }, D = {
                    version: "2.1.0",
                    ucs2: {
                        decode: E,
                        encode: function(e) {
                            return String.fromCodePoint.apply(String, function(e) {
                                if (Array.isArray(e)) {
                                    for(var r = 0, t = Array(e.length); r < e.length; r++)t[r] = e[r];
                                    return t;
                                }
                                return Array.from(e);
                            }(e));
                        }
                    },
                    decode: S,
                    encode: A,
                    toASCII: function(e) {
                        return m(e, function(e) {
                            return h.test(e) ? "xn--" + A(e) : e;
                        });
                    },
                    toUnicode: function(e) {
                        return m(e, function(e) {
                            return p.test(e) ? S(e.slice(4).toLowerCase()) : e;
                        });
                    }
                }, w = {};
                function b(e) {
                    var r = e.charCodeAt(0);
                    return r < 16 ? "%0" + r.toString(16).toUpperCase() : r < 128 ? "%" + r.toString(16).toUpperCase() : r < 2048 ? "%" + (r >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & r | 128).toString(16).toUpperCase() : "%" + (r >> 12 | 224).toString(16).toUpperCase() + "%" + (r >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & r | 128).toString(16).toUpperCase();
                }
                function x(e) {
                    for(var r = "", t = 0, n = e.length; t < n;){
                        var o = parseInt(e.substr(t + 1, 2), 16);
                        if (o < 128) r += String.fromCharCode(o), t += 3;
                        else if (o >= 194 && o < 224) {
                            if (n - t >= 6) {
                                var a = parseInt(e.substr(t + 4, 2), 16);
                                r += String.fromCharCode((31 & o) << 6 | 63 & a);
                            } else r += e.substr(t, 6);
                            t += 6;
                        } else if (o >= 224) {
                            if (n - t >= 9) {
                                var i = parseInt(e.substr(t + 4, 2), 16), s = parseInt(e.substr(t + 7, 2), 16);
                                r += String.fromCharCode((15 & o) << 12 | (63 & i) << 6 | 63 & s);
                            } else r += e.substr(t, 9);
                            t += 9;
                        } else r += e.substr(t, 3), t += 3;
                    }
                    return r;
                }
                function O(e, r) {
                    function t(e) {
                        var t = x(e);
                        return t.match(r.UNRESERVED) ? t : e;
                    }
                    return e.scheme && (e.scheme = String(e.scheme).replace(r.PCT_ENCODED, t).toLowerCase().replace(r.NOT_SCHEME, "")), void 0 !== e.userinfo && (e.userinfo = String(e.userinfo).replace(r.PCT_ENCODED, t).replace(r.NOT_USERINFO, b).replace(r.PCT_ENCODED, o)), void 0 !== e.host && (e.host = String(e.host).replace(r.PCT_ENCODED, t).toLowerCase().replace(r.NOT_HOST, b).replace(r.PCT_ENCODED, o)), void 0 !== e.path && (e.path = String(e.path).replace(r.PCT_ENCODED, t).replace(e.scheme ? r.NOT_PATH : r.NOT_PATH_NOSCHEME, b).replace(r.PCT_ENCODED, o)), void 0 !== e.query && (e.query = String(e.query).replace(r.PCT_ENCODED, t).replace(r.NOT_QUERY, b).replace(r.PCT_ENCODED, o)), void 0 !== e.fragment && (e.fragment = String(e.fragment).replace(r.PCT_ENCODED, t).replace(r.NOT_FRAGMENT, b).replace(r.PCT_ENCODED, o)), e;
                }
                function I(e) {
                    return e.replace(/^0*(.*)/, "$1") || "0";
                }
                function F(e, r) {
                    var t = e.match(r.IPV4ADDRESS) || [], n = u(t, 2)[1];
                    return n ? n.split(".").map(I).join(".") : e;
                }
                function N(e, r) {
                    var t = e.match(r.IPV6ADDRESS) || [], n = u(t, 3), o = n[1], a = n[2];
                    if (o) {
                        for(var i = o.toLowerCase().split("::").reverse(), s = u(i, 2), c = s[0], p = s[1], h = p ? p.split(":").map(I) : [], f = c.split(":").map(I), l = r.IPV4ADDRESS.test(f[f.length - 1]), v = l ? 7 : 8, d = f.length - v, g = Array(v), m = 0; m < v; ++m)g[m] = h[m] || f[d + m] || "";
                        l && (g[v - 1] = F(g[v - 1], r));
                        var E = g.reduce(function(e, r, t) {
                            if (!r || "0" === r) {
                                var n = e[e.length - 1];
                                n && n.index + n.length === t ? n.length++ : e.push({
                                    index: t,
                                    length: 1
                                });
                            }
                            return e;
                        }, []).sort(function(e, r) {
                            return r.length - e.length;
                        })[0], C = void 0;
                        if (E && E.length > 1) {
                            var y = g.slice(0, E.index), S = g.slice(E.index + E.length);
                            C = y.join(":") + "::" + S.join(":");
                        } else C = g.join(":");
                        return a && (C += "%" + a), C;
                    }
                    return e;
                }
                var R = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, T = void 0 === "".match(/(){0}/)[1];
                function _(e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t = {}, n = !1 !== r.iri ? s : i;
                    "suffix" === r.reference && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e);
                    var o = e.match(R);
                    if (o) {
                        T ? (t.scheme = o[1], t.userinfo = o[3], t.host = o[4], t.port = parseInt(o[5], 10), t.path = o[6] || "", t.query = o[7], t.fragment = o[8], isNaN(t.port) && (t.port = o[5])) : (t.scheme = o[1] || void 0, t.userinfo = -1 !== e.indexOf("@") ? o[3] : void 0, t.host = -1 !== e.indexOf("//") ? o[4] : void 0, t.port = parseInt(o[5], 10), t.path = o[6] || "", t.query = -1 !== e.indexOf("?") ? o[7] : void 0, t.fragment = -1 !== e.indexOf("#") ? o[8] : void 0, isNaN(t.port) && (t.port = e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? o[4] : void 0)), t.host && (t.host = N(F(t.host, n), n)), void 0 !== t.scheme || void 0 !== t.userinfo || void 0 !== t.host || void 0 !== t.port || t.path || void 0 !== t.query ? void 0 === t.scheme ? t.reference = "relative" : void 0 === t.fragment ? t.reference = "absolute" : t.reference = "uri" : t.reference = "same-document", r.reference && "suffix" !== r.reference && r.reference !== t.reference && (t.error = t.error || "URI is not a " + r.reference + " reference.");
                        var a = w[(r.scheme || t.scheme || "").toLowerCase()];
                        if (r.unicodeSupport || a && a.unicodeSupport) O(t, n);
                        else {
                            if (t.host && (r.domainHost || a && a.domainHost)) try {
                                t.host = D.toASCII(t.host.replace(n.PCT_ENCODED, x).toLowerCase());
                            } catch (u) {
                                t.error = t.error || "Host's domain name can not be converted to ASCII via punycode: " + u;
                            }
                            O(t, i);
                        }
                        a && a.parse && a.parse(t, r);
                    } else t.error = t.error || "URI can not be parsed.";
                    return t;
                }
                var P = /^\.\.?\//, U = /^\/\.(\/|$)/, j = /^\/\.\.(\/|$)/, q = /^\/?(?:.|\n)*?(?=\/|$)/;
                function H(e) {
                    for(var r = []; e.length;)if (e.match(P)) e = e.replace(P, "");
                    else if (e.match(U)) e = e.replace(U, "/");
                    else if (e.match(j)) e = e.replace(j, "/"), r.pop();
                    else if ("." === e || ".." === e) e = "";
                    else {
                        var t = e.match(q);
                        if (!t) throw new Error("Unexpected dot segment condition");
                        var n = t[0];
                        e = e.slice(n.length), r.push(n);
                    }
                    return r.join("");
                }
                function z(e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t = r.iri ? s : i, n = [], o = w[(r.scheme || e.scheme || "").toLowerCase()];
                    if (o && o.serialize && o.serialize(e, r), e.host) {
                        if (t.IPV6ADDRESS.test(e.host)) ;
                        else if (r.domainHost || o && o.domainHost) try {
                            e.host = r.iri ? D.toUnicode(e.host) : D.toASCII(e.host.replace(t.PCT_ENCODED, x).toLowerCase());
                        } catch (c) {
                            e.error = e.error || "Host's domain name can not be converted to " + (r.iri ? "Unicode" : "ASCII") + " via punycode: " + c;
                        }
                    }
                    O(e, t), "suffix" !== r.reference && e.scheme && (n.push(e.scheme), n.push(":"));
                    var a = function(e, r) {
                        var t = !1 !== r.iri ? s : i, n = [];
                        return void 0 !== e.userinfo && (n.push(e.userinfo), n.push("@")), void 0 !== e.host && n.push(N(F(String(e.host), t), t).replace(t.IPV6ADDRESS, function(e, r, t) {
                            return "[" + r + (t ? "%25" + t : "") + "]";
                        })), "number" == typeof e.port && (n.push(":"), n.push(e.port.toString(10))), n.length ? n.join("") : void 0;
                    }(e, r);
                    if (void 0 !== a && ("suffix" !== r.reference && n.push("//"), n.push(a), e.path && "/" !== e.path.charAt(0) && n.push("/")), void 0 !== e.path) {
                        var u = e.path;
                        r.absolutePath || o && o.absolutePath || (u = H(u)), void 0 === a && (u = u.replace(/^\/\//, "/%2F")), n.push(u);
                    }
                    return void 0 !== e.query && (n.push("?"), n.push(e.query)), void 0 !== e.fragment && (n.push("#"), n.push(e.fragment)), n.join("");
                }
                function L(e, r) {
                    var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = {};
                    return arguments[3] || (e = _(z(e, t), t), r = _(z(r, t), t)), !(t = t || {}).tolerant && r.scheme ? (n.scheme = r.scheme, n.userinfo = r.userinfo, n.host = r.host, n.port = r.port, n.path = H(r.path || ""), n.query = r.query) : (void 0 !== r.userinfo || void 0 !== r.host || void 0 !== r.port ? (n.userinfo = r.userinfo, n.host = r.host, n.port = r.port, n.path = H(r.path || ""), n.query = r.query) : (r.path ? ("/" === r.path.charAt(0) ? n.path = H(r.path) : (void 0 === e.userinfo && void 0 === e.host && void 0 === e.port || e.path ? e.path ? n.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + r.path : n.path = r.path : n.path = "/" + r.path, n.path = H(n.path)), n.query = r.query) : (n.path = e.path, void 0 !== r.query ? n.query = r.query : n.query = e.query), n.userinfo = e.userinfo, n.host = e.host, n.port = e.port), n.scheme = e.scheme), n.fragment = r.fragment, n;
                }
                function $(e, r) {
                    return e && e.toString().replace(r && r.iri ? s.PCT_ENCODED : i.PCT_ENCODED, x);
                }
                var V = {
                    scheme: "http",
                    domainHost: !0,
                    parse: function(e, r) {
                        return e.host || (e.error = e.error || "HTTP URIs must have a host."), e;
                    },
                    serialize: function(e, r) {
                        return e.port !== ("https" !== String(e.scheme).toLowerCase() ? 80 : 443) && "" !== e.port || (e.port = void 0), e.path || (e.path = "/"), e;
                    }
                }, M = {
                    scheme: "https",
                    domainHost: V.domainHost,
                    parse: V.parse,
                    serialize: V.serialize
                }, Z = {}, k = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", G = "[0-9A-Fa-f]", Q = t(t("%[EFef][0-9A-Fa-f]%" + G + G + "%" + G + G) + "|" + t("%[89A-Fa-f][0-9A-Fa-f]%" + G + G) + "|" + t("%" + G + G)), Y = r("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), B = new RegExp(k, "g"), J = new RegExp(Q, "g"), K = new RegExp(r("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', Y), "g"), W = new RegExp(r("[^]", k, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), X = W;
                function ee(e) {
                    var r = x(e);
                    return r.match(B) ? r : e;
                }
                var re = {
                    scheme: "mailto",
                    parse: function(e, r) {
                        var t = e, n = t.to = t.path ? t.path.split(",") : [];
                        if (t.path = void 0, t.query) {
                            for(var o = !1, a = {}, i = t.query.split("&"), s = 0, u = i.length; s < u; ++s){
                                var c = i[s].split("=");
                                switch(c[0]){
                                    case "to":
                                        for(var p = c[1].split(","), h = 0, f = p.length; h < f; ++h)n.push(p[h]);
                                        break;
                                    case "subject":
                                        t.subject = $(c[1], r);
                                        break;
                                    case "body":
                                        t.body = $(c[1], r);
                                        break;
                                    default:
                                        o = !0, a[$(c[0], r)] = $(c[1], r);
                                }
                            }
                            o && (t.headers = a);
                        }
                        t.query = void 0;
                        for(var l = 0, v = n.length; l < v; ++l){
                            var d = n[l].split("@");
                            if (d[0] = $(d[0]), r.unicodeSupport) d[1] = $(d[1], r).toLowerCase();
                            else try {
                                d[1] = D.toASCII($(d[1], r).toLowerCase());
                            } catch (g) {
                                t.error = t.error || "Email address's domain name can not be converted to ASCII via punycode: " + g;
                            }
                            n[l] = d.join("@");
                        }
                        return t;
                    },
                    serialize: function(e, r) {
                        var t, n = e, a = null != (t = e.to) ? t instanceof Array ? t : "number" != typeof t.length || t.split || t.setInterval || t.call ? [
                            t
                        ] : Array.prototype.slice.call(t) : [];
                        if (a) {
                            for(var i = 0, s = a.length; i < s; ++i){
                                var u = String(a[i]), c = u.lastIndexOf("@"), p = u.slice(0, c).replace(J, ee).replace(J, o).replace(K, b), h = u.slice(c + 1);
                                try {
                                    h = r.iri ? D.toUnicode(h) : D.toASCII($(h, r).toLowerCase());
                                } catch (d) {
                                    n.error = n.error || "Email address's domain name can not be converted to " + (r.iri ? "Unicode" : "ASCII") + " via punycode: " + d;
                                }
                                a[i] = p + "@" + h;
                            }
                            n.path = a.join(",");
                        }
                        var f = e.headers = e.headers || {};
                        e.subject && (f.subject = e.subject), e.body && (f.body = e.body);
                        var l = [];
                        for(var v in f)f[v] !== Z[v] && l.push(v.replace(J, ee).replace(J, o).replace(W, b) + "=" + f[v].replace(J, ee).replace(J, o).replace(X, b));
                        return l.length && (n.query = l.join("&")), n;
                    }
                }, te = /^([^\:]+)\:(.*)/, ne = {
                    scheme: "urn",
                    parse: function(e, r) {
                        var t = e.path && e.path.match(te), n = e;
                        if (t) {
                            var o = r.scheme || n.scheme || "urn", a = t[1].toLowerCase(), i = t[2], s = o + ":" + (r.nid || a), u = w[s];
                            n.nid = a, n.nss = i, n.path = void 0, u && (n = u.parse(n, r));
                        } else n.error = n.error || "URN can not be parsed.";
                        return n;
                    },
                    serialize: function(e, r) {
                        var t = r.scheme || e.scheme || "urn", n = e.nid, o = t + ":" + (r.nid || n), a = w[o];
                        a && (e = a.serialize(e, r));
                        var i = e, s = e.nss;
                        return i.path = (n || r.nid) + ":" + s, i;
                    }
                }, oe = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ae = {
                    scheme: "urn:uuid",
                    parse: function(e, r) {
                        var t = e;
                        return t.uuid = t.nss, t.nss = void 0, r.tolerant || t.uuid && t.uuid.match(oe) || (t.error = t.error || "UUID is not valid."), t;
                    },
                    serialize: function(e, r) {
                        var t = e;
                        return t.nss = (e.uuid || "").toLowerCase(), t;
                    }
                };
                w[V.scheme] = V, w[M.scheme] = M, w[re.scheme] = re, w[ne.scheme] = ne, w[ae.scheme] = ae, e.SCHEMES = w, e.pctEncChar = b, e.pctDecChars = x, e.parse = _, e.removeDotSegments = H, e.serialize = z, e.resolveComponents = L, e.resolve = function(e, r, t) {
                    var n = function(e, r) {
                        var t = e;
                        if (r) for(var n in r)t[n] = r[n];
                        return t;
                    }({
                        scheme: "null"
                    }, t);
                    return z(L(_(e, n), _(r, n), n, !0), n);
                }, e.normalize = function(e, r) {
                    return "string" == typeof e ? e = z(_(e, r), r) : "object" === n(e) && (e = _(z(e, r), r)), e;
                }, e.equal = function(e, r, t) {
                    return "string" == typeof e ? e = z(_(e, t), t) : "object" === n(e) && (e = z(e, t)), "string" == typeof r ? r = z(_(r, t), t) : "object" === n(r) && (r = z(r, t)), e === r;
                }, e.escapeComponent = function(e, r) {
                    return e && e.toString().replace(r && r.iri ? s.ESCAPE : i.ESCAPE, b);
                }, e.unescapeComponent = $, Object.defineProperty(e, "__esModule", {
                    value: !0
                });
            });
        },
        {}
    ],
    "dPQH": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function r(t, e) {
                if (t === e) return !0;
                if (t && e && "object" == typeof t && "object" == typeof e) {
                    if (t.constructor !== e.constructor) return !1;
                    var o, n, u;
                    if (Array.isArray(t)) {
                        if ((o = t.length) != e.length) return !1;
                        for(n = o; 0 != n--;)if (!r(t[n], e[n])) return !1;
                        return !0;
                    }
                    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;
                    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf();
                    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString();
                    if ((o = (u = Object.keys(t)).length) !== Object.keys(e).length) return !1;
                    for(n = o; 0 != n--;)if (!Object.prototype.hasOwnProperty.call(e, u[n])) return !1;
                    for(n = o; 0 != n--;){
                        var f = u[n];
                        if (!r(t[f], e[f])) return !1;
                    }
                    return !0;
                }
                return t != t && e != e;
            };
        },
        {}
    ],
    "rD0p": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r) {
                for(var t, e = 0, o = r.length, c = 0; c < o;)e++, (t = r.charCodeAt(c++)) >= 55296 && t <= 56319 && c < o && 56320 == (64512 & (t = r.charCodeAt(c))) && c++;
                return e;
            };
        },
        {}
    ],
    "Q1F7": [
        function(require1, module1, exports) {
            "use strict";
            function e(e, r) {
                for(var n in r = r || {}, e)r[n] = e[n];
                return r;
            }
            function r(e, r, n, t) {
                var a = t ? " !== " : " === ", o = t ? " || " : " && ", u = t ? "!" : "", c = t ? "" : "!";
                switch(e){
                    case "null":
                        return r + a + "null";
                    case "array":
                        return u + "Array.isArray(" + r + ")";
                    case "object":
                        return "(" + u + r + o + "typeof " + r + a + '"object"' + o + c + "Array.isArray(" + r + "))";
                    case "integer":
                        return "(typeof " + r + a + '"number"' + o + c + "(" + r + " % 1)" + o + r + a + r + (n ? o + u + "isFinite(" + r + ")" : "") + ")";
                    case "number":
                        return "(typeof " + r + a + '"' + e + '"' + (n ? o + u + "isFinite(" + r + ")" : "") + ")";
                    default:
                        return "typeof " + r + a + '"' + e + '"';
                }
            }
            function n(e, n, t) {
                switch(e.length){
                    case 1:
                        return r(e[0], n, t, !0);
                    default:
                        var a = "", u = o(e);
                        for(var c in u.array && u.object && (a = u.null ? "(" : "(!" + n + " || ", a += "typeof " + n + ' !== "object")', delete u.null, delete u.array, delete u.object), u.number && delete u.integer, u)a += (a ? " && " : "") + r(c, n, t, !0);
                        return a;
                }
            }
            module1.exports = {
                copy: e,
                checkDataType: r,
                checkDataTypes: n,
                coerceToTypes: a,
                toHash: o,
                getProperty: i,
                escapeQuotes: l,
                equal: require1("fast-deep-equal"),
                ucs2length: require1("./ucs2length"),
                varOccurences: f,
                varReplace: s,
                schemaHasRules: p,
                schemaHasRulesExcept: g,
                schemaUnknownRules: y,
                toQuotedString: h,
                getPathExpr: v,
                getPath: d,
                getData: w,
                unescapeFragment: E,
                unescapeJsonPointer: A,
                escapeFragment: R,
                escapeJsonPointer: x
            };
            var t = o([
                "string",
                "number",
                "integer",
                "boolean",
                "null"
            ]);
            function a(e, r) {
                if (Array.isArray(r)) {
                    for(var n = [], a = 0; a < r.length; a++){
                        var o = r[a];
                        t[o] ? n[n.length] = o : "array" === e && "array" === o && (n[n.length] = o);
                    }
                    if (n.length) return n;
                } else {
                    if (t[r]) return [
                        r
                    ];
                    if ("array" === e && "array" === r) return [
                        "array"
                    ];
                }
            }
            function o(e) {
                for(var r = {}, n = 0; n < e.length; n++)r[e[n]] = !0;
                return r;
            }
            var u = /^[a-z$_][a-z$_0-9]*$/i, c = /'|\\/g;
            function i(e) {
                return "number" == typeof e ? "[" + e + "]" : u.test(e) ? "." + e : "['" + l(e) + "']";
            }
            function l(e) {
                return e.replace(c, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
            }
            function f(e, r) {
                r += "[^0-9]";
                var n = e.match(new RegExp(r, "g"));
                return n ? n.length : 0;
            }
            function s(e, r, n) {
                return r += "([^0-9])", n = n.replace(/\$/g, "$$$$"), e.replace(new RegExp(r, "g"), n + "$1");
            }
            function p(e, r) {
                if ("boolean" == typeof e) return !e;
                for(var n in e)if (r[n]) return !0;
            }
            function g(e, r, n) {
                if ("boolean" == typeof e) return !e && "not" != n;
                for(var t in e)if (t != n && r[t]) return !0;
            }
            function y(e, r) {
                if ("boolean" != typeof e) {
                    for(var n in e)if (!r[n]) return n;
                }
            }
            function h(e) {
                return "'" + l(e) + "'";
            }
            function v(e, r, n, t) {
                return $(e, n ? "'/' + " + r + (t ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : t ? "'[' + " + r + " + ']'" : "'[\\'' + " + r + " + '\\']'");
            }
            function d(e, r, n) {
                return $(e, h(n ? "/" + x(r) : i(r)));
            }
            var m = /^\/(?:[^~]|~0|~1)*$/, b = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
            function w(e, r, n) {
                var t, a, o, u;
                if ("" === e) return "rootData";
                if ("/" == e[0]) {
                    if (!m.test(e)) throw new Error("Invalid JSON-pointer: " + e);
                    a = e, o = "rootData";
                } else {
                    if (!(u = e.match(b))) throw new Error("Invalid JSON-pointer: " + e);
                    if (t = +u[1], "#" == (a = u[2])) {
                        if (t >= r) throw new Error("Cannot access property/index " + t + " levels up, current level is " + r);
                        return n[r - t];
                    }
                    if (t > r) throw new Error("Cannot access data " + t + " levels up, current level is " + r);
                    if (o = "data" + (r - t || ""), !a) return o;
                }
                for(var c = o, l = a.split("/"), f = 0; f < l.length; f++){
                    var s = l[f];
                    s && (c += " && " + (o += i(A(s))));
                }
                return c;
            }
            function $(e, r) {
                return '""' == e ? r : (e + " + " + r).replace(/([^\\])' \+ '/g, "$1");
            }
            function E(e) {
                return A(decodeURIComponent(e));
            }
            function R(e) {
                return encodeURIComponent(x(e));
            }
            function x(e) {
                return e.replace(/~/g, "~0").replace(/\//g, "~1");
            }
            function A(e) {
                return e.replace(/~1/g, "/").replace(/~0/g, "~");
            }
        },
        {
            "fast-deep-equal": "dPQH",
            "./ucs2length": "rD0p"
        }
    ],
    "HHLG": [
        function(require1, module1, exports) {
            "use strict";
            var t = require1("./util");
            function e(e) {
                t.copy(e, this);
            }
            module1.exports = e;
        },
        {
            "./util": "Q1F7"
        }
    ],
    "uMRE": [
        function(require1, module1, exports) {
            "use strict";
            var e = module1.exports = function(e, i, t) {
                "function" == typeof i && (t = i, i = {}), r(i, "function" == typeof (t = i.cb || t) ? t : t.pre || function() {}, t.post || function() {}, e, "", e);
            };
            function r(t, n, o, s, a, m, p, f, u, y) {
                if (s && "object" == typeof s && !Array.isArray(s)) {
                    for(var c in n(s, a, m, p, f, u, y), s){
                        var d = s[c];
                        if (Array.isArray(d)) {
                            if (c in e.arrayKeywords) for(var l = 0; l < d.length; l++)r(t, n, o, d[l], a + "/" + c + "/" + l, m, a, c, s, l);
                        } else if (c in e.propsKeywords) {
                            if (d && "object" == typeof d) for(var w in d)r(t, n, o, d[w], a + "/" + c + "/" + i(w), m, a, c, s, w);
                        } else (c in e.keywords || t.allKeys && !(c in e.skipKeywords)) && r(t, n, o, d, a + "/" + c, m, a, c, s);
                    }
                    o(s, a, m, p, f, u, y);
                }
            }
            function i(e) {
                return e.replace(/~/g, "~0").replace(/\//g, "~1");
            }
            e.keywords = {
                additionalItems: !0,
                items: !0,
                contains: !0,
                additionalProperties: !0,
                propertyNames: !0,
                not: !0
            }, e.arrayKeywords = {
                items: !0,
                allOf: !0,
                anyOf: !0,
                oneOf: !0
            }, e.propsKeywords = {
                definitions: !0,
                properties: !0,
                patternProperties: !0,
                dependencies: !0
            }, e.skipKeywords = {
                default: !0,
                enum: !0,
                const: !0,
                required: !0,
                maximum: !0,
                minimum: !0,
                exclusiveMaximum: !0,
                exclusiveMinimum: !0,
                multipleOf: !0,
                maxLength: !0,
                minLength: !0,
                pattern: !0,
                format: !0,
                maxItems: !0,
                minItems: !0,
                uniqueItems: !0,
                maxProperties: !0,
                minProperties: !0
            };
        },
        {}
    ],
    "w10T": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("uri-js"), r = require1("fast-deep-equal"), t = require1("./util"), i = require1("./schema_obj"), s = require1("json-schema-traverse");
            function a(e, r, t) {
                var s = this._refs[t];
                if ("string" == typeof s) {
                    if (!this._refs[s]) return a.call(this, e, r, s);
                    s = this._refs[s];
                }
                if ((s = s || this._schemas[t]) instanceof i) return u(s.schema, this._opts.inlineRefs) ? s.schema : s.validate || this._compile(s);
                var o, f, c, h = n.call(this, r, t);
                return h && (o = h.schema, r = h.root, c = h.baseId), o instanceof i ? f = o.validate || e.call(this, o.schema, r, void 0, c) : void 0 !== o && (f = u(o, this._opts.inlineRefs) ? o : e.call(this, o, r, void 0, c)), f;
            }
            function n(r, t) {
                var s = e.parse(t), a = d(s), n = v(this._getId(r.schema));
                if (0 === Object.keys(r.schema).length || a !== n) {
                    var f = g(a), h = this._refs[f];
                    if ("string" == typeof h) return o.call(this, r, h, s);
                    if (h instanceof i) h.validate || this._compile(h), r = h;
                    else {
                        if (!((h = this._schemas[f]) instanceof i)) return;
                        if (h.validate || this._compile(h), f == g(t)) return {
                            schema: h,
                            root: r,
                            baseId: n
                        };
                        r = h;
                    }
                    if (!r.schema) return;
                    n = v(this._getId(r.schema));
                }
                return c.call(this, s, n, r.schema, r);
            }
            function o(e, r, t) {
                var i = n.call(this, e, r);
                if (i) {
                    var s = i.schema, a = i.baseId;
                    e = i.root;
                    var o = this._getId(s);
                    return o && (a = _(a, o)), c.call(this, t, a, s, e);
                }
            }
            module1.exports = a, a.normalizeId = g, a.fullPath = v, a.url = _, a.ids = y, a.inlineRef = u, a.schema = n;
            var f = t.toHash([
                "properties",
                "patternProperties",
                "enum",
                "dependencies",
                "definitions"
            ]);
            function c(e, r, i, s) {
                if (e.fragment = e.fragment || "", "/" == e.fragment.slice(0, 1)) {
                    for(var a = e.fragment.split("/"), o = 1; o < a.length; o++){
                        var c = a[o];
                        if (c) {
                            if (void 0 === (i = i[c = t.unescapeFragment(c)])) break;
                            var h;
                            if (!f[c] && ((h = this._getId(i)) && (r = _(r, h)), i.$ref)) {
                                var u = _(r, i.$ref), l = n.call(this, s, u);
                                l && (i = l.schema, s = l.root, r = l.baseId);
                            }
                        }
                    }
                    return void 0 !== i && i !== s.schema ? {
                        schema: i,
                        root: s,
                        baseId: r
                    } : void 0;
                }
            }
            var h = t.toHash([
                "type",
                "format",
                "pattern",
                "maxLength",
                "minLength",
                "maxProperties",
                "minProperties",
                "maxItems",
                "minItems",
                "maximum",
                "minimum",
                "uniqueItems",
                "multipleOf",
                "required",
                "enum"
            ]);
            function u(e, r) {
                return !1 !== r && (void 0 === r || !0 === r ? l(e) : r ? m(e) <= r : void 0);
            }
            function l(e) {
                var r;
                if (Array.isArray(e)) {
                    for(var t = 0; t < e.length; t++)if ("object" == typeof (r = e[t]) && !l(r)) return !1;
                } else for(var i in e){
                    if ("$ref" == i) return !1;
                    if ("object" == typeof (r = e[i]) && !l(r)) return !1;
                }
                return !0;
            }
            function m(e) {
                var r, t = 0;
                if (Array.isArray(e)) {
                    for(var i = 0; i < e.length; i++)if ("object" == typeof (r = e[i]) && (t += m(r)), t == 1 / 0) return 1 / 0;
                } else for(var s in e){
                    if ("$ref" == s) return 1 / 0;
                    if (h[s]) t++;
                    else if ("object" == typeof (r = e[s]) && (t += m(r) + 1), t == 1 / 0) return 1 / 0;
                }
                return t;
            }
            function v(r, t) {
                return !1 !== t && (r = g(r)), d(e.parse(r));
            }
            function d(r) {
                return e.serialize(r).split("#")[0] + "#";
            }
            var p = /#\/?$/;
            function g(e) {
                return e ? e.replace(p, "") : "";
            }
            function _(r, t) {
                return t = g(t), e.resolve(r, t);
            }
            function y(i) {
                var a = g(this._getId(i)), n = {
                    "": a
                }, o = {
                    "": v(a, !1)
                }, f = {}, c = this;
                return s(i, {
                    allKeys: !0
                }, function(i, s, a, h, u, l, m) {
                    if ("" !== s) {
                        var v = c._getId(i), d = n[h], p = o[h] + "/" + u;
                        if (void 0 !== m && (p += "/" + ("number" == typeof m ? m : t.escapeFragment(m))), "string" == typeof v) {
                            v = d = g(d ? e.resolve(d, v) : v);
                            var _ = c._refs[v];
                            if ("string" == typeof _ && (_ = c._refs[_]), _ && _.schema) {
                                if (!r(i, _.schema)) throw new Error('id "' + v + '" resolves to more than one schema');
                            } else if (v != g(p)) {
                                if ("#" == v[0]) {
                                    if (f[v] && !r(i, f[v])) throw new Error('id "' + v + '" resolves to more than one schema');
                                    f[v] = i;
                                } else c._refs[v] = p;
                            }
                        }
                        n[s] = d, o[s] = p;
                    }
                }), f;
            }
        },
        {
            "uri-js": "wWOq",
            "fast-deep-equal": "dPQH",
            "./util": "Q1F7",
            "./schema_obj": "HHLG",
            "json-schema-traverse": "uMRE"
        }
    ],
    "OtNE": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./resolve");
            function t(e) {
                this.message = "validation failed", this.errors = e, this.ajv = this.validation = !0;
            }
            function i(t, s, r) {
                this.message = r || i.message(t, s), this.missingRef = e.url(t, s), this.missingSchema = e.normalizeId(e.fullPath(this.missingRef));
            }
            function s(e) {
                return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
            }
            module1.exports = {
                Validation: s(t),
                MissingRef: s(i)
            }, i.message = function(e, t) {
                return "can't resolve reference " + t + " from id " + e;
            };
        },
        {
            "./resolve": "w10T"
        }
    ],
    "Xb3N": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r, t) {
                t || (t = {}), "function" == typeof t && (t = {
                    cmp: t
                });
                var e, n = "boolean" == typeof t.cycles && t.cycles, i = t.cmp && (e = t.cmp, function(r) {
                    return function(t, n) {
                        var i = {
                            key: t,
                            value: r[t]
                        }, u = {
                            key: n,
                            value: r[n]
                        };
                        return e(i, u);
                    };
                }), u = [];
                return function r(t) {
                    if (t && t.toJSON && "function" == typeof t.toJSON && (t = t.toJSON()), void 0 !== t) {
                        if ("number" == typeof t) return isFinite(t) ? "" + t : "null";
                        if ("object" != typeof t) return JSON.stringify(t);
                        var e, o;
                        if (Array.isArray(t)) {
                            for(o = "[", e = 0; e < t.length; e++)e && (o += ","), o += r(t[e]) || "null";
                            return o + "]";
                        }
                        if (null === t) return "null";
                        if (-1 !== u.indexOf(t)) {
                            if (n) return JSON.stringify("__cycle__");
                            throw new TypeError("Converting circular structure to JSON");
                        }
                        var f = u.push(t) - 1, c = Object.keys(t).sort(i && i(t));
                        for(o = "", e = 0; e < c.length; e++){
                            var l = c[e], y = r(t[l]);
                            y && (o && (o += ","), o += JSON.stringify(l) + ":" + y);
                        }
                        return u.splice(f, 1), "{" + o + "}";
                    }
                }(r);
            };
        },
        {}
    ],
    "yhC1": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t = "", s = !0 === e.schema.$async, o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"), l = e.self._getId(e.schema);
                if (e.opts.strictKeywords) {
                    var i = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
                    if (i) {
                        var n = "unknown keyword: " + i;
                        if ("log" !== e.opts.strictKeywords) throw new Error(n);
                        e.logger.warn(n);
                    }
                }
                if (e.isTop && (t += " var validate = ", s && (e.async = !0, t += "async "), t += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", l && (e.opts.sourceCode || e.opts.processCode) && (t += " /*# sourceURL=" + l + " */ ")), "boolean" == typeof e.schema || !o && !e.schema.$ref) {
                    var c = e.level, f = e.dataLevel, h = e.schema["false schema"], u = e.schemaPath + e.util.getProperty("false schema"), p = e.errSchemaPath + "/false schema", d = !e.opts.allErrors, m = "data" + (f || ""), v = "valid" + c;
                    if (!1 === e.schema) {
                        e.isTop ? d = !0 : t += " var " + v + " = false; ", (W = W || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'false schema' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: {} ", !1 !== e.opts.messages && (t += " , message: 'boolean schema is false' "), e.opts.verbose && (t += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                        var y = t;
                        t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    } else e.isTop ? t += s ? " return data; " : " validate.errors = null; return true; " : t += " var " + v + " = true; ";
                    return e.isTop && (t += " }; return validate; "), t;
                }
                if (e.isTop) {
                    var g = e.isTop;
                    c = e.level = 0, f = e.dataLevel = 0, m = "data";
                    if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [
                        ""
                    ], void 0 !== e.schema.default && e.opts.useDefaults && e.opts.strictDefaults) {
                        var w = "default is ignored in the schema root";
                        if ("log" !== e.opts.strictDefaults) throw new Error(w);
                        e.logger.warn(w);
                    }
                    t += " var vErrors = null; ", t += " var errors = 0;     ", t += " if (rootData === undefined) rootData = data; ";
                } else {
                    c = e.level, m = "data" + ((f = e.dataLevel) || "");
                    if (l && (e.baseId = e.resolve.url(e.baseId, l)), s && !e.async) throw new Error("async schema in sync schema");
                    t += " var errs_" + c + " = errors;";
                }
                v = "valid" + c, d = !e.opts.allErrors;
                var E = "", P = "", b = e.schema.type, D = Array.isArray(b);
                if (b && e.opts.nullable && !0 === e.schema.nullable && (D ? -1 == b.indexOf("null") && (b = b.concat("null")) : "null" != b && (b = [
                    b,
                    "null"
                ], D = !0)), D && 1 == b.length && (b = b[0], D = !1), e.schema.$ref && o) {
                    if ("fail" == e.opts.extendRefs) throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
                    !0 !== e.opts.extendRefs && (o = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'));
                }
                if (e.schema.$comment && e.opts.$comment && (t += " " + e.RULES.all.$comment.code(e, "$comment")), b) {
                    if (e.opts.coerceTypes) var S = e.util.coerceToTypes(e.opts.coerceTypes, b);
                    var R = e.RULES.types[b];
                    if (S || D || !0 === R || R && !X(R)) {
                        u = e.schemaPath + ".type", p = e.errSchemaPath + "/type", u = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
                        var T = D ? "checkDataTypes" : "checkDataType";
                        if (t += " if (" + e.util[T](b, m, e.opts.strictNumbers, !0) + ") { ", S) {
                            var k = "dataType" + c, $ = "coerced" + c;
                            t += " var " + k + " = typeof " + m + "; var " + $ + " = undefined; ", "array" == e.opts.coerceTypes && (t += " if (" + k + " == 'object' && Array.isArray(" + m + ") && " + m + ".length == 1) { " + m + " = " + m + "[0]; " + k + " = typeof " + m + "; if (" + e.util.checkDataType(e.schema.type, m, e.opts.strictNumbers) + ") " + $ + " = " + m + "; } "), t += " if (" + $ + " !== undefined) ; ";
                            var L = S;
                            if (L) for(var j, A = -1, I = L.length - 1; A < I;)"string" == (j = L[A += 1]) ? t += " else if (" + k + " == 'number' || " + k + " == 'boolean') " + $ + " = '' + " + m + "; else if (" + m + " === null) " + $ + " = ''; " : "number" == j || "integer" == j ? (t += " else if (" + k + " == 'boolean' || " + m + " === null || (" + k + " == 'string' && " + m + " && " + m + " == +" + m + " ", "integer" == j && (t += " && !(" + m + " % 1)"), t += ")) " + $ + " = +" + m + "; ") : "boolean" == j ? t += " else if (" + m + " === 'false' || " + m + " === 0 || " + m + " === null) " + $ + " = false; else if (" + m + " === 'true' || " + m + " === 1) " + $ + " = true; " : "null" == j ? t += " else if (" + m + " === '' || " + m + " === 0 || " + m + " === false) " + $ + " = null; " : "array" == e.opts.coerceTypes && "array" == j && (t += " else if (" + k + " == 'string' || " + k + " == 'number' || " + k + " == 'boolean' || " + m + " == null) " + $ + " = [" + m + "]; ");
                            t += " else {   ", (W = W || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", !1 !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                            y = t;
                            t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } if (" + $ + " !== undefined) {  ";
                            var U = f ? "data" + (f - 1 || "") : "parentData";
                            t += " " + m + " = " + $ + "; ", f || (t += "if (" + U + " !== undefined)"), t += " " + U + "[" + (f ? e.dataPathArr[f] : "parentDataProperty") + "] = " + $ + "; } ";
                        } else {
                            (W = W || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", !1 !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                            y = t;
                            t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                        }
                        t += " } ";
                    }
                }
                if (e.schema.$ref && !o) t += " " + e.RULES.all.$ref.code(e, "$ref") + " ", d && (t += " } if (errors === ", t += g ? "0" : "errs_" + c, t += ") { ", P += "}");
                else {
                    var x = e.RULES;
                    if (x) {
                        for(var _ = -1, N = x.length - 1; _ < N;)if (X(R = x[_ += 1])) {
                            if (R.type && (t += " if (" + e.util.checkDataType(R.type, m, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
                                if ("object" == R.type && e.schema.properties) {
                                    h = e.schema.properties;
                                    var V = Object.keys(h);
                                    if (V) {
                                        for(var O, Q = -1, C = V.length - 1; Q < C;)if (void 0 !== (H = h[O = V[Q += 1]]).default) {
                                            var J = m + e.util.getProperty(O);
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    w = "default is ignored for: " + J;
                                                    if ("log" !== e.opts.strictDefaults) throw new Error(w);
                                                    e.logger.warn(w);
                                                }
                                            } else t += " if (" + J + " === undefined ", "empty" == e.opts.useDefaults && (t += " || " + J + " === null || " + J + " === '' "), t += " ) " + J + " = ", "shared" == e.opts.useDefaults ? t += " " + e.useDefault(H.default) + " " : t += " " + JSON.stringify(H.default) + " ", t += "; ";
                                        }
                                    }
                                } else if ("array" == R.type && Array.isArray(e.schema.items)) {
                                    var K = e.schema.items;
                                    if (K) {
                                        A = -1;
                                        for(var H, q = K.length - 1; A < q;)if (void 0 !== (H = K[A += 1]).default) {
                                            J = m + "[" + A + "]";
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    w = "default is ignored for: " + J;
                                                    if ("log" !== e.opts.strictDefaults) throw new Error(w);
                                                    e.logger.warn(w);
                                                }
                                            } else t += " if (" + J + " === undefined ", "empty" == e.opts.useDefaults && (t += " || " + J + " === null || " + J + " === '' "), t += " ) " + J + " = ", "shared" == e.opts.useDefaults ? t += " " + e.useDefault(H.default) + " " : t += " " + JSON.stringify(H.default) + " ", t += "; ";
                                        }
                                    }
                                }
                            }
                            var z = R.rules;
                            if (z) {
                                for(var B, F = -1, G = z.length - 1; F < G;)if (Y(B = z[F += 1])) {
                                    var M = B.code(e, B.keyword, R.type);
                                    M && (t += " " + M + " ", d && (E += "}"));
                                }
                            }
                            if (d && (t += " " + E + " ", E = ""), R.type && (t += " } ", b && b === R.type && !S)) {
                                t += " else { ";
                                var W;
                                u = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
                                (W = W || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", !1 !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                                y = t;
                                t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } ";
                            }
                            d && (t += " if (errors === ", t += g ? "0" : "errs_" + c, t += ") { ", P += "}");
                        }
                    }
                }
                function X(e) {
                    for(var r = e.rules, a = 0; a < r.length; a++)if (Y(r[a])) return !0;
                }
                function Y(r) {
                    return void 0 !== e.schema[r.keyword] || r.implements && function(r) {
                        for(var a = r.implements, t = 0; t < a.length; t++)if (void 0 !== e.schema[a[t]]) return !0;
                    }(r);
                }
                return d && (t += " " + P + " "), g ? (s ? (t += " if (errors === 0) return data;           ", t += " else throw new ValidationError(vErrors); ") : (t += " validate.errors = vErrors; ", t += " return errors === 0;       "), t += " }; return validate;") : t += " var " + v + " = errors === errs_" + c + ";", t;
            };
        },
        {}
    ],
    "qdYs": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./resolve"), r = require1("./util"), t = require1("./error_classes"), i = require1("fast-json-stable-stringify"), o = require1("../dotjs/validate"), a = r.ucs2length, n = require1("fast-deep-equal"), s = t.Validation;
            function l(f, g, y, w) {
                var R = this, V = this._opts, S = [
                    void 0
                ], _ = {}, b = [], E = {}, q = [], j = {}, x = [];
                g = g || {
                    schema: f,
                    refVal: S,
                    refs: _
                };
                var $ = c.call(this, f, g, w), k = this._compilations[$.index];
                if ($.compiling) return k.callValidate = function e() {
                    var r = k.validate;
                    var t = r.apply(this, arguments);
                    e.errors = r.errors;
                    return t;
                };
                var C = this._formats, P = this.RULES;
                try {
                    var I = U(f, g, y, w);
                    k.validate = I;
                    var L = k.callValidate;
                    return L && (L.schema = I.schema, L.errors = null, L.refs = I.refs, L.refVal = I.refVal, L.root = I.root, L.$async = I.$async, V.sourceCode && (L.source = I.source)), I;
                } finally{
                    u.call(this, f, g, w);
                }
                function U(i, c, u, f) {
                    var y = !c || c && c.schema == i;
                    if (c.schema != g.schema) return l.call(R, i, c, u, f);
                    var w, E = !0 === i.$async, j = o({
                        isTop: !0,
                        schema: i,
                        isRoot: y,
                        baseId: f,
                        root: c,
                        schemaPath: "",
                        errSchemaPath: "#",
                        errorPath: '""',
                        MissingRefError: t.MissingRef,
                        RULES: P,
                        validate: o,
                        util: r,
                        resolve: e,
                        resolveRef: M,
                        usePattern: T,
                        useDefault: D,
                        useCustomRule: F,
                        opts: V,
                        formats: C,
                        logger: R.logger,
                        self: R
                    });
                    j = p(S, h) + p(b, d) + p(q, v) + p(x, m) + j, V.processCode && (j = V.processCode(j, i));
                    try {
                        w = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", j)(R, P, C, g, S, q, x, n, a, s), S[0] = w;
                    } catch ($) {
                        throw R.logger.error("Error compiling schema, function code:", j), $;
                    }
                    return w.schema = i, w.errors = null, w.refs = _, w.refVal = S, w.root = y ? w : c, E && (w.$async = !0), !0 === V.sourceCode && (w.source = {
                        code: j,
                        patterns: b,
                        defaults: q
                    }), w;
                }
                function M(r, t, i) {
                    t = e.url(r, t);
                    var o, a, n = _[t];
                    if (void 0 !== n) return Q(o = S[n], a = "refVal[" + n + "]");
                    if (!i && g.refs) {
                        var s = g.refs[t];
                        if (void 0 !== s) return Q(o = g.refVal[s], a = O(t, o));
                    }
                    a = O(t);
                    var c = e.call(R, U, g, t);
                    if (void 0 === c) {
                        var u = y && y[t];
                        u && (c = e.inlineRef(u, V.inlineRefs) ? u : l.call(R, u, g, y, r));
                    }
                    if (void 0 !== c) return function(e, r) {
                        var t = _[e];
                        S[t] = r;
                    }(t, c), Q(c, a);
                    !function(e) {
                        delete _[e];
                    }(t);
                }
                function O(e, r) {
                    var t = S.length;
                    return S[t] = r, _[e] = t, "refVal" + t;
                }
                function Q(e, r) {
                    return "object" == typeof e || "boolean" == typeof e ? {
                        code: r,
                        schema: e,
                        inline: !0
                    } : {
                        code: r,
                        $async: e && !!e.$async
                    };
                }
                function T(e) {
                    var r = E[e];
                    return void 0 === r && (r = E[e] = b.length, b[r] = e), "pattern" + r;
                }
                function D(e) {
                    switch(typeof e){
                        case "boolean":
                        case "number":
                            return "" + e;
                        case "string":
                            return r.toQuotedString(e);
                        case "object":
                            if (null === e) return "null";
                            var t = i(e), o = j[t];
                            return void 0 === o && (o = j[t] = q.length, q[o] = e), "default" + o;
                    }
                }
                function F(e, r, t, i) {
                    if (!1 !== R._opts.validateSchema) {
                        var o = e.definition.dependencies;
                        if (o && !o.every(function(e) {
                            return Object.prototype.hasOwnProperty.call(t, e);
                        })) throw new Error("parent schema must have all required keywords: " + o.join(","));
                        var a = e.definition.validateSchema;
                        if (a) {
                            if (!a(r)) {
                                var n = "keyword schema is invalid: " + R.errorsText(a.errors);
                                if ("log" != R._opts.validateSchema) throw new Error(n);
                                R.logger.error(n);
                            }
                        }
                    }
                    var s, l = e.definition.compile, c = e.definition.inline, u = e.definition.macro;
                    if (l) s = l.call(R, r, t, i);
                    else if (u) s = u.call(R, r, t, i), !1 !== V.validateSchema && R.validateSchema(s, !0);
                    else if (c) s = c.call(R, i, e.keyword, r, t);
                    else if (!(s = e.definition.validate)) return;
                    if (void 0 === s) throw new Error('custom keyword "' + e.keyword + '"failed to compile');
                    var f = x.length;
                    return x[f] = s, {
                        code: "customRule" + f,
                        validate: s
                    };
                }
            }
            function c(e, r, t) {
                var i = f.call(this, e, r, t);
                return i >= 0 ? {
                    index: i,
                    compiling: !0
                } : (i = this._compilations.length, this._compilations[i] = {
                    schema: e,
                    root: r,
                    baseId: t
                }, {
                    index: i,
                    compiling: !1
                });
            }
            function u(e, r, t) {
                var i = f.call(this, e, r, t);
                i >= 0 && this._compilations.splice(i, 1);
            }
            function f(e, r, t) {
                for(var i = 0; i < this._compilations.length; i++){
                    var o = this._compilations[i];
                    if (o.schema == e && o.root == r && o.baseId == t) return i;
                }
                return -1;
            }
            function d(e, t) {
                return "var pattern" + e + " = new RegExp(" + r.toQuotedString(t[e]) + ");";
            }
            function v(e) {
                return "var default" + e + " = defaults[" + e + "];";
            }
            function h(e, r) {
                return void 0 === r[e] ? "" : "var refVal" + e + " = refVal[" + e + "];";
            }
            function m(e) {
                return "var customRule" + e + " = customRules[" + e + "];";
            }
            function p(e, r) {
                if (!e.length) return "";
                for(var t = "", i = 0; i < e.length; i++)t += r(i, e);
                return t;
            }
            module1.exports = l;
        },
        {
            "./resolve": "w10T",
            "./util": "Q1F7",
            "./error_classes": "OtNE",
            "fast-json-stable-stringify": "Xb3N",
            "../dotjs/validate": "yhC1",
            "fast-deep-equal": "dPQH"
        }
    ],
    "fXCy": [
        function(require1, module1, exports) {
            "use strict";
            var t = module1.exports = function() {
                this._cache = {};
            };
            t.prototype.put = function(t, e) {
                this._cache[t] = e;
            }, t.prototype.get = function(t) {
                return this._cache[t];
            }, t.prototype.del = function(t) {
                delete this._cache[t];
            }, t.prototype.clear = function() {
                this._cache = {};
            };
        },
        {}
    ],
    "dfAH": [
        function(require1, module1, exports) {
            "use strict";
            var d = require1("./util"), a = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, u = [
                0,
                31,
                28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31
            ], F = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, f = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, D = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, t = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, r = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, e = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, i = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, z = /^(?:\/(?:[^~/]|~0|~1)*)*$/, $ = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, n = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
            function s(a) {
                return a = "full" == a ? "full" : "fast", d.copy(s[a]);
            }
            function x(d) {
                return d % 4 == 0 && (d % 100 != 0 || d % 400 == 0);
            }
            function _(d) {
                var F = d.match(a);
                if (!F) return !1;
                var f = +F[1], D = +F[2], t = +F[3];
                return D >= 1 && D <= 12 && t >= 1 && t <= (2 == D && x(f) ? 29 : u[D]);
            }
            function o(d, a) {
                var u = d.match(F);
                if (!u) return !1;
                var f = u[1], D = u[2], t = u[3], r = u[5];
                return (f <= 23 && D <= 59 && t <= 59 || 23 == f && 59 == D && 60 == t) && (!a || r);
            }
            module1.exports = s, s.fast = {
                date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
                time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
                "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
                uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
                "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
                "uri-template": r,
                url: e,
                email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
                hostname: f,
                ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
                regex: v,
                uuid: i,
                "json-pointer": z,
                "json-pointer-uri-fragment": $,
                "relative-json-pointer": n
            }, s.full = {
                date: _,
                time: o,
                "date-time": B,
                uri: l,
                "uri-reference": t,
                "uri-template": r,
                url: e,
                email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
                hostname: f,
                ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
                regex: v,
                uuid: i,
                "json-pointer": z,
                "json-pointer-uri-fragment": $,
                "relative-json-pointer": n
            };
            var E = /t|\s/i;
            function B(d) {
                var a = d.split(E);
                return 2 == a.length && _(a[0]) && o(a[1], !0);
            }
            var C = /\/|:/;
            function l(d) {
                return C.test(d) && D.test(d);
            }
            var p = /[^\\]\\Z/;
            function v(d) {
                if (p.test(d)) return !1;
                try {
                    return new RegExp(d), !0;
                } catch (a) {
                    return !1;
                }
            }
        },
        {
            "./util": "Q1F7"
        }
    ],
    "a2na": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r, e, a) {
                var s, t, o = " ", i = r.level, l = r.dataLevel, c = r.schema[e], n = r.errSchemaPath + "/" + e, h = !r.opts.allErrors, v = "data" + (l || ""), f = "valid" + i;
                if ("#" == c || "#/" == c) r.isRoot ? (s = r.async, t = "validate") : (s = !0 === r.root.schema.$async, t = "root.refVal[0]");
                else {
                    var d = r.resolveRef(r.baseId, c, r.isRoot);
                    if (void 0 === d) {
                        var p = r.MissingRefError.message(r.baseId, c);
                        if ("fail" == r.opts.missingRefs) {
                            r.logger.error(p), (g = g || []).push(o), o = "", !1 !== r.createErrors ? (o += " { keyword: '$ref' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(n) + " , params: { ref: '" + r.util.escapeQuotes(c) + "' } ", !1 !== r.opts.messages && (o += " , message: 'can\\'t resolve reference " + r.util.escapeQuotes(c) + "' "), r.opts.verbose && (o += " , schema: " + r.util.toQuotedString(c) + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + v + " "), o += " } ") : o += " {} ";
                            var m = o;
                            o = g.pop(), !r.compositeRule && h ? r.async ? o += " throw new ValidationError([" + m + "]); " : o += " validate.errors = [" + m + "]; return false; " : o += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h && (o += " if (false) { ");
                        } else {
                            if ("ignore" != r.opts.missingRefs) throw new r.MissingRefError(r.baseId, c, p);
                            r.logger.warn(p), h && (o += " if (true) { ");
                        }
                    } else if (d.inline) {
                        var u = r.util.copy(r);
                        u.level++;
                        var E = "valid" + u.level;
                        u.schema = d.schema, u.schemaPath = "", u.errSchemaPath = c, o += " " + r.validate(u).replace(/validate\.schema/g, d.code) + " ", h && (o += " if (" + E + ") { ");
                    } else s = !0 === d.$async || r.async && !1 !== d.$async, t = d.code;
                }
                if (t) {
                    var g;
                    (g = g || []).push(o), o = "", r.opts.passContext ? o += " " + t + ".call(this, " : o += " " + t + "( ", o += " " + v + ", (dataPath || '')", '""' != r.errorPath && (o += " + " + r.errorPath);
                    var y = o += " , " + (l ? "data" + (l - 1 || "") : "parentData") + " , " + (l ? r.dataPathArr[l] : "parentDataProperty") + ", rootData)  ";
                    if (o = g.pop(), s) {
                        if (!r.async) throw new Error("async schema referenced by sync schema");
                        h && (o += " var " + f + "; "), o += " try { await " + y + "; ", h && (o += " " + f + " = true; "), o += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", h && (o += " " + f + " = false; "), o += " } ", h && (o += " if (" + f + ") { ");
                    } else o += " if (!" + y + ") { if (vErrors === null) vErrors = " + t + ".errors; else vErrors = vErrors.concat(" + t + ".errors); errors = vErrors.length; } ", h && (o += " else { ");
                }
                return o;
            };
        },
        {}
    ],
    "hRgn": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, t, a) {
                var r = " ", s = e.schema[t], l = e.schemaPath + e.util.getProperty(t), c = e.errSchemaPath + "/" + t, h = !e.opts.allErrors, i = e.util.copy(e), o = "";
                i.level++;
                var u = "valid" + i.level, m = i.baseId, v = !0, d = s;
                if (d) for(var f, p = -1, n = d.length - 1; p < n;)f = d[p += 1], (e.opts.strictKeywords ? "object" == typeof f && Object.keys(f).length > 0 || !1 === f : e.util.schemaHasRules(f, e.RULES.all)) && (v = !1, i.schema = f, i.schemaPath = l + "[" + p + "]", i.errSchemaPath = c + "/" + p, r += "  " + e.validate(i) + " ", i.baseId = m, h && (r += " if (" + u + ") { ", o += "}"));
                return h && (r += v ? " if (true) { " : " " + o.slice(0, -1) + " "), r;
            };
        },
        {}
    ],
    "lo6J": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var s = " ", t = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, v = "data" + (o || ""), m = "valid" + t, u = "errs__" + t, n = e.util.copy(e), d = "";
                n.level++;
                var p = "valid" + n.level;
                if (l.every(function(r) {
                    return e.opts.strictKeywords ? "object" == typeof r && Object.keys(r).length > 0 || !1 === r : e.util.schemaHasRules(r, e.RULES.all);
                })) {
                    var f = n.baseId;
                    s += " var " + u + " = errors; var " + m + " = false;  ";
                    var E = e.compositeRule;
                    e.compositeRule = n.compositeRule = !0;
                    var y = l;
                    if (y) for(var P, R = -1, g = y.length - 1; R < g;)P = y[R += 1], n.schema = P, n.schemaPath = i + "[" + R + "]", n.errSchemaPath = c + "/" + R, s += "  " + e.validate(n) + " ", n.baseId = f, s += " " + m + " = " + m + " || " + p + "; if (!" + m + ") { ", d += "}";
                    e.compositeRule = n.compositeRule = E, s += " " + d + " if (!" + m + ") {   var err =   ", !1 !== e.createErrors ? (s += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", !1 !== e.opts.messages && (s += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (s += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && h && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += " } else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; } ", e.opts.allErrors && (s += " } ");
                } else h && (s += " if (true) { ");
                return s;
            };
        },
        {}
    ],
    "Kkzr": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(t, o, e) {
                var r = " ", s = t.schema[o], n = t.errSchemaPath + "/" + o, c = (t.opts.allErrors, t.util.toQuotedString(s));
                return !0 === t.opts.$comment ? r += " console.log(" + c + ");" : "function" == typeof t.opts.$comment && (r += " self._opts.$comment(" + c + ", " + t.util.toQuotedString(n) + ", validate.root.schema);"), r;
            };
        },
        {}
    ],
    "U4sD": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(a, e, r) {
                var t = " ", s = a.level, o = a.dataLevel, l = a.schema[e], h = a.schemaPath + a.util.getProperty(e), c = a.errSchemaPath + "/" + e, d = !a.opts.allErrors, m = "data" + (o || ""), v = "valid" + s, u = a.opts.$data && l && l.$data;
                u && (t += " var schema" + s + " = " + a.util.getData(l.$data, o, a.dataPathArr) + "; "), u || (t += " var schema" + s + " = validate.schema" + h + ";"), t += "var " + v + " = equal(" + m + ", schema" + s + "); if (!" + v + ") {   ";
                var i = i || [];
                i.push(t), t = "", !1 !== a.createErrors ? (t += " { keyword: 'const' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(c) + " , params: { allowedValue: schema" + s + " } ", !1 !== a.opts.messages && (t += " , message: 'should be equal to constant' "), a.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                var n = t;
                return t = i.pop(), !a.compositeRule && d ? a.async ? t += " throw new ValidationError([" + n + "]); " : t += " validate.errors = [" + n + "]; return false; " : t += " var err = " + n + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }", d && (t += " else { "), t;
            };
        },
        {}
    ],
    "EypH": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t = " ", s = e.level, l = e.dataLevel, o = e.schema[r], i = e.schemaPath + e.util.getProperty(r), v = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, c = "data" + (l || ""), u = "valid" + s, d = "errs__" + s, m = e.util.copy(e);
                m.level++;
                var p = "valid" + m.level, n = "i" + s, P = m.dataLevel = e.dataLevel + 1, f = "data" + P, E = e.baseId, g = e.opts.strictKeywords ? "object" == typeof o && Object.keys(o).length > 0 || !1 === o : e.util.schemaHasRules(o, e.RULES.all);
                if (t += "var " + d + " = errors;var " + u + ";", g) {
                    var R = e.compositeRule;
                    e.compositeRule = m.compositeRule = !0, m.schema = o, m.schemaPath = i, m.errSchemaPath = v, t += " var " + p + " = false; for (var " + n + " = 0; " + n + " < " + c + ".length; " + n + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, n, e.opts.jsonPointers, !0);
                    var y = c + "[" + n + "]";
                    m.dataPathArr[P] = n;
                    var b = e.validate(m);
                    m.baseId = E, e.util.varOccurences(b, f) < 2 ? t += " " + e.util.varReplace(b, f, y) + " " : t += " var " + f + " = " + y + "; " + b + " ", t += " if (" + p + ") break; }  ", e.compositeRule = m.compositeRule = R, t += "  if (!" + p + ") {";
                } else t += " if (" + c + ".length == 0) {";
                var S = S || [];
                S.push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(v) + " , params: {} ", !1 !== e.opts.messages && (t += " , message: 'should contain a valid item' "), e.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), t += " } ") : t += " {} ";
                var w = t;
                return t = S.pop(), !e.compositeRule && h ? e.async ? t += " throw new ValidationError([" + w + "]); " : t += " validate.errors = [" + w + "]; return false; " : t += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ", g && (t += "  errors = " + d + "; if (vErrors !== null) { if (" + d + ") vErrors.length = " + d + "; else vErrors = null; } "), e.opts.allErrors && (t += " } "), t;
            };
        },
        {}
    ],
    "Cpp7": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, t) {
                var a = " ", s = e.level, o = e.dataLevel, p = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, u = !e.opts.allErrors, n = "data" + (o || ""), h = "errs__" + s, c = e.util.copy(e), d = "";
                c.level++;
                var v = "valid" + c.level, P = {}, m = {}, y = e.opts.ownProperties;
                for(j in p)if ("__proto__" != j) {
                    var g = p[j], f = Array.isArray(g) ? m : P;
                    f[j] = g;
                }
                a += "var " + h + " = errors;";
                var Q = e.errorPath;
                for(var j in a += "var missing" + s + ";", m)if ((f = m[j]).length) {
                    if (a += " if ( " + n + e.util.getProperty(j) + " !== undefined ", y && (a += " && Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(j) + "') "), u) {
                        a += " && ( ";
                        var w = f;
                        if (w) for(var E = -1, b = w.length - 1; E < b;)x = w[E += 1], E && (a += " || "), a += " ( ( " + (I = n + (D = e.util.getProperty(x))) + " === undefined ", y && (a += " || ! Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(x) + "') "), a += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? x : D) + ") ) ";
                        a += ")) {  ";
                        var O = "missing" + s, S = "' + " + O + " + '";
                        e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(Q, O, !0) : Q + " + " + O);
                        var _ = _ || [];
                        _.push(a), a = "", !1 !== e.createErrors ? (a += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(j) + "', missingProperty: '" + S + "', depsCount: " + f.length + ", deps: '" + e.util.escapeQuotes(1 == f.length ? f[0] : f.join(", ")) + "' } ", !1 !== e.opts.messages && (a += " , message: 'should have ", 1 == f.length ? a += "property " + e.util.escapeQuotes(f[0]) : a += "properties " + e.util.escapeQuotes(f.join(", ")), a += " when property " + e.util.escapeQuotes(j) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), a += " } ") : a += " {} ";
                        var k = a;
                        a = _.pop(), !e.compositeRule && u ? e.async ? a += " throw new ValidationError([" + k + "]); " : a += " validate.errors = [" + k + "]; return false; " : a += " var err = " + k + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    } else {
                        a += " ) { ";
                        var R = f;
                        if (R) for(var x, A = -1, C = R.length - 1; A < C;){
                            x = R[A += 1];
                            var D = e.util.getProperty(x), I = (S = e.util.escapeQuotes(x), n + D);
                            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(Q, x, e.opts.jsonPointers)), a += " if ( " + I + " === undefined ", y && (a += " || ! Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(x) + "') "), a += ") {  var err =   ", !1 !== e.createErrors ? (a += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(j) + "', missingProperty: '" + S + "', depsCount: " + f.length + ", deps: '" + e.util.escapeQuotes(1 == f.length ? f[0] : f.join(", ")) + "' } ", !1 !== e.opts.messages && (a += " , message: 'should have ", 1 == f.length ? a += "property " + e.util.escapeQuotes(f[0]) : a += "properties " + e.util.escapeQuotes(f.join(", ")), a += " when property " + e.util.escapeQuotes(j) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                        }
                    }
                    a += " }   ", u && (d += "}", a += " else { ");
                }
                e.errorPath = Q;
                var L = c.baseId;
                for(var j in P){
                    g = P[j];
                    (e.opts.strictKeywords ? "object" == typeof g && Object.keys(g).length > 0 || !1 === g : e.util.schemaHasRules(g, e.RULES.all)) && (a += " " + v + " = true; if ( " + n + e.util.getProperty(j) + " !== undefined ", y && (a += " && Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(j) + "') "), a += ") { ", c.schema = g, c.schemaPath = i + e.util.getProperty(j), c.errSchemaPath = l + "/" + e.util.escapeFragment(j), a += "  " + e.validate(c) + " ", c.baseId = L, a += " }  ", u && (a += " if (" + v + ") { ", d += "}"));
                }
                return u && (a += "   " + d + " if (" + h + " == errors) {"), a;
            };
        },
        {}
    ],
    "fqDY": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(a, e, r) {
                var t = " ", s = a.level, l = a.dataLevel, o = a.schema[e], h = a.schemaPath + a.util.getProperty(e), d = a.errSchemaPath + "/" + e, i = !a.opts.allErrors, u = "data" + (l || ""), m = "valid" + s, v = a.opts.$data && o && o.$data;
                v && (t += " var schema" + s + " = " + a.util.getData(o.$data, l, a.dataPathArr) + "; ");
                var c = "i" + s, n = "schema" + s;
                v || (t += " var " + n + " = validate.schema" + h + ";"), t += "var " + m + ";", v && (t += " if (schema" + s + " === undefined) " + m + " = true; else if (!Array.isArray(schema" + s + ")) " + m + " = false; else {"), t += m + " = false;for (var " + c + "=0; " + c + "<" + n + ".length; " + c + "++) if (equal(" + u + ", " + n + "[" + c + "])) { " + m + " = true; break; }", v && (t += "  }  "), t += " if (!" + m + ") {   ";
                var p = p || [];
                p.push(t), t = "", !1 !== a.createErrors ? (t += " { keyword: 'enum' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(d) + " , params: { allowedValues: schema" + s + " } ", !1 !== a.opts.messages && (t += " , message: 'should be equal to one of the allowed values' "), a.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + u + " "), t += " } ") : t += " {} ";
                var f = t;
                return t = p.pop(), !a.compositeRule && i ? a.async ? t += " throw new ValidationError([" + f + "]); " : t += " validate.errors = [" + f + "]; return false; " : t += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }", i && (t += " else { "), t;
            };
        },
        {}
    ],
    "avoW": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(a, t, r) {
                var e = " ", o = a.level, s = a.dataLevel, i = a.schema[t], n = a.schemaPath + a.util.getProperty(t), f = a.errSchemaPath + "/" + t, c = !a.opts.allErrors, u = "data" + (s || "");
                if (!1 === a.opts.format) return c && (e += " if (true) { "), e;
                var m, h = a.opts.$data && i && i.$data;
                h ? (e += " var schema" + o + " = " + a.util.getData(i.$data, s, a.dataPathArr) + "; ", m = "schema" + o) : m = i;
                var l = a.opts.unknownFormats, d = Array.isArray(l);
                if (h) e += " var " + (p = "format" + o) + " = formats[" + m + "]; var " + (v = "isObject" + o) + " = typeof " + p + " == 'object' && !(" + p + " instanceof RegExp) && " + p + ".validate; var " + (y = "formatType" + o) + " = " + v + " && " + p + ".type || 'string'; if (" + v + ") { ", a.async && (e += " var async" + o + " = " + p + ".async; "), e += " " + p + " = " + p + ".validate; } if (  ", h && (e += " (" + m + " !== undefined && typeof " + m + " != 'string') || "), e += " (", "ignore" != l && (e += " (" + m + " && !" + p + " ", d && (e += " && self._opts.unknownFormats.indexOf(" + m + ") == -1 "), e += ") || "), e += " (" + p + " && " + y + " == '" + r + "' && !(typeof " + p + " == 'function' ? ", a.async ? e += " (async" + o + " ? await " + p + "(" + u + ") : " + p + "(" + u + ")) " : e += " " + p + "(" + u + ") ", e += " : " + p + ".test(" + u + "))))) {";
                else {
                    var p;
                    if (!(p = a.formats[i])) {
                        if ("ignore" == l) return a.logger.warn('unknown format "' + i + '" ignored in schema at path "' + a.errSchemaPath + '"'), c && (e += " if (true) { "), e;
                        if (d && l.indexOf(i) >= 0) return c && (e += " if (true) { "), e;
                        throw new Error('unknown format "' + i + '" is used in schema at path "' + a.errSchemaPath + '"');
                    }
                    var v, y = (v = "object" == typeof p && !(p instanceof RegExp) && p.validate) && p.type || "string";
                    if (v) {
                        var g = !0 === p.async;
                        p = p.validate;
                    }
                    if (y != r) return c && (e += " if (true) { "), e;
                    if (g) {
                        if (!a.async) throw new Error("async format in sync schema");
                        e += " if (!(await " + (w = "formats" + a.util.getProperty(i) + ".validate") + "(" + u + "))) { ";
                    } else {
                        e += " if (! ";
                        var w = "formats" + a.util.getProperty(i);
                        v && (w += ".validate"), e += "function" == typeof p ? " " + w + "(" + u + ") " : " " + w + ".test(" + u + ") ", e += ") { ";
                    }
                }
                var P = P || [];
                P.push(e), e = "", !1 !== a.createErrors ? (e += " { keyword: 'format' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(f) + " , params: { format:  ", e += h ? "" + m : "" + a.util.toQuotedString(i), e += "  } ", !1 !== a.opts.messages && (e += " , message: 'should match format \"", e += h ? "' + " + m + " + '" : "" + a.util.escapeQuotes(i), e += "\"' "), a.opts.verbose && (e += " , schema:  ", e += h ? "validate.schema" + n : "" + a.util.toQuotedString(i), e += "         , parentSchema: validate.schema" + a.schemaPath + " , data: " + u + " "), e += " } ") : e += " {} ";
                var E = e;
                return e = P.pop(), !a.compositeRule && c ? a.async ? e += " throw new ValidationError([" + E + "]); " : e += " validate.errors = [" + E + "]; return false; " : e += " var err = " + E + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", e += " } ", c && (e += " else { "), e;
            };
        },
        {}
    ],
    "JHQ3": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var s = " ", t = e.level, l = e.dataLevel, h = e.schema[r], o = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, i = !e.opts.allErrors, m = "data" + (l || ""), v = "valid" + t, u = "errs__" + t, d = e.util.copy(e);
                d.level++;
                var n = "valid" + d.level, p = e.schema.then, P = e.schema.else, f = void 0 !== p && (e.opts.strictKeywords ? "object" == typeof p && Object.keys(p).length > 0 || !1 === p : e.util.schemaHasRules(p, e.RULES.all)), E = void 0 !== P && (e.opts.strictKeywords ? "object" == typeof P && Object.keys(P).length > 0 || !1 === P : e.util.schemaHasRules(P, e.RULES.all)), y = d.baseId;
                if (f || E) {
                    var R;
                    d.createErrors = !1, d.schema = h, d.schemaPath = o, d.errSchemaPath = c, s += " var " + u + " = errors; var " + v + " = true;  ";
                    var S = e.compositeRule;
                    e.compositeRule = d.compositeRule = !0, s += "  " + e.validate(d) + " ", d.baseId = y, d.createErrors = !0, s += "  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; }  ", e.compositeRule = d.compositeRule = S, f ? (s += " if (" + n + ") {  ", d.schema = e.schema.then, d.schemaPath = e.schemaPath + ".then", d.errSchemaPath = e.errSchemaPath + "/then", s += "  " + e.validate(d) + " ", d.baseId = y, s += " " + v + " = " + n + "; ", f && E ? s += " var " + (R = "ifClause" + t) + " = 'then'; " : R = "'then'", s += " } ", E && (s += " else { ")) : s += " if (!" + n + ") { ", E && (d.schema = e.schema.else, d.schemaPath = e.schemaPath + ".else", d.errSchemaPath = e.errSchemaPath + "/else", s += "  " + e.validate(d) + " ", d.baseId = y, s += " " + v + " = " + n + "; ", f && E ? s += " var " + (R = "ifClause" + t) + " = 'else'; " : R = "'else'", s += " } "), s += " if (!" + v + ") {   var err =   ", !1 !== e.createErrors ? (s += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { failingKeyword: " + R + " } ", !1 !== e.opts.messages && (s += " , message: 'should match \"' + " + R + " + '\" schema' "), e.opts.verbose && (s += " , schema: validate.schema" + o + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && i && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += " }   ", i && (s += " else { ");
                } else i && (s += " if (true) { ");
                return s;
            };
        },
        {}
    ],
    "aiPb": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, a, r) {
                var t = " ", s = e.level, l = e.dataLevel, h = e.schema[a], o = e.schemaPath + e.util.getProperty(a), i = e.errSchemaPath + "/" + a, c = !e.opts.allErrors, v = "data" + (l || ""), d = "valid" + s, n = "errs__" + s, m = e.util.copy(e), u = "";
                m.level++;
                var P = "valid" + m.level, p = "i" + s, f = m.dataLevel = e.dataLevel + 1, g = "data" + f, y = e.baseId;
                if (t += "var " + n + " = errors;var " + d + ";", Array.isArray(h)) {
                    var b = e.schema.additionalItems;
                    if (!1 === b) {
                        t += " " + d + " = " + v + ".length <= " + h.length + "; ";
                        var E = i;
                        i = e.errSchemaPath + "/additionalItems", t += "  if (!" + d + ") {   ";
                        var S = S || [];
                        S.push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { limit: " + h.length + " } ", !1 !== e.opts.messages && (t += " , message: 'should NOT have more than " + h.length + " items' "), e.opts.verbose && (t += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), t += " } ") : t += " {} ";
                        var j = t;
                        t = S.pop(), !e.compositeRule && c ? e.async ? t += " throw new ValidationError([" + j + "]); " : t += " validate.errors = [" + j + "]; return false; " : t += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } ", i = E, c && (u += "}", t += " else { ");
                    }
                    var R = h;
                    if (R) {
                        for(var I, O = -1, k = R.length - 1; O < k;)if (I = R[O += 1], e.opts.strictKeywords ? "object" == typeof I && Object.keys(I).length > 0 || !1 === I : e.util.schemaHasRules(I, e.RULES.all)) {
                            t += " " + P + " = true; if (" + v + ".length > " + O + ") { ";
                            var w = v + "[" + O + "]";
                            m.schema = I, m.schemaPath = o + "[" + O + "]", m.errSchemaPath = i + "/" + O, m.errorPath = e.util.getPathExpr(e.errorPath, O, e.opts.jsonPointers, !0), m.dataPathArr[f] = O;
                            var L = e.validate(m);
                            m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", t += " }  ", c && (t += " if (" + P + ") { ", u += "}");
                        }
                    }
                    if ("object" == typeof b && (e.opts.strictKeywords ? "object" == typeof b && Object.keys(b).length > 0 || !1 === b : e.util.schemaHasRules(b, e.RULES.all))) {
                        m.schema = b, m.schemaPath = e.schemaPath + ".additionalItems", m.errSchemaPath = e.errSchemaPath + "/additionalItems", t += " " + P + " = true; if (" + v + ".length > " + h.length + ") {  for (var " + p + " = " + h.length + "; " + p + " < " + v + ".length; " + p + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, p, e.opts.jsonPointers, !0);
                        w = v + "[" + p + "]";
                        m.dataPathArr[f] = p;
                        L = e.validate(m);
                        m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", c && (t += " if (!" + P + ") break; "), t += " } }  ", c && (t += " if (" + P + ") { ", u += "}");
                    }
                } else if (e.opts.strictKeywords ? "object" == typeof h && Object.keys(h).length > 0 || !1 === h : e.util.schemaHasRules(h, e.RULES.all)) {
                    m.schema = h, m.schemaPath = o, m.errSchemaPath = i, t += "  for (var " + p + " = 0; " + p + " < " + v + ".length; " + p + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, p, e.opts.jsonPointers, !0);
                    w = v + "[" + p + "]";
                    m.dataPathArr[f] = p;
                    L = e.validate(m);
                    m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", c && (t += " if (!" + P + ") break; "), t += " }";
                }
                return c && (t += " " + u + " if (" + n + " == errors) {"), t;
            };
        },
        {}
    ],
    "UJAl": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t, s = " ", o = e.level, i = e.dataLevel, m = e.schema[r], h = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, l = !e.opts.allErrors, d = "data" + (i || ""), n = e.opts.$data && m && m.$data;
                n ? (s += " var schema" + o + " = " + e.util.getData(m.$data, i, e.dataPathArr) + "; ", t = "schema" + o) : t = m;
                var c = "maximum" == r, v = c ? "exclusiveMaximum" : "exclusiveMinimum", p = e.schema[v], f = e.opts.$data && p && p.$data, b = c ? "<" : ">", P = c ? ">" : "<", E = void 0;
                if (!n && "number" != typeof m && void 0 !== m) throw new Error(r + " must be number");
                if (!f && void 0 !== p && "number" != typeof p && "boolean" != typeof p) throw new Error(v + " must be number or boolean");
                if (f) {
                    var y = e.util.getData(p.$data, i, e.dataPathArr), x = "exclusive" + o, w = "exclType" + o, g = "exclIsNumber" + o, S = "' + " + (k = "op" + o) + " + '";
                    s += " var schemaExcl" + o + " = " + y + "; ", s += " var " + x + "; var " + w + " = typeof " + (y = "schemaExcl" + o) + "; if (" + w + " != 'boolean' && " + w + " != 'undefined' && " + w + " != 'number') { ";
                    var $;
                    E = v;
                    ($ = $ || []).push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: '" + (E || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", !1 !== e.opts.messages && (s += " , message: '" + v + " should be boolean' "), e.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
                    var M = s;
                    s = $.pop(), !e.compositeRule && l ? e.async ? s += " throw new ValidationError([" + M + "]); " : s += " validate.errors = [" + M + "]; return false; " : s += " var err = " + M + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + w + " == 'number' ? ( (" + x + " = " + t + " === undefined || " + y + " " + b + "= " + t + ") ? " + d + " " + P + "= " + y + " : " + d + " " + P + " " + t + " ) : ( (" + x + " = " + y + " === true) ? " + d + " " + P + "= " + t + " : " + d + " " + P + " " + t + " ) || " + d + " !== " + d + ") { var op" + o + " = " + x + " ? '" + b + "' : '" + b + "='; ", void 0 === m && (E = v, u = e.errSchemaPath + "/" + v, t = y, n = f);
                } else {
                    S = b;
                    if ((g = "number" == typeof p) && n) {
                        var k = "'" + S + "'";
                        s += " if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " ( " + t + " === undefined || " + p + " " + b + "= " + t + " ? " + d + " " + P + "= " + p + " : " + d + " " + P + " " + t + " ) || " + d + " !== " + d + ") { ";
                    } else {
                        g && void 0 === m ? (x = !0, E = v, u = e.errSchemaPath + "/" + v, t = p, P += "=") : (g && (t = Math[c ? "min" : "max"](p, m)), p === (!g || t) ? (x = !0, E = v, u = e.errSchemaPath + "/" + v, P += "=") : (x = !1, S += "="));
                        k = "'" + S + "'";
                        s += " if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + d + " " + P + " " + t + " || " + d + " !== " + d + ") { ";
                    }
                }
                E = E || r, ($ = $ || []).push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: '" + (E || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + k + ", limit: " + t + ", exclusive: " + x + " } ", !1 !== e.opts.messages && (s += " , message: 'should be " + S + " ", s += n ? "' + " + t : t + "'"), e.opts.verbose && (s += " , schema:  ", s += n ? "validate.schema" + h : "" + m, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
                M = s;
                return s = $.pop(), !e.compositeRule && l ? e.async ? s += " throw new ValidationError([" + M + "]); " : s += " validate.errors = [" + M + "]; return false; " : s += " var err = " + M + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } ", l && (s += " else { "), s;
            };
        },
        {}
    ],
    "W8ih": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t, s = " ", o = e.level, m = e.dataLevel, h = e.schema[r], l = e.schemaPath + e.util.getProperty(r), i = e.errSchemaPath + "/" + r, d = !e.opts.allErrors, u = "data" + (m || ""), n = e.opts.$data && h && h.$data;
                if (n ? (s += " var schema" + o + " = " + e.util.getData(h.$data, m, e.dataPathArr) + "; ", t = "schema" + o) : t = h, !n && "number" != typeof h) throw new Error(r + " must be number");
                s += "if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + u + ".length " + ("maxItems" == r ? ">" : "<") + " " + t + ") { ";
                var c = r, p = p || [];
                p.push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: '" + (c || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { limit: " + t + " } ", !1 !== e.opts.messages && (s += " , message: 'should NOT have ", s += "maxItems" == r ? "more" : "fewer", s += " than ", s += n ? "' + " + t + " + '" : "" + h, s += " items' "), e.opts.verbose && (s += " , schema:  ", s += n ? "validate.schema" + l : "" + h, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
                var v = s;
                return s = p.pop(), !e.compositeRule && d ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", d && (s += " else { "), s;
            };
        },
        {}
    ],
    "fZGX": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t, s = " ", o = e.level, h = e.dataLevel, l = e.schema[r], m = e.schemaPath + e.util.getProperty(r), n = e.errSchemaPath + "/" + r, i = !e.opts.allErrors, u = "data" + (h || ""), c = e.opts.$data && l && l.$data;
                if (c ? (s += " var schema" + o + " = " + e.util.getData(l.$data, h, e.dataPathArr) + "; ", t = "schema" + o) : t = l, !c && "number" != typeof l) throw new Error(r + " must be number");
                var d = "maxLength" == r ? ">" : "<";
                s += "if ( ", c && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), !1 === e.opts.unicode ? s += " " + u + ".length " : s += " ucs2length(" + u + ") ", s += " " + d + " " + t + ") { ";
                var p = r, v = v || [];
                v.push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: '" + (p || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(n) + " , params: { limit: " + t + " } ", !1 !== e.opts.messages && (s += " , message: 'should NOT be ", s += "maxLength" == r ? "longer" : "shorter", s += " than ", s += c ? "' + " + t + " + '" : "" + l, s += " characters' "), e.opts.verbose && (s += " , schema:  ", s += c ? "validate.schema" + m : "" + l, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
                var g = s;
                return s = v.pop(), !e.compositeRule && i ? e.async ? s += " throw new ValidationError([" + g + "]); " : s += " validate.errors = [" + g + "]; return false; " : s += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", i && (s += " else { "), s;
            };
        },
        {}
    ],
    "JAEr": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t, s = " ", o = e.level, h = e.dataLevel, m = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, p = !e.opts.allErrors, d = "data" + (h || ""), u = e.opts.$data && m && m.$data;
                if (u ? (s += " var schema" + o + " = " + e.util.getData(m.$data, h, e.dataPathArr) + "; ", t = "schema" + o) : t = m, !u && "number" != typeof m) throw new Error(r + " must be number");
                s += "if ( ", u && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " Object.keys(" + d + ").length " + ("maxProperties" == r ? ">" : "<") + " " + t + ") { ";
                var n = r, c = c || [];
                c.push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: '" + (n || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { limit: " + t + " } ", !1 !== e.opts.messages && (s += " , message: 'should NOT have ", s += "maxProperties" == r ? "more" : "fewer", s += " than ", s += u ? "' + " + t + " + '" : "" + m, s += " properties' "), e.opts.verbose && (s += " , schema:  ", s += u ? "validate.schema" + i : "" + m, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
                var v = s;
                return s = c.pop(), !e.compositeRule && p ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", p && (s += " else { "), s;
            };
        },
        {}
    ],
    "oNPH": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t, s = " ", i = e.level, o = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), h = e.errSchemaPath + "/" + r, n = !e.opts.allErrors, m = "data" + (o || ""), u = e.opts.$data && l && l.$data;
                if (u ? (s += " var schema" + i + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", t = "schema" + i) : t = l, !u && "number" != typeof l) throw new Error(r + " must be number");
                s += "var division" + i + ";if (", u && (s += " " + t + " !== undefined && ( typeof " + t + " != 'number' || "), s += " (division" + i + " = " + m + " / " + t + ", ", e.opts.multipleOfPrecision ? s += " Math.abs(Math.round(division" + i + ") - division" + i + ") > 1e-" + e.opts.multipleOfPrecision + " " : s += " division" + i + " !== parseInt(division" + i + ") ", s += " ) ", u && (s += "  )  "), s += " ) {   ";
                var p = p || [];
                p.push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { multipleOf: " + t + " } ", !1 !== e.opts.messages && (s += " , message: 'should be multiple of ", s += u ? "' + " + t : t + "'"), e.opts.verbose && (s += " , schema:  ", s += u ? "validate.schema" + d : "" + l, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ";
                var v = s;
                return s = p.pop(), !e.compositeRule && n ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", n && (s += " else { "), s;
            };
        },
        {}
    ],
    "mmjm": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r, e, a) {
                var s = " ", t = r.level, o = r.dataLevel, l = r.schema[e], h = r.schemaPath + r.util.getProperty(e), c = r.errSchemaPath + "/" + e, i = !r.opts.allErrors, m = "data" + (o || ""), v = "errs__" + t, p = r.util.copy(r);
                p.level++;
                var u = "valid" + p.level;
                if (r.opts.strictKeywords ? "object" == typeof l && Object.keys(l).length > 0 || !1 === l : r.util.schemaHasRules(l, r.RULES.all)) {
                    p.schema = l, p.schemaPath = h, p.errSchemaPath = c, s += " var " + v + " = errors;  ";
                    var d, E = r.compositeRule;
                    r.compositeRule = p.compositeRule = !0, p.createErrors = !1, p.opts.allErrors && (d = p.opts.allErrors, p.opts.allErrors = !1), s += " " + r.validate(p) + " ", p.createErrors = !0, d && (p.opts.allErrors = d), r.compositeRule = p.compositeRule = E, s += " if (" + u + ") {   ";
                    var n = n || [];
                    n.push(s), s = "", !1 !== r.createErrors ? (s += " { keyword: 'not' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(c) + " , params: {} ", !1 !== r.opts.messages && (s += " , message: 'should NOT be valid' "), r.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ";
                    var P = s;
                    s = n.pop(), !r.compositeRule && i ? r.async ? s += " throw new ValidationError([" + P + "]); " : s += " validate.errors = [" + P + "]; return false; " : s += " var err = " + P + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else {  errors = " + v + "; if (vErrors !== null) { if (" + v + ") vErrors.length = " + v + "; else vErrors = null; } ", r.opts.allErrors && (s += " } ");
                } else s += "  var err =   ", !1 !== r.createErrors ? (s += " { keyword: 'not' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(c) + " , params: {} ", !1 !== r.opts.messages && (s += " , message: 'should NOT be valid' "), r.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i && (s += " if (false) { ");
                return s;
            };
        },
        {}
    ],
    "SSWF": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var s = " ", t = e.level, l = e.dataLevel, o = e.schema[r], i = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, v = "data" + (l || ""), m = "valid" + t, u = "errs__" + t, n = e.util.copy(e), p = "";
                n.level++;
                var d = "valid" + n.level, f = n.baseId, E = "prevValid" + t, P = "passingSchemas" + t;
                s += "var " + u + " = errors , " + E + " = false , " + m + " = false , " + P + " = null; ";
                var g = e.compositeRule;
                e.compositeRule = n.compositeRule = !0;
                var y = o;
                if (y) for(var R, S = -1, b = y.length - 1; S < b;)R = y[S += 1], (e.opts.strictKeywords ? "object" == typeof R && Object.keys(R).length > 0 || !1 === R : e.util.schemaHasRules(R, e.RULES.all)) ? (n.schema = R, n.schemaPath = i + "[" + S + "]", n.errSchemaPath = c + "/" + S, s += "  " + e.validate(n) + " ", n.baseId = f) : s += " var " + d + " = true; ", S && (s += " if (" + d + " && " + E + ") { " + m + " = false; " + P + " = [" + P + ", " + S + "]; } else { ", p += "}"), s += " if (" + d + ") { " + m + " = " + E + " = true; " + P + " = " + S + "; }";
                return e.compositeRule = n.compositeRule = g, s += p + "if (!" + m + ") {   var err =   ", !1 !== e.createErrors ? (s += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { passingSchemas: " + P + " } ", !1 !== e.opts.messages && (s += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (s += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && h && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += "} else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; }", e.opts.allErrors && (s += " } "), s;
            };
        },
        {}
    ],
    "mGZS": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, t, a) {
                var r, s = " ", o = e.level, h = e.dataLevel, l = e.schema[t], u = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, i = !e.opts.allErrors, n = "data" + (h || ""), p = e.opts.$data && l && l.$data;
                p ? (s += " var schema" + o + " = " + e.util.getData(l.$data, h, e.dataPathArr) + "; ", r = "schema" + o) : r = l, s += "if ( ", p && (s += " (" + r + " !== undefined && typeof " + r + " != 'string') || "), s += " !" + (p ? "(new RegExp(" + r + "))" : e.usePattern(l)) + ".test(" + n + ") ) {   ";
                var c = c || [];
                c.push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { pattern:  ", s += p ? "" + r : "" + e.util.toQuotedString(l), s += "  } ", !1 !== e.opts.messages && (s += " , message: 'should match pattern \"", s += p ? "' + " + r + " + '" : "" + e.util.escapeQuotes(l), s += "\"' "), e.opts.verbose && (s += " , schema:  ", s += p ? "validate.schema" + u : "" + e.util.toQuotedString(l), s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), s += " } ") : s += " {} ";
                var m = s;
                return s = c.pop(), !e.compositeRule && i ? e.async ? s += " throw new ValidationError([" + m + "]); " : s += " validate.errors = [" + m + "]; return false; " : s += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", i && (s += " else { "), s;
            };
        },
        {}
    ],
    "jFnx": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, t) {
                var a = " ", o = e.level, s = e.dataLevel, i = e.schema[r], l = e.schemaPath + e.util.getProperty(r), h = e.errSchemaPath + "/" + r, p = !e.opts.allErrors, d = "data" + (s || ""), n = "errs__" + o, c = e.util.copy(e), P = "";
                c.level++;
                var u = "valid" + c.level, v = "key" + o, f = "idx" + o, m = c.dataLevel = e.dataLevel + 1, g = "data" + m, y = "dataProperties" + o, b = Object.keys(i || {}).filter(x), j = e.schema.patternProperties || {}, O = Object.keys(j).filter(x), S = e.schema.additionalProperties, E = b.length || O.length, R = !1 === S, k = "object" == typeof S && Object.keys(S).length, w = e.opts.removeAdditional, _ = R || k || w, Q = e.opts.ownProperties, A = e.baseId, D = e.schema.required;
                if (D && (!e.opts.$data || !D.$data) && D.length < e.opts.loopRequired) var q = e.util.toHash(D);
                function x(e) {
                    return "__proto__" !== e;
                }
                if (a += "var " + n + " = errors;var " + u + " = true;", Q && (a += " var " + y + " = undefined;"), _) {
                    if (a += Q ? " " + y + " = " + y + " || Object.keys(" + d + "); for (var " + f + "=0; " + f + "<" + y + ".length; " + f + "++) { var " + v + " = " + y + "[" + f + "]; " : " for (var " + v + " in " + d + ") { ", E) {
                        if (a += " var isAdditional" + o + " = !(false ", b.length) {
                            if (b.length > 8) a += " || validate.schema" + l + ".hasOwnProperty(" + v + ") ";
                            else {
                                var I = b;
                                if (I) for(var L = -1, H = I.length - 1; L < H;)M = I[L += 1], a += " || " + v + " == " + e.util.toQuotedString(M) + " ";
                            }
                        }
                        if (O.length) {
                            var F = O;
                            if (F) for(var K = -1, U = F.length - 1; K < U;)se = F[K += 1], a += " || " + e.usePattern(se) + ".test(" + v + ") ";
                        }
                        a += " ); if (isAdditional" + o + ") { ";
                    }
                    if ("all" == w) a += " delete " + d + "[" + v + "]; ";
                    else {
                        var V = e.errorPath, $ = "' + " + v + " + '";
                        if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers)), R) {
                            if (w) a += " delete " + d + "[" + v + "]; ";
                            else {
                                a += " " + u + " = false; ";
                                var N = h;
                                h = e.errSchemaPath + "/additionalProperties", (te = te || []).push(a), a = "", !1 !== e.createErrors ? (a += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { additionalProperty: '" + $ + "' } ", !1 !== e.opts.messages && (a += " , message: '", e.opts._errorDataPathProperty ? a += "is an invalid additional property" : a += "should NOT have additional properties", a += "' "), e.opts.verbose && (a += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), a += " } ") : a += " {} ";
                                var T = a;
                                a = te.pop(), !e.compositeRule && p ? e.async ? a += " throw new ValidationError([" + T + "]); " : a += " validate.errors = [" + T + "]; return false; " : a += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h = N, p && (a += " break; ");
                            }
                        } else if (k) {
                            if ("failing" == w) {
                                a += " var " + n + " = errors;  ";
                                var z = e.compositeRule;
                                e.compositeRule = c.compositeRule = !0, c.schema = S, c.schemaPath = e.schemaPath + ".additionalProperties", c.errSchemaPath = e.errSchemaPath + "/additionalProperties", c.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                                var B = d + "[" + v + "]";
                                c.dataPathArr[m] = v;
                                var C = e.validate(c);
                                c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", a += " if (!" + u + ") { errors = " + n + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + d + "[" + v + "]; }  ", e.compositeRule = c.compositeRule = z;
                            } else {
                                c.schema = S, c.schemaPath = e.schemaPath + ".additionalProperties", c.errSchemaPath = e.errSchemaPath + "/additionalProperties", c.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                                B = d + "[" + v + "]";
                                c.dataPathArr[m] = v;
                                C = e.validate(c);
                                c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", p && (a += " if (!" + u + ") break; ");
                            }
                        }
                        e.errorPath = V;
                    }
                    E && (a += " } "), a += " }  ", p && (a += " if (" + u + ") { ", P += "}");
                }
                var G = e.opts.useDefaults && !e.compositeRule;
                if (b.length) {
                    var J = b;
                    if (J) for(var M, W = -1, X = J.length - 1; W < X;){
                        var Y = i[M = J[W += 1]];
                        if (e.opts.strictKeywords ? "object" == typeof Y && Object.keys(Y).length > 0 || !1 === Y : e.util.schemaHasRules(Y, e.RULES.all)) {
                            var Z = e.util.getProperty(M), ee = (B = d + Z, G && void 0 !== Y.default);
                            c.schema = Y, c.schemaPath = l + Z, c.errSchemaPath = h + "/" + e.util.escapeFragment(M), c.errorPath = e.util.getPath(e.errorPath, M, e.opts.jsonPointers), c.dataPathArr[m] = e.util.toQuotedString(M);
                            C = e.validate(c);
                            if (c.baseId = A, e.util.varOccurences(C, g) < 2) {
                                C = e.util.varReplace(C, g, B);
                                var re = B;
                            } else {
                                re = g;
                                a += " var " + g + " = " + B + "; ";
                            }
                            if (ee) a += " " + C + " ";
                            else {
                                if (q && q[M]) {
                                    a += " if ( " + re + " === undefined ", Q && (a += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += ") { " + u + " = false; ";
                                    V = e.errorPath, N = h;
                                    var te, ae = e.util.escapeQuotes(M);
                                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(V, M, e.opts.jsonPointers)), h = e.errSchemaPath + "/required", (te = te || []).push(a), a = "", !1 !== e.createErrors ? (a += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { missingProperty: '" + ae + "' } ", !1 !== e.opts.messages && (a += " , message: '", e.opts._errorDataPathProperty ? a += "is a required property" : a += "should have required property \\'" + ae + "\\'", a += "' "), e.opts.verbose && (a += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), a += " } ") : a += " {} ";
                                    T = a;
                                    a = te.pop(), !e.compositeRule && p ? e.async ? a += " throw new ValidationError([" + T + "]); " : a += " validate.errors = [" + T + "]; return false; " : a += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h = N, e.errorPath = V, a += " } else { ";
                                } else p ? (a += " if ( " + re + " === undefined ", Q && (a += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += ") { " + u + " = true; } else { ") : (a += " if (" + re + " !== undefined ", Q && (a += " &&   Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += " ) { ");
                                a += " " + C + " } ";
                            }
                        }
                        p && (a += " if (" + u + ") { ", P += "}");
                    }
                }
                if (O.length) {
                    var oe = O;
                    if (oe) for(var se, ie = -1, le = oe.length - 1; ie < le;){
                        Y = j[se = oe[ie += 1]];
                        if (e.opts.strictKeywords ? "object" == typeof Y && Object.keys(Y).length > 0 || !1 === Y : e.util.schemaHasRules(Y, e.RULES.all)) {
                            c.schema = Y, c.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(se), c.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(se), a += Q ? " " + y + " = " + y + " || Object.keys(" + d + "); for (var " + f + "=0; " + f + "<" + y + ".length; " + f + "++) { var " + v + " = " + y + "[" + f + "]; " : " for (var " + v + " in " + d + ") { ", a += " if (" + e.usePattern(se) + ".test(" + v + ")) { ", c.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                            B = d + "[" + v + "]";
                            c.dataPathArr[m] = v;
                            C = e.validate(c);
                            c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", p && (a += " if (!" + u + ") break; "), a += " } ", p && (a += " else " + u + " = true; "), a += " }  ", p && (a += " if (" + u + ") { ", P += "}");
                        }
                    }
                }
                return p && (a += " " + P + " if (" + n + " == errors) {"), a;
            };
        },
        {}
    ],
    "XxjR": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r, e, a) {
                var t = " ", s = r.level, o = r.dataLevel, l = r.schema[e], i = r.schemaPath + r.util.getProperty(e), v = r.errSchemaPath + "/" + e, c = !r.opts.allErrors, p = "data" + (o || ""), m = "errs__" + s, h = r.util.copy(r);
                h.level++;
                var d = "valid" + h.level;
                if (t += "var " + m + " = errors;", r.opts.strictKeywords ? "object" == typeof l && Object.keys(l).length > 0 || !1 === l : r.util.schemaHasRules(l, r.RULES.all)) {
                    h.schema = l, h.schemaPath = i, h.errSchemaPath = v;
                    var u = "key" + s, n = "idx" + s, y = "i" + s, E = "' + " + u + " + '", P = "data" + (h.dataLevel = r.dataLevel + 1), f = "dataProperties" + s, R = r.opts.ownProperties, b = r.baseId;
                    R && (t += " var " + f + " = undefined; "), t += R ? " " + f + " = " + f + " || Object.keys(" + p + "); for (var " + n + "=0; " + n + "<" + f + ".length; " + n + "++) { var " + u + " = " + f + "[" + n + "]; " : " for (var " + u + " in " + p + ") { ", t += " var startErrs" + s + " = errors; ";
                    var g = u, k = r.compositeRule;
                    r.compositeRule = h.compositeRule = !0;
                    var w = r.validate(h);
                    h.baseId = b, r.util.varOccurences(w, P) < 2 ? t += " " + r.util.varReplace(w, P, g) + " " : t += " var " + P + " = " + g + "; " + w + " ", r.compositeRule = h.compositeRule = k, t += " if (!" + d + ") { for (var " + y + "=startErrs" + s + "; " + y + "<errors; " + y + "++) { vErrors[" + y + "].propertyName = " + u + "; }   var err =   ", !1 !== r.createErrors ? (t += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(v) + " , params: { propertyName: '" + E + "' } ", !1 !== r.opts.messages && (t += " , message: 'property name \\'" + E + "\\' is invalid' "), r.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + p + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !r.compositeRule && c && (r.async ? t += " throw new ValidationError(vErrors); " : t += " validate.errors = vErrors; return false; "), c && (t += " break; "), t += " } }";
                }
                return c && (t += "  if (" + m + " == errors) {"), t;
            };
        },
        {}
    ],
    "Dht1": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(r, e, a) {
                var t = " ", s = r.level, o = r.dataLevel, i = r.schema[e], h = r.schemaPath + r.util.getProperty(e), p = r.errSchemaPath + "/" + e, l = !r.opts.allErrors, d = "data" + (o || ""), u = "valid" + s, P = r.opts.$data && i && i.$data;
                P && (t += " var schema" + s + " = " + r.util.getData(i.$data, o, r.dataPathArr) + "; ");
                var n = "schema" + s;
                if (!P) {
                    if (i.length < r.opts.loopRequired && r.schema.properties && Object.keys(r.schema.properties).length) {
                        var c = [], m = i;
                        if (m) for(var v, y = -1, g = m.length - 1; y < g;){
                            v = m[y += 1];
                            var f = r.schema.properties[v];
                            f && (r.opts.strictKeywords ? "object" == typeof f && Object.keys(f).length > 0 || !1 === f : r.util.schemaHasRules(f, r.RULES.all)) || (c[c.length] = v);
                        }
                    } else c = i;
                }
                if (P || c.length) {
                    var E = r.errorPath, q = P || c.length >= r.opts.loopRequired, w = r.opts.ownProperties;
                    if (l) {
                        if (t += " var missing" + s + "; ", q) {
                            P || (t += " var " + n + " = validate.schema" + h + "; ");
                            var b = "' + " + (_ = "schema" + s + "[" + (D = "i" + s) + "]") + " + '";
                            r.opts._errorDataPathProperty && (r.errorPath = r.util.getPathExpr(E, _, r.opts.jsonPointers)), t += " var " + u + " = true; ", P && (t += " if (schema" + s + " === undefined) " + u + " = true; else if (!Array.isArray(schema" + s + ")) " + u + " = false; else {"), t += " for (var " + D + " = 0; " + D + " < " + n + ".length; " + D + "++) { " + u + " = " + d + "[" + n + "[" + D + "]] !== undefined ", w && (t += " &&   Object.prototype.hasOwnProperty.call(" + d + ", " + n + "[" + D + "]) "), t += "; if (!" + u + ") break; } ", P && (t += "  }  "), t += "  if (!" + u + ") {   ", (Q = Q || []).push(t), t = "", !1 !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", !1 !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ";
                            var S = t;
                            t = Q.pop(), !r.compositeRule && l ? r.async ? t += " throw new ValidationError([" + S + "]); " : t += " validate.errors = [" + S + "]; return false; " : t += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ";
                        } else {
                            t += " if ( ";
                            var j = c;
                            if (j) for(var D = -1, O = j.length - 1; D < O;)R = j[D += 1], D && (t += " || "), t += " ( ( " + (L = d + ($ = r.util.getProperty(R))) + " === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + r.util.escapeQuotes(R) + "') "), t += ") && (missing" + s + " = " + r.util.toQuotedString(r.opts.jsonPointers ? R : $) + ") ) ";
                            t += ") {  ";
                            var Q;
                            b = "' + " + (_ = "missing" + s) + " + '";
                            r.opts._errorDataPathProperty && (r.errorPath = r.opts.jsonPointers ? r.util.getPathExpr(E, _, !0) : E + " + " + _), (Q = Q || []).push(t), t = "", !1 !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", !1 !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ";
                            S = t;
                            t = Q.pop(), !r.compositeRule && l ? r.async ? t += " throw new ValidationError([" + S + "]); " : t += " validate.errors = [" + S + "]; return false; " : t += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ";
                        }
                    } else if (q) {
                        P || (t += " var " + n + " = validate.schema" + h + "; ");
                        var _;
                        b = "' + " + (_ = "schema" + s + "[" + (D = "i" + s) + "]") + " + '";
                        r.opts._errorDataPathProperty && (r.errorPath = r.util.getPathExpr(E, _, r.opts.jsonPointers)), P && (t += " if (" + n + " && !Array.isArray(" + n + ")) {  var err =   ", !1 !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", !1 !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + n + " !== undefined) { "), t += " for (var " + D + " = 0; " + D + " < " + n + ".length; " + D + "++) { if (" + d + "[" + n + "[" + D + "]] === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", " + n + "[" + D + "]) "), t += ") {  var err =   ", !1 !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", !1 !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", P && (t += "  }  ");
                    } else {
                        var k = c;
                        if (k) for(var R, A = -1, x = k.length - 1; A < x;){
                            R = k[A += 1];
                            var $ = r.util.getProperty(R), L = (b = r.util.escapeQuotes(R), d + $);
                            r.opts._errorDataPathProperty && (r.errorPath = r.util.getPath(E, R, r.opts.jsonPointers)), t += " if ( " + L + " === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + r.util.escapeQuotes(R) + "') "), t += ") {  var err =   ", !1 !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", !1 !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                        }
                    }
                    r.errorPath = E;
                } else l && (t += " if (true) {");
                return t;
            };
        },
        {}
    ],
    "mmFQ": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, a, r) {
                var t, i = " ", s = e.level, o = e.dataLevel, m = e.schema[a], l = e.schemaPath + e.util.getProperty(a), c = e.errSchemaPath + "/" + a, u = !e.opts.allErrors, d = "data" + (o || ""), h = "valid" + s, n = e.opts.$data && m && m.$data;
                if (n ? (i += " var schema" + s + " = " + e.util.getData(m.$data, o, e.dataPathArr) + "; ", t = "schema" + s) : t = m, (m || n) && !1 !== e.opts.uniqueItems) {
                    n && (i += " var " + h + "; if (" + t + " === false || " + t + " === undefined) " + h + " = true; else if (typeof " + t + " != 'boolean') " + h + " = false; else { "), i += " var i = " + d + ".length , " + h + " = true , j; if (i > 1) { ";
                    var f = e.schema.items && e.schema.items.type, v = Array.isArray(f);
                    if (!f || "object" == f || "array" == f || v && (f.indexOf("object") >= 0 || f.indexOf("array") >= 0)) i += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + d + "[i], " + d + "[j])) { " + h + " = false; break outer; } } } ";
                    else {
                        i += " var itemIndices = {}, item; for (;i--;) { var item = " + d + "[i]; ";
                        var p = "checkDataType" + (v ? "s" : "");
                        i += " if (" + e.util[p](f, "item", e.opts.strictNumbers, !0) + ") continue; ", v && (i += " if (typeof item == 'string') item = '\"' + item; "), i += " if (typeof itemIndices[item] == 'number') { " + h + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
                    }
                    i += " } ", n && (i += "  }  "), i += " if (!" + h + ") {   ";
                    var y = y || [];
                    y.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { i: i, j: j } ", !1 !== e.opts.messages && (i += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (i += " , schema:  ", i += n ? "validate.schema" + l : "" + m, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), i += " } ") : i += " {} ";
                    var j = i;
                    i = y.pop(), !e.compositeRule && u ? e.async ? i += " throw new ValidationError([" + j + "]); " : i += " validate.errors = [" + j + "]; return false; " : i += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", u && (i += " else { ");
                } else u && (i += " if (true) { ");
                return i;
            };
        },
        {}
    ],
    "Czyc": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = {
                $ref: require1("./ref"),
                allOf: require1("./allOf"),
                anyOf: require1("./anyOf"),
                $comment: require1("./comment"),
                const: require1("./const"),
                contains: require1("./contains"),
                dependencies: require1("./dependencies"),
                enum: require1("./enum"),
                format: require1("./format"),
                if: require1("./if"),
                items: require1("./items"),
                maximum: require1("./_limit"),
                minimum: require1("./_limit"),
                maxItems: require1("./_limitItems"),
                minItems: require1("./_limitItems"),
                maxLength: require1("./_limitLength"),
                minLength: require1("./_limitLength"),
                maxProperties: require1("./_limitProperties"),
                minProperties: require1("./_limitProperties"),
                multipleOf: require1("./multipleOf"),
                not: require1("./not"),
                oneOf: require1("./oneOf"),
                pattern: require1("./pattern"),
                properties: require1("./properties"),
                propertyNames: require1("./propertyNames"),
                required: require1("./required"),
                uniqueItems: require1("./uniqueItems"),
                validate: require1("./validate")
            };
        },
        {
            "./ref": "a2na",
            "./allOf": "hRgn",
            "./anyOf": "lo6J",
            "./comment": "Kkzr",
            "./const": "U4sD",
            "./contains": "EypH",
            "./dependencies": "Cpp7",
            "./enum": "fqDY",
            "./format": "avoW",
            "./if": "JHQ3",
            "./items": "aiPb",
            "./_limit": "UJAl",
            "./_limitItems": "W8ih",
            "./_limitLength": "fZGX",
            "./_limitProperties": "JAEr",
            "./multipleOf": "oNPH",
            "./not": "mmjm",
            "./oneOf": "SSWF",
            "./pattern": "mGZS",
            "./properties": "jFnx",
            "./propertyNames": "XxjR",
            "./required": "Dht1",
            "./uniqueItems": "mmFQ",
            "./validate": "yhC1"
        }
    ],
    "vBP0": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("../dotjs"), t = require1("./util").toHash;
            module1.exports = function() {
                var n = [
                    {
                        type: "number",
                        rules: [
                            {
                                maximum: [
                                    "exclusiveMaximum"
                                ]
                            },
                            {
                                minimum: [
                                    "exclusiveMinimum"
                                ]
                            },
                            "multipleOf",
                            "format"
                        ]
                    },
                    {
                        type: "string",
                        rules: [
                            "maxLength",
                            "minLength",
                            "pattern",
                            "format"
                        ]
                    },
                    {
                        type: "array",
                        rules: [
                            "maxItems",
                            "minItems",
                            "items",
                            "contains",
                            "uniqueItems"
                        ]
                    },
                    {
                        type: "object",
                        rules: [
                            "maxProperties",
                            "minProperties",
                            "required",
                            "dependencies",
                            "propertyNames",
                            {
                                properties: [
                                    "additionalProperties",
                                    "patternProperties"
                                ]
                            }
                        ]
                    },
                    {
                        rules: [
                            "$ref",
                            "const",
                            "enum",
                            "not",
                            "anyOf",
                            "oneOf",
                            "allOf",
                            "if"
                        ]
                    }
                ], r = [
                    "type",
                    "$comment"
                ];
                return n.all = t(r), n.types = t([
                    "number",
                    "integer",
                    "string",
                    "array",
                    "object",
                    "boolean",
                    "null"
                ]), n.forEach(function(t) {
                    t.rules = t.rules.map(function(t) {
                        var i;
                        if ("object" == typeof t) {
                            var o = Object.keys(t)[0];
                            i = t[o], t = o, i.forEach(function(e) {
                                r.push(e), n.all[e] = !0;
                            });
                        }
                        return r.push(t), n.all[t] = {
                            keyword: t,
                            code: e[t],
                            implements: i
                        };
                    }), n.all.$comment = {
                        keyword: "$comment",
                        code: e.$comment
                    }, t.type && (n.types[t.type] = t);
                }), n.keywords = t(r.concat([
                    "$schema",
                    "$id",
                    "id",
                    "$data",
                    "$async",
                    "title",
                    "description",
                    "default",
                    "definitions",
                    "examples",
                    "readOnly",
                    "writeOnly",
                    "contentMediaType",
                    "contentEncoding",
                    "additionalItems",
                    "then",
                    "else"
                ])), n.custom = {}, n;
            };
        },
        {
            "../dotjs": "Czyc",
            "./util": "Q1F7"
        }
    ],
    "BunE": [
        function(require1, module1, exports) {
            "use strict";
            var e = [
                "multipleOf",
                "maximum",
                "exclusiveMaximum",
                "minimum",
                "exclusiveMinimum",
                "maxLength",
                "minLength",
                "pattern",
                "additionalItems",
                "maxItems",
                "minItems",
                "uniqueItems",
                "maxProperties",
                "minProperties",
                "required",
                "additionalProperties",
                "enum",
                "format",
                "const"
            ];
            module1.exports = function(t, i) {
                for(var r = 0; r < i.length; r++){
                    t = JSON.parse(JSON.stringify(t));
                    var m, a = i[r].split("/"), n = t;
                    for(m = 1; m < a.length; m++)n = n[a[m]];
                    for(m = 0; m < e.length; m++){
                        var s = e[m], o = n[s];
                        o && (n[s] = {
                            anyOf: [
                                o,
                                {
                                    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                                }
                            ]
                        });
                    }
                }
                return t;
            };
        },
        {}
    ],
    "mNRF": [
        function(require1, module1, exports) {
            "use strict";
            var n = require1("./error_classes").MissingRef;
            function e(t, r, o) {
                var i = this;
                if ("function" != typeof this._opts.loadSchema) throw new Error("options.loadSchema should be a function");
                "function" == typeof r && (o = r, r = void 0);
                var a = c(t).then(function() {
                    var e = i._addSchema(t, void 0, r);
                    return e.validate || function e(t) {
                        try {
                            return i._compile(t);
                        } catch (a) {
                            if (a instanceof n) return function o(e) {
                                var o = e.missingSchema;
                                if (h(o)) throw new Error("Schema " + o + " is loaded but " + e.missingRef + " cannot be resolved");
                                var a = i._loadingSchemas[o];
                                a || (a = i._loadingSchemas[o] = i._opts.loadSchema(o)).then(s, s);
                                return a.then(function(n) {
                                    if (!h(o)) return c(n).then(function() {
                                        h(o) || i.addSchema(n, o, void 0, r);
                                    });
                                }).then(function() {
                                    return function t(o) {
                                        try {
                                            return i._compile(o);
                                        } catch (e) {
                                            if (e instanceof n) return a(e);
                                            throw e;
                                        }
                                        function a(n) {
                                            var e = n.missingSchema;
                                            if (h(e)) throw new Error("Schema " + e + " is loaded but " + n.missingRef + " cannot be resolved");
                                            var a = i._loadingSchemas[e];
                                            return a || (a = i._loadingSchemas[e] = i._opts.loadSchema(e)).then(s, s), a.then(function(n) {
                                                if (!h(e)) return c(n).then(function() {
                                                    h(e) || i.addSchema(n, e, void 0, r);
                                                });
                                            }).then(function() {
                                                return t(o);
                                            });
                                            function s() {
                                                delete i._loadingSchemas[e];
                                            }
                                            function h(n) {
                                                return i._refs[n] || i._schemas[n];
                                            }
                                        }
                                    }(t);
                                });
                                function s() {
                                    delete i._loadingSchemas[o];
                                }
                                function h(n) {
                                    return i._refs[n] || i._schemas[n];
                                }
                            }(a);
                            throw a;
                        }
                        function o(n) {
                            var o = n.missingSchema;
                            if (h(o)) throw new Error("Schema " + o + " is loaded but " + n.missingRef + " cannot be resolved");
                            var a = i._loadingSchemas[o];
                            return a || (a = i._loadingSchemas[o] = i._opts.loadSchema(o)).then(s, s), a.then(function(n) {
                                if (!h(o)) return c(n).then(function() {
                                    h(o) || i.addSchema(n, o, void 0, r);
                                });
                            }).then(function() {
                                return e(t);
                            });
                            function s() {
                                delete i._loadingSchemas[o];
                            }
                            function h(n) {
                                return i._refs[n] || i._schemas[n];
                            }
                        }
                    }(e);
                });
                return o && a.then(function(n) {
                    o(null, n);
                }, o), a;
                function c(n) {
                    var t = n.$schema;
                    return t && !i.getSchema(t) ? e.call(i, {
                        $ref: t
                    }, !0) : Promise.resolve();
                }
            }
            module1.exports = e;
        },
        {
            "./error_classes": "OtNE"
        }
    ],
    "Mzku": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(a, r, e) {
                var t, s, o = " ", i = a.level, h = a.dataLevel, d = a.schema[r], l = a.schemaPath + a.util.getProperty(r), v = a.errSchemaPath + "/" + r, c = !a.opts.allErrors, n = "data" + (h || ""), m = "valid" + i, u = "errs__" + i, p = a.opts.$data && d && d.$data;
                p ? (o += " var schema" + i + " = " + a.util.getData(d.$data, h, a.dataPathArr) + "; ", s = "schema" + i) : s = d;
                var f, P, y, E, w, k = "definition" + i, g = this.definition, R = "";
                if (p && g.$data) {
                    w = "keywordValidate" + i;
                    var S = g.validateSchema;
                    o += " var " + k + " = RULES.custom['" + r + "'].definition; var " + w + " = " + k + ".validate;";
                } else {
                    if (!(E = a.useCustomRule(this, d, a.schema, a))) return;
                    s = "validate.schema" + l, w = E.code, f = g.compile, P = g.inline, y = g.macro;
                }
                var b = w + ".errors", $ = "i" + i, A = "ruleErr" + i, D = g.async;
                if (D && !a.async) throw new Error("async keyword in sync schema");
                if (P || y || (o += b + " = null;"), o += "var " + u + " = errors;var " + m + ";", p && g.$data && (R += "}", o += " if (" + s + " === undefined) { " + m + " = true; } else { ", S && (R += "}", o += " " + m + " = " + k + ".validateSchema(" + s + "); if (" + m + ") { ")), P) g.statements ? o += " " + E.validate + " " : o += " " + m + " = " + E.validate + "; ";
                else if (y) {
                    var V = a.util.copy(a);
                    R = "";
                    V.level++;
                    var x = "valid" + V.level;
                    V.schema = E.validate, V.schemaPath = "";
                    var C = a.compositeRule;
                    a.compositeRule = V.compositeRule = !0;
                    var L = a.validate(V).replace(/validate\.schema/g, w);
                    a.compositeRule = V.compositeRule = C, o += " " + L;
                } else {
                    (j = j || []).push(o), o = "", o += "  " + w + ".call( ", a.opts.passContext ? o += "this" : o += "self", f || !1 === g.schema ? o += " , " + n + " " : o += " , " + s + " , " + n + " , validate.schema" + a.schemaPath + " ", o += " , (dataPath || '')", '""' != a.errorPath && (o += " + " + a.errorPath);
                    var Q = h ? "data" + (h - 1 || "") : "parentData", _ = h ? a.dataPathArr[h] : "parentDataProperty", U = o += " , " + Q + " , " + _ + " , rootData )  ";
                    o = j.pop(), !1 === g.errors ? (o += " " + m + " = ", D && (o += "await "), o += U + "; ") : o += D ? " var " + (b = "customErrors" + i) + " = null; try { " + m + " = await " + U + "; } catch (e) { " + m + " = false; if (e instanceof ValidationError) " + b + " = e.errors; else throw e; } " : " " + b + " = null; " + m + " = " + U + "; ";
                }
                if (g.modifying && (o += " if (" + Q + ") " + n + " = " + Q + "[" + _ + "];"), o += "" + R, g.valid) c && (o += " if (true) { ");
                else {
                    var j;
                    o += " if ( ", void 0 === g.valid ? (o += " !", o += y ? "" + x : "" + m) : o += " " + !g.valid + " ", o += ") { ", t = this.keyword, (j = j || []).push(o), o = "", (j = j || []).push(o), o = "", !1 !== a.createErrors ? (o += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(v) + " , params: { keyword: '" + this.keyword + "' } ", !1 !== a.opts.messages && (o += " , message: 'should pass \"" + this.keyword + "\" keyword validation' "), a.opts.verbose && (o += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + n + " "), o += " } ") : o += " {} ";
                    var q = o;
                    o = j.pop(), !a.compositeRule && c ? a.async ? o += " throw new ValidationError([" + q + "]); " : o += " validate.errors = [" + q + "]; return false; " : o += " var err = " + q + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    var z = o;
                    o = j.pop(), P ? g.errors ? "full" != g.errors && (o += "  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + "; if (" + A + ".schemaPath === undefined) { " + A + '.schemaPath = "' + v + '"; } ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } ") : !1 === g.errors ? o += " " + z + " " : (o += " if (" + u + " == errors) { " + z + " } else {  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + "; if (" + A + ".schemaPath === undefined) { " + A + '.schemaPath = "' + v + '"; } ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } } ") : y ? (o += "   var err =   ", !1 !== a.createErrors ? (o += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(v) + " , params: { keyword: '" + this.keyword + "' } ", !1 !== a.opts.messages && (o += " , message: 'should pass \"" + this.keyword + "\" keyword validation' "), a.opts.verbose && (o += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + n + " "), o += " } ") : o += " {} ", o += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !a.compositeRule && c && (a.async ? o += " throw new ValidationError(vErrors); " : o += " validate.errors = vErrors; return false; ")) : !1 === g.errors ? o += " " + z + " " : (o += " if (Array.isArray(" + b + ")) { if (vErrors === null) vErrors = " + b + "; else vErrors = vErrors.concat(" + b + "); errors = vErrors.length;  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + ";  " + A + '.schemaPath = "' + v + '";  ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } } else { " + z + " } "), o += " } ", c && (o += " else { ");
                }
                return o;
            };
        },
        {}
    ],
    "ve7q": [
        function(require1, module1, exports) {
            module1.exports = {
                $schema: "http://json-schema.org/draft-07/schema#",
                $id: "http://json-schema.org/draft-07/schema#",
                title: "Core schema meta-schema",
                definitions: {
                    schemaArray: {
                        type: "array",
                        minItems: 1,
                        items: {
                            $ref: "#"
                        }
                    },
                    nonNegativeInteger: {
                        type: "integer",
                        minimum: 0
                    },
                    nonNegativeIntegerDefault0: {
                        allOf: [
                            {
                                $ref: "#/definitions/nonNegativeInteger"
                            },
                            {
                                default: 0
                            }
                        ]
                    },
                    simpleTypes: {
                        enum: [
                            "array",
                            "boolean",
                            "integer",
                            "null",
                            "number",
                            "object",
                            "string"
                        ]
                    },
                    stringArray: {
                        type: "array",
                        items: {
                            type: "string"
                        },
                        uniqueItems: !0,
                        default: []
                    }
                },
                type: [
                    "object",
                    "boolean"
                ],
                properties: {
                    $id: {
                        type: "string",
                        format: "uri-reference"
                    },
                    $schema: {
                        type: "string",
                        format: "uri"
                    },
                    $ref: {
                        type: "string",
                        format: "uri-reference"
                    },
                    $comment: {
                        type: "string"
                    },
                    title: {
                        type: "string"
                    },
                    description: {
                        type: "string"
                    },
                    default: !0,
                    readOnly: {
                        type: "boolean",
                        default: !1
                    },
                    examples: {
                        type: "array",
                        items: !0
                    },
                    multipleOf: {
                        type: "number",
                        exclusiveMinimum: 0
                    },
                    maximum: {
                        type: "number"
                    },
                    exclusiveMaximum: {
                        type: "number"
                    },
                    minimum: {
                        type: "number"
                    },
                    exclusiveMinimum: {
                        type: "number"
                    },
                    maxLength: {
                        $ref: "#/definitions/nonNegativeInteger"
                    },
                    minLength: {
                        $ref: "#/definitions/nonNegativeIntegerDefault0"
                    },
                    pattern: {
                        type: "string",
                        format: "regex"
                    },
                    additionalItems: {
                        $ref: "#"
                    },
                    items: {
                        anyOf: [
                            {
                                $ref: "#"
                            },
                            {
                                $ref: "#/definitions/schemaArray"
                            }
                        ],
                        default: !0
                    },
                    maxItems: {
                        $ref: "#/definitions/nonNegativeInteger"
                    },
                    minItems: {
                        $ref: "#/definitions/nonNegativeIntegerDefault0"
                    },
                    uniqueItems: {
                        type: "boolean",
                        default: !1
                    },
                    contains: {
                        $ref: "#"
                    },
                    maxProperties: {
                        $ref: "#/definitions/nonNegativeInteger"
                    },
                    minProperties: {
                        $ref: "#/definitions/nonNegativeIntegerDefault0"
                    },
                    required: {
                        $ref: "#/definitions/stringArray"
                    },
                    additionalProperties: {
                        $ref: "#"
                    },
                    definitions: {
                        type: "object",
                        additionalProperties: {
                            $ref: "#"
                        },
                        default: {}
                    },
                    properties: {
                        type: "object",
                        additionalProperties: {
                            $ref: "#"
                        },
                        default: {}
                    },
                    patternProperties: {
                        type: "object",
                        additionalProperties: {
                            $ref: "#"
                        },
                        propertyNames: {
                            format: "regex"
                        },
                        default: {}
                    },
                    dependencies: {
                        type: "object",
                        additionalProperties: {
                            anyOf: [
                                {
                                    $ref: "#"
                                },
                                {
                                    $ref: "#/definitions/stringArray"
                                }
                            ]
                        }
                    },
                    propertyNames: {
                        $ref: "#"
                    },
                    const: !0,
                    enum: {
                        type: "array",
                        items: !0,
                        minItems: 1,
                        uniqueItems: !0
                    },
                    type: {
                        anyOf: [
                            {
                                $ref: "#/definitions/simpleTypes"
                            },
                            {
                                type: "array",
                                items: {
                                    $ref: "#/definitions/simpleTypes"
                                },
                                minItems: 1,
                                uniqueItems: !0
                            }
                        ]
                    },
                    format: {
                        type: "string"
                    },
                    contentMediaType: {
                        type: "string"
                    },
                    contentEncoding: {
                        type: "string"
                    },
                    if: {
                        $ref: "#"
                    },
                    then: {
                        $ref: "#"
                    },
                    else: {
                        $ref: "#"
                    },
                    allOf: {
                        $ref: "#/definitions/schemaArray"
                    },
                    anyOf: {
                        $ref: "#/definitions/schemaArray"
                    },
                    oneOf: {
                        $ref: "#/definitions/schemaArray"
                    },
                    not: {
                        $ref: "#"
                    }
                },
                default: !0
            };
        },
        {}
    ],
    "GIYw": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./refs/json-schema-draft-07.json");
            module1.exports = {
                $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
                definitions: {
                    simpleTypes: e.definitions.simpleTypes
                },
                type: "object",
                dependencies: {
                    schema: [
                        "validate"
                    ],
                    $data: [
                        "validate"
                    ],
                    statements: [
                        "inline"
                    ],
                    valid: {
                        not: {
                            required: [
                                "macro"
                            ]
                        }
                    }
                },
                properties: {
                    type: e.properties.type,
                    schema: {
                        type: "boolean"
                    },
                    statements: {
                        type: "boolean"
                    },
                    dependencies: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    },
                    metaSchema: {
                        type: "object"
                    },
                    modifying: {
                        type: "boolean"
                    },
                    valid: {
                        type: "boolean"
                    },
                    $data: {
                        type: "boolean"
                    },
                    async: {
                        type: "boolean"
                    },
                    errors: {
                        anyOf: [
                            {
                                type: "boolean"
                            },
                            {
                                const: "full"
                            }
                        ]
                    }
                }
            };
        },
        {
            "./refs/json-schema-draft-07.json": "ve7q"
        }
    ],
    "UVv5": [
        function(require1, module1, exports) {
            "use strict";
            var e = /^[a-z_$][a-z0-9_$-]*$/i, r = require1("./dotjs/custom"), t = require1("./definition_schema");
            function i(t, i) {
                var o = this.RULES;
                if (o.keywords[t]) throw new Error("Keyword " + t + " is already defined");
                if (!e.test(t)) throw new Error("Keyword " + t + " is not a valid identifier");
                if (i) {
                    this.validateKeyword(i, !0);
                    var a = i.type;
                    if (Array.isArray(a)) for(var s = 0; s < a.length; s++)d(t, a[s], i);
                    else d(t, a, i);
                    var n = i.metaSchema;
                    n && (i.$data && this._opts.$data && (n = {
                        anyOf: [
                            n,
                            {
                                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                            }
                        ]
                    }), i.validateSchema = this.compile(n, !0));
                }
                function d(e, t, i) {
                    for(var a, s = 0; s < o.length; s++){
                        var n = o[s];
                        if (n.type == t) {
                            a = n;
                            break;
                        }
                    }
                    a || (a = {
                        type: t,
                        rules: []
                    }, o.push(a));
                    var d = {
                        keyword: e,
                        definition: i,
                        custom: !0,
                        code: r,
                        implements: i.implements
                    };
                    a.rules.push(d), o.custom[e] = d;
                }
                return o.keywords[t] = o.all[t] = !0, this;
            }
            function o(e) {
                var r = this.RULES.custom[e];
                return r ? r.definition : this.RULES.keywords[e] || !1;
            }
            function a(e) {
                var r = this.RULES;
                delete r.keywords[e], delete r.all[e], delete r.custom[e];
                for(var t = 0; t < r.length; t++)for(var i = r[t].rules, o = 0; o < i.length; o++)if (i[o].keyword == e) {
                    i.splice(o, 1);
                    break;
                }
                return this;
            }
            function s(e, r) {
                s.errors = null;
                var i = this._validateKeyword = this._validateKeyword || this.compile(t, !0);
                if (i(e)) return !0;
                if (s.errors = i.errors, r) throw new Error("custom keyword definition is invalid: " + this.errorsText(i.errors));
                return !1;
            }
            module1.exports = {
                add: i,
                get: o,
                remove: a,
                validate: s
            };
        },
        {
            "./dotjs/custom": "Mzku",
            "./definition_schema": "GIYw"
        }
    ],
    "xbmT": [
        function(require1, module1, exports) {
            module1.exports = {
                $schema: "http://json-schema.org/draft-07/schema#",
                $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
                description: "Meta-schema for $data reference (JSON Schema extension proposal)",
                type: "object",
                required: [
                    "$data"
                ],
                properties: {
                    $data: {
                        type: "string",
                        anyOf: [
                            {
                                format: "relative-json-pointer"
                            },
                            {
                                format: "json-pointer"
                            }
                        ]
                    }
                },
                additionalProperties: !1
            };
        },
        {}
    ],
    "hi5j": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./compile"), t = require1("./compile/resolve"), r = require1("./cache"), a = require1("./compile/schema_obj"), i = require1("fast-json-stable-stringify"), s = require1("./compile/formats"), o = require1("./compile/rules"), h = require1("./data"), n = require1("./compile/util");
            module1.exports = p, p.prototype.validate = u, p.prototype.compile = v, p.prototype.addSchema = _, p.prototype.addMetaSchema = g, p.prototype.validateSchema = y, p.prototype.getSchema = S, p.prototype.removeSchema = q, p.prototype.addFormat = x, p.prototype.errorsText = k, p.prototype._addSchema = E, p.prototype._compile = I, p.prototype.compileAsync = require1("./compile/async");
            var c = require1("./keyword");
            p.prototype.addKeyword = c.add, p.prototype.getKeyword = c.get, p.prototype.removeKeyword = c.remove, p.prototype.validateKeyword = c.validate;
            var d = require1("./compile/error_classes");
            p.ValidationError = d.Validation, p.MissingRefError = d.MissingRef, p.$dataMetaSchema = h;
            var l = "http://json-schema.org/draft-07/schema", m = [
                "removeAdditional",
                "useDefaults",
                "coerceTypes",
                "strictDefaults"
            ], f = [
                "/properties"
            ];
            function p(e) {
                if (!(this instanceof p)) return new p(e);
                e = this._opts = n.copy(e) || {}, O(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = s(e.format), this._cache = e.cache || new r, this._loadingSchemas = {}, this._compilations = [], this.RULES = o(), this._getId = M(e), e.loopRequired = e.loopRequired || 1 / 0, "property" == e.errorDataPath && (e._errorDataPathProperty = !0), void 0 === e.serialize && (e.serialize = i), this._metaOpts = F(this), e.formats && D(this), e.keywords && P(this), A(this), "object" == typeof e.meta && this.addMetaSchema(e.meta), e.nullable && this.addKeyword("nullable", {
                    metaSchema: {
                        type: "boolean"
                    }
                }), V(this);
            }
            function u(e, t) {
                var r;
                if ("string" == typeof e) {
                    if (!(r = this.getSchema(e))) throw new Error('no schema with key or ref "' + e + '"');
                } else {
                    var a = this._addSchema(e);
                    r = a.validate || this._compile(a);
                }
                var i = r(t);
                return !0 !== r.$async && (this.errors = r.errors), i;
            }
            function v(e, t) {
                var r = this._addSchema(e, void 0, t);
                return r.validate || this._compile(r);
            }
            function _(e, r, a, i) {
                if (Array.isArray(e)) {
                    for(var s = 0; s < e.length; s++)this.addSchema(e[s], void 0, a, i);
                    return this;
                }
                var o = this._getId(e);
                if (void 0 !== o && "string" != typeof o) throw new Error("schema id must be string");
                return T(this, r = t.normalizeId(r || o)), this._schemas[r] = this._addSchema(e, a, i, !0), this;
            }
            function g(e, t, r) {
                return this.addSchema(e, t, r, !0), this;
            }
            function y(e, t) {
                var r = e.$schema;
                if (void 0 !== r && "string" != typeof r) throw new Error("$schema must be a string");
                if (!(r = r || this._opts.defaultMeta || w(this))) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
                var a = this.validate(r, e);
                if (!a && t) {
                    var i = "schema is invalid: " + this.errorsText();
                    if ("log" != this._opts.validateSchema) throw new Error(i);
                    this.logger.error(i);
                }
                return a;
            }
            function w(e) {
                var t = e._opts.meta;
                return e._opts.defaultMeta = "object" == typeof t ? e._getId(t) || t : e.getSchema(l) ? l : void 0, e._opts.defaultMeta;
            }
            function S(e) {
                var t = $(this, e);
                switch(typeof t){
                    case "object":
                        return t.validate || this._compile(t);
                    case "string":
                        return this.getSchema(t);
                    case "undefined":
                        return b(this, e);
                }
            }
            function b(r, i) {
                var s = t.schema.call(r, {
                    schema: {}
                }, i);
                if (s) {
                    var o = s.schema, h = s.root, n = s.baseId, c = e.call(r, o, h, void 0, n);
                    return r._fragments[i] = new a({
                        ref: i,
                        fragment: !0,
                        schema: o,
                        root: h,
                        baseId: n,
                        validate: c
                    }), c;
                }
            }
            function $(e, r) {
                return r = t.normalizeId(r), e._schemas[r] || e._refs[r] || e._fragments[r];
            }
            function q(e) {
                if (e instanceof RegExp) return j(this, this._schemas, e), j(this, this._refs, e), this;
                switch(typeof e){
                    case "undefined":
                        return j(this, this._schemas), j(this, this._refs), this._cache.clear(), this;
                    case "string":
                        var r = $(this, e);
                        return r && this._cache.del(r.cacheKey), delete this._schemas[e], delete this._refs[e], this;
                    case "object":
                        var a = this._opts.serialize, i = a ? a(e) : e;
                        this._cache.del(i);
                        var s = this._getId(e);
                        s && (s = t.normalizeId(s), delete this._schemas[s], delete this._refs[s]);
                }
                return this;
            }
            function j(e, t, r) {
                for(var a in t){
                    var i = t[a];
                    i.meta || r && !r.test(a) || (e._cache.del(i.cacheKey), delete t[a]);
                }
            }
            function E(e, r, i, s) {
                if ("object" != typeof e && "boolean" != typeof e) throw new Error("schema should be object or boolean");
                var o = this._opts.serialize, h = o ? o(e) : e, n = this._cache.get(h);
                if (n) return n;
                s = s || !1 !== this._opts.addUsedSchema;
                var c = t.normalizeId(this._getId(e));
                c && s && T(this, c);
                var d, l = !1 !== this._opts.validateSchema && !r;
                l && !(d = c && c == t.normalizeId(e.$schema)) && this.validateSchema(e, !0);
                var m = t.ids.call(this, e), f = new a({
                    id: c,
                    schema: e,
                    localRefs: m,
                    cacheKey: h,
                    meta: i
                });
                return "#" != c[0] && s && (this._refs[c] = f), this._cache.put(h, f), l && d && this.validateSchema(e, !0), f;
            }
            function I(t, r) {
                if (t.compiling) return t.validate = s, s.schema = t.schema, s.errors = null, s.root = r || s, !0 === t.schema.$async && (s.$async = !0), s;
                var a, i;
                t.compiling = !0, t.meta && (a = this._opts, this._opts = this._metaOpts);
                try {
                    i = e.call(this, t.schema, r, t.localRefs);
                } catch (o) {
                    throw delete t.validate, o;
                } finally{
                    t.compiling = !1, t.meta && (this._opts = a);
                }
                return t.validate = i, t.refs = i.refs, t.refVal = i.refVal, t.root = i.root, i;
                function s() {
                    var e = t.validate, r = e.apply(this, arguments);
                    return s.errors = e.errors, r;
                }
            }
            function M(e) {
                switch(e.schemaId){
                    case "auto":
                        return R;
                    case "id":
                        return z;
                    default:
                        return K;
                }
            }
            function z(e) {
                return e.$id && this.logger.warn("schema $id ignored", e.$id), e.id;
            }
            function K(e) {
                return e.id && this.logger.warn("schema id ignored", e.id), e.$id;
            }
            function R(e) {
                if (e.$id && e.id && e.$id != e.id) throw new Error("schema $id is different from id");
                return e.$id || e.id;
            }
            function k(e, t) {
                if (!(e = e || this.errors)) return "No errors";
                for(var r = void 0 === (t = t || {}).separator ? ", " : t.separator, a = void 0 === t.dataVar ? "data" : t.dataVar, i = "", s = 0; s < e.length; s++){
                    var o = e[s];
                    o && (i += a + o.dataPath + " " + o.message + r);
                }
                return i.slice(0, -r.length);
            }
            function x(e, t) {
                return "string" == typeof t && (t = new RegExp(t)), this._formats[e] = t, this;
            }
            function A(e) {
                var t;
                if (e._opts.$data && (t = require1("./refs/data.json"), e.addMetaSchema(t, t.$id, !0)), !1 !== e._opts.meta) {
                    var r = require1("./refs/json-schema-draft-07.json");
                    e._opts.$data && (r = h(r, f)), e.addMetaSchema(r, l, !0), e._refs["http://json-schema.org/schema"] = l;
                }
            }
            function V(e) {
                var t = e._opts.schemas;
                if (t) {
                    if (Array.isArray(t)) e.addSchema(t);
                    else for(var r in t)e.addSchema(t[r], r);
                }
            }
            function D(e) {
                for(var t in e._opts.formats){
                    var r = e._opts.formats[t];
                    e.addFormat(t, r);
                }
            }
            function P(e) {
                for(var t in e._opts.keywords){
                    var r = e._opts.keywords[t];
                    e.addKeyword(t, r);
                }
            }
            function T(e, t) {
                if (e._schemas[t] || e._refs[t]) throw new Error('schema with key or id "' + t + '" already exists');
            }
            function F(e) {
                for(var t = n.copy(e._opts), r = 0; r < m.length; r++)delete t[m[r]];
                return t;
            }
            function O(e) {
                var t = e._opts.logger;
                if (!1 === t) e.logger = {
                    log: U,
                    warn: U,
                    error: U
                };
                else {
                    if (void 0 === t && (t = console), !("object" == typeof t && t.log && t.warn && t.error)) throw new Error("logger must implement log, warn and error methods");
                    e.logger = t;
                }
            }
            function U() {}
        },
        {
            "./compile": "qdYs",
            "./compile/resolve": "w10T",
            "./cache": "fXCy",
            "./compile/schema_obj": "HHLG",
            "fast-json-stable-stringify": "Xb3N",
            "./compile/formats": "dfAH",
            "./compile/rules": "vBP0",
            "./data": "BunE",
            "./compile/util": "Q1F7",
            "./compile/async": "mNRF",
            "./keyword": "UVv5",
            "./compile/error_classes": "OtNE",
            "./refs/data.json": "xbmT",
            "./refs/json-schema-draft-07.json": "ve7q"
        }
    ],
    "dhP9": [
        function(require1, module1, exports) {
            var Buffer = require1("buffer").Buffer;
            var r = require1("buffer").Buffer, e = {
                Object: Object,
                Array: Array,
                Function: Function,
                Number: Number,
                String: String,
                Date: Date,
                RegExp: RegExp
            };
            module1.exports = function n(t) {
                return void 0 !== r && (e.Buffer = r), "undefined" != typeof Promise && (e.Promise = Promise), n.definition = {
                    compile: function(r) {
                        if ("string" == typeof r) {
                            var e = i(r);
                            return function(r) {
                                return r instanceof e;
                            };
                        }
                        var n = r.map(i);
                        return function(r) {
                            for(var e = 0; e < n.length; e++)if (r instanceof n[e]) return !0;
                            return !1;
                        };
                    },
                    CONSTRUCTORS: e,
                    metaSchema: {
                        anyOf: [
                            {
                                type: "string"
                            },
                            {
                                type: "array",
                                items: {
                                    type: "string"
                                }
                            }
                        ]
                    }
                }, t.addKeyword("instanceof", n.definition), t;
                function i(r) {
                    var n = e[r];
                    if (n) return n;
                    throw new Error('invalid "instanceof" keyword value ' + r);
                }
            };
        },
        {
            "buffer": "dskh"
        }
    ],
    "uBCt": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(n) {
                return e.definition = {
                    type: "number",
                    macro: function(e, n) {
                        var r = e[0], i = e[1], o = n.exclusiveRange;
                        return function(e, n, r) {
                            if (void 0 !== r && "boolean" != typeof r) throw new Error("Invalid schema for exclusiveRange keyword, should be boolean");
                            if (e > n || r && e == n) throw new Error("There are no numbers in range");
                        }(r, i, o), !0 === o ? {
                            exclusiveMinimum: r,
                            exclusiveMaximum: i
                        } : {
                            minimum: r,
                            maximum: i
                        };
                    },
                    metaSchema: {
                        type: "array",
                        minItems: 2,
                        maxItems: 2,
                        items: {
                            type: "number"
                        }
                    }
                }, n.addKeyword("range", e.definition), n.addKeyword("exclusiveRange"), n;
            };
        },
        {}
    ],
    "AtCq": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(t) {
                return e.definition = {
                    type: "string",
                    inline: function(e, t, r) {
                        return function() {
                            try {
                                if ("object" == typeof r) return new RegExp(r.pattern, r.flags);
                                var e = r.match(/^\/(.*)\/([gimuy]*)$/);
                                if (e) return new RegExp(e[1], e[2]);
                                throw new Error("cannot parse string into RegExp");
                            } catch (t) {
                                throw console.error("regular expression", r, "is invalid"), t;
                            }
                        }() + ".test(data" + (e.dataLevel || "") + ")";
                    },
                    metaSchema: {
                        type: [
                            "string",
                            "object"
                        ],
                        properties: {
                            pattern: {
                                type: "string"
                            },
                            flags: {
                                type: "string"
                            }
                        },
                        required: [
                            "pattern"
                        ],
                        additionalProperties: !1
                    }
                }, t.addKeyword("regexp", e.definition), t;
            };
        },
        {}
    ],
    "yoml": [
        function(require1, module1, exports) {
            "use strict";
            var e = [
                "undefined",
                "string",
                "number",
                "object",
                "function",
                "boolean",
                "symbol"
            ];
            module1.exports = function t(n) {
                return t.definition = {
                    inline: function(e, t, n) {
                        var i = "data" + (e.dataLevel || "");
                        return "string" == typeof n ? "typeof " + i + ' == "' + n + '"' : (n = "validate.schema" + e.schemaPath + "." + t) + ".indexOf(typeof " + i + ") >= 0";
                    },
                    metaSchema: {
                        anyOf: [
                            {
                                type: "string",
                                enum: e
                            },
                            {
                                type: "array",
                                items: {
                                    type: "string",
                                    enum: e
                                }
                            }
                        ]
                    }
                }, n.addKeyword("typeof", t.definition), n;
            };
        },
        {}
    ],
    "FbE8": [
        function(require1, module1, exports) {
            "use strict";
            var t = {}, n = {
                timestamp: function() {
                    return Date.now();
                },
                datetime: function() {
                    return (new Date).toISOString();
                },
                date: function() {
                    return (new Date).toISOString().slice(0, 10);
                },
                time: function() {
                    return (new Date).toISOString().slice(11);
                },
                random: function() {
                    return Math.random();
                },
                randomint: function(t) {
                    var n = t && t.max || 2;
                    return function() {
                        return Math.floor(Math.random() * n);
                    };
                },
                seq: function(n) {
                    var r = n && n.name || "";
                    return t[r] = t[r] || 0, function() {
                        return t[r]++;
                    };
                }
            };
            module1.exports = function t(r) {
                return t.definition = {
                    compile: function(t, n, r) {
                        var i = {};
                        for(var o in t){
                            var u = t[o], a = e("string" == typeof u ? u : u.func);
                            i[o] = a.length ? a(u.args) : a;
                        }
                        return r.opts.useDefaults && !r.compositeRule ? function(n) {
                            for(var e in t)void 0 !== n[e] && ("empty" != r.opts.useDefaults || null !== n[e] && "" !== n[e]) || (n[e] = i[e]());
                            return !0;
                        } : function() {
                            return !0;
                        };
                    },
                    DEFAULTS: n,
                    metaSchema: {
                        type: "object",
                        additionalProperties: {
                            type: [
                                "string",
                                "object"
                            ],
                            additionalProperties: !1,
                            required: [
                                "func",
                                "args"
                            ],
                            properties: {
                                func: {
                                    type: "string"
                                },
                                args: {
                                    type: "object"
                                }
                            }
                        }
                    }
                }, r.addKeyword("dynamicDefaults", t.definition), r;
                function e(t) {
                    var r = n[t];
                    if (r) return r;
                    throw new Error('invalid "dynamicDefaults" keyword property value: ' + t);
                }
            };
        },
        {}
    ],
    "CJDR": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(r) {
                return e.definition = {
                    type: "object",
                    macro: function(e, r) {
                        if (!e) return !0;
                        var t = Object.keys(r.properties);
                        return 0 == t.length || {
                            required: t
                        };
                    },
                    metaSchema: {
                        type: "boolean"
                    },
                    dependencies: [
                        "properties"
                    ]
                }, r.addKeyword("allRequired", e.definition), r;
            };
        },
        {}
    ],
    "n1DR": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(t) {
                return e.definition = {
                    type: "object",
                    macro: function(e) {
                        return 0 == e.length || (1 == e.length ? {
                            required: e
                        } : {
                            anyOf: e.map(function(e) {
                                return {
                                    required: [
                                        e
                                    ]
                                };
                            })
                        });
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                }, t.addKeyword("anyRequired", e.definition), t;
            };
        },
        {}
    ],
    "XrCF": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(t) {
                return e.definition = {
                    type: "object",
                    macro: function(e) {
                        return 0 == e.length || (1 == e.length ? {
                            required: e
                        } : {
                            oneOf: e.map(function(e) {
                                return {
                                    required: [
                                        e
                                    ]
                                };
                            })
                        });
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                }, t.addKeyword("oneRequired", e.definition), t;
            };
        },
        {}
    ],
    "MFGI": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(t) {
                return e.definition = {
                    type: "object",
                    macro: function(e) {
                        return 0 == e.length || (1 == e.length ? {
                            not: {
                                required: e
                            }
                        } : {
                            not: {
                                anyOf: e.map(function(e) {
                                    return {
                                        required: [
                                            e
                                        ]
                                    };
                                })
                            }
                        });
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                }, t.addKeyword("prohibited", e.definition), t;
            };
        },
        {}
    ],
    "m7Ap": [
        function(require1, module1, exports) {
            "use strict";
            var e = [
                "number",
                "integer",
                "string",
                "boolean",
                "null"
            ];
            function r(r, t) {
                return r.map(function(r) {
                    var n = t.items && t.items.properties, i = n && n[r] && n[r].type;
                    return Array.isArray(i) ? i.indexOf("object") < 0 && i.indexOf("array") < 0 : e.indexOf(i) >= 0;
                });
            }
            module1.exports = function e(t) {
                return e.definition = {
                    type: "array",
                    compile: function(e, t, n) {
                        var i = n.util.equal, o = r(e, t);
                        return function(r) {
                            if (r.length > 1) for(var t = 0; t < e.length; t++){
                                var n, f = e[t];
                                if (o[t]) {
                                    var a = {};
                                    for(n = r.length; n--;)if (r[n] && "object" == typeof r[n]) {
                                        var u = r[n][f];
                                        if (!u || "object" != typeof u) {
                                            if ("string" == typeof u && (u = '"' + u), a[u]) return !1;
                                            a[u] = !0;
                                        }
                                    }
                                } else for(n = r.length; n--;)if (r[n] && "object" == typeof r[n]) {
                                    for(var p = n; p--;)if (r[p] && "object" == typeof r[p] && i(r[n][f], r[p][f])) return !1;
                                }
                            }
                            return !0;
                        };
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                }, t.addKeyword("uniqueItemProperties", e.definition), t;
            };
        },
        {}
    ],
    "R4Fp": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = {
                metaSchemaRef: t
            };
            var e = "http://json-schema.org/draft-07/schema";
            function t(t) {
                var a = t._opts.defaultMeta;
                return "string" == typeof a ? {
                    $ref: a
                } : t.getSchema(e) ? {
                    $ref: e
                } : (console.warn("meta schema not defined"), {});
            }
        },
        {}
    ],
    "kIuQ": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./_util");
            function r(e, r) {
                for(var i = e.split("/"), o = {}, n = o, a = 1; a < i.length; a++){
                    var p = i[a], s = a == i.length - 1;
                    p = t(p);
                    var u = n.properties = {}, f = void 0;
                    if (/[0-9]+/.test(p)) {
                        var c = +p;
                        for(f = n.items = []; c--;)f.push({});
                    }
                    n = s ? r : {}, u[p] = n, f && f.push(n);
                }
                return o;
            }
            function t(e) {
                return e.replace(/~1/g, "/").replace(/~0/g, "~");
            }
            module1.exports = function t(i) {
                return t.definition = {
                    type: "object",
                    macro: function(e) {
                        var t = [];
                        for(var i in e)t.push(r(i, e[i]));
                        return {
                            allOf: t
                        };
                    },
                    metaSchema: {
                        type: "object",
                        propertyNames: {
                            type: "string",
                            format: "json-pointer"
                        },
                        additionalProperties: e.metaSchemaRef(i)
                    }
                }, i.addKeyword("deepProperties", t.definition), i;
            };
        },
        {
            "./_util": "R4Fp"
        }
    ],
    "KB8y": [
        function(require1, module1, exports) {
            "use strict";
            function e(e, t) {
                var r = "data" + (t || "");
                if (!e) return r;
                for(var n = r, o = e.split("/"), u = 1; u < o.length; u++)n += " && " + (r += i(a(o[u])));
                return n;
            }
            module1.exports = function t(r) {
                return t.definition = {
                    type: "object",
                    inline: function(t, r, n) {
                        for(var i = "", a = 0; a < n.length; a++)a && (i += " && "), i += "(" + e(n[a], t.dataLevel) + " !== undefined)";
                        return i;
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string",
                            format: "json-pointer"
                        }
                    }
                }, r.addKeyword("deepRequired", t.definition), r;
            };
            var t = /^[a-z$_][a-z$_0-9]*$/i, r = /^[0-9]+$/, n = /'|\\/g;
            function i(e) {
                return r.test(e) ? "[" + e + "]" : t.test(e) ? "." + e : "['" + e.replace(n, "\\$&") + "']";
            }
            function a(e) {
                return e.replace(/~1/g, "/").replace(/~0/g, "~");
            }
        },
        {}
    ],
    "KeB4": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, a, r) {
                var t = " ", s = e.level, o = e.dataLevel, i = e.schema[a], l = e.schemaPath + e.util.getProperty(a), u = e.errSchemaPath + "/" + a, d = !e.opts.allErrors, m = "data" + (o || ""), f = "valid" + s;
                if (t += "var " + f + " = undefined;", !1 === e.opts.format) return t += " " + f + " = true; ";
                var n = e.schema.format, h = e.opts.$data && n.$data, c = "";
                if (h) t += " var " + (v = "format" + s) + " = formats[" + e.util.getData(n.$data, o, e.dataPathArr) + "] , " + (p = "compare" + s) + " = " + v + " && " + v + ".compare;";
                else {
                    var v;
                    if (!(v = e.formats[n]) || !v.compare) return t += "  " + f + " = true; ";
                    var p = "formats" + e.util.getProperty(n) + ".compare";
                }
                var g, P = "formatMaximum" == a, E = "formatExclusive" + (P ? "Maximum" : "Minimum"), x = e.schema[E], y = e.opts.$data && x && x.$data, S = P ? "<" : ">", $ = "result" + s, Q = e.opts.$data && i && i.$data;
                if (Q ? (t += " var schema" + s + " = " + e.util.getData(i.$data, o, e.dataPathArr) + "; ", g = "schema" + s) : g = i, y) {
                    var b = e.util.getData(x.$data, o, e.dataPathArr), w = "exclusive" + s, A = "' + " + (M = "op" + s) + " + '";
                    t += " var schemaExcl" + s + " = " + b + "; ", t += " if (typeof " + (b = "schemaExcl" + s) + " != 'boolean' && " + b + " !== undefined) { " + f + " = false; ";
                    var D = E;
                    (k = k || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: '" + (D || "_formatExclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", !1 !== e.opts.messages && (t += " , message: '" + E + " should be boolean' "), e.opts.verbose && (t += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                    var L = t;
                    t = k.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + L + "]); " : t += " validate.errors = [" + L + "]; return false; " : t += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }  ", d && (c += "}", t += " else { "), Q && (t += " if (" + g + " === undefined) " + f + " = true; else if (typeof " + g + " != 'string') " + f + " = false; else { ", c += "}"), h && (t += " if (!" + p + ") " + f + " = true; else { ", c += "}"), t += " var " + $ + " = " + p + "(" + m + ",  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " ); if (" + $ + " === undefined) " + f + " = false; var " + w + " = " + b + " === true; if (" + f + " === undefined) { " + f + " = " + w + " ? " + $ + " " + S + " 0 : " + $ + " " + S + "= 0; } if (!" + f + ") var op" + s + " = " + w + " ? '" + S + "' : '" + S + "=';";
                } else {
                    A = S;
                    (w = !0 === x) || (A += "=");
                    var M = "'" + A + "'";
                    Q && (t += " if (" + g + " === undefined) " + f + " = true; else if (typeof " + g + " != 'string') " + f + " = false; else { ", c += "}"), h && (t += " if (!" + p + ") " + f + " = true; else { ", c += "}"), t += " var " + $ + " = " + p + "(" + m + ",  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " ); if (" + $ + " === undefined) " + f + " = false; if (" + f + " === undefined) " + f + " = " + $ + " " + S, w || (t += "="), t += " 0;";
                }
                t += c + "if (!" + f + ") { ";
                var k;
                D = a;
                (k = k || []).push(t), t = "", !1 !== e.createErrors ? (t += " { keyword: '" + (D || "_formatLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + M + ", limit:  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " , exclusive: " + w + " } ", !1 !== e.opts.messages && (t += " , message: 'should be " + A + ' "', t += Q ? "' + " + g + " + '" : "" + e.util.escapeQuotes(i), t += "\"' "), e.opts.verbose && (t += " , schema:  ", t += Q ? "validate.schema" + l : "" + e.util.toQuotedString(i), t += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                L = t;
                return t = k.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + L + "]); " : t += " validate.errors = [" + L + "]; return false; " : t += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += "}";
            };
        },
        {}
    ],
    "mYD7": [
        function(require1, module1, exports) {
            "use strict";
            var t = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i, e = /t|\s/i, i = {
                date: n,
                time: o,
                "date-time": d
            }, r = {
                type: "object",
                required: [
                    "$data"
                ],
                properties: {
                    $data: {
                        type: "string",
                        anyOf: [
                            {
                                format: "relative-json-pointer"
                            },
                            {
                                format: "json-pointer"
                            }
                        ]
                    }
                },
                additionalProperties: !1
            };
            function a(t) {
                var e = t._formats;
                for(var r in i){
                    var a = e[r];
                    ("object" != typeof a || a instanceof RegExp || !a.validate) && (a = e[r] = {
                        validate: a
                    }), a.compare || (a.compare = i[r]);
                }
            }
            function n(t, e) {
                if (t && e) return t > e ? 1 : t < e ? -1 : t === e ? 0 : void 0;
            }
            function o(e, i) {
                if (e && i && (e = e.match(t), i = i.match(t), e && i)) return (e = e[1] + e[2] + e[3] + (e[4] || "")) > (i = i[1] + i[2] + i[3] + (i[4] || "")) ? 1 : e < i ? -1 : e === i ? 0 : void 0;
            }
            function d(t, i) {
                if (t && i) {
                    t = t.split(e), i = i.split(e);
                    var r = n(t[0], i[0]);
                    if (void 0 !== r) return r || o(t[1], i[1]);
                }
            }
            module1.exports = function(t) {
                var e = "format" + t;
                return function i(n) {
                    return i.definition = {
                        type: "string",
                        inline: require1("./dotjs/_formatLimit"),
                        statements: !0,
                        errors: "full",
                        dependencies: [
                            "format"
                        ],
                        metaSchema: {
                            anyOf: [
                                {
                                    type: "string"
                                },
                                r
                            ]
                        }
                    }, n.addKeyword(e, i.definition), n.addKeyword("formatExclusive" + t, {
                        dependencies: [
                            "format" + t
                        ],
                        metaSchema: {
                            anyOf: [
                                {
                                    type: "boolean"
                                },
                                r
                            ]
                        }
                    }), a(n), n;
                };
            };
        },
        {
            "./dotjs/_formatLimit": "KeB4"
        }
    ],
    "J927": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = require1("./_formatLimit")("Minimum");
        },
        {
            "./_formatLimit": "mYD7"
        }
    ],
    "dgLz": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = require1("./_formatLimit")("Maximum");
        },
        {
            "./_formatLimit": "mYD7"
        }
    ],
    "OTUE": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var t = " ", s = e.level, o = e.dataLevel, h = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, v = !e.opts.allErrors, n = "data" + (o || ""), d = "valid" + s, p = "key" + s, c = "idx" + s, u = "patternMatched" + s, m = "dataProperties" + s, P = "", f = e.opts.ownProperties;
                t += "var " + d + " = true;", f && (t += " var " + m + " = undefined;");
                var g = h;
                if (g) for(var y, E = -1, k = g.length - 1; E < k;){
                    y = g[E += 1], t += " var " + u + " = false;  ", t += f ? " " + m + " = " + m + " || Object.keys(" + n + "); for (var " + c + "=0; " + c + "<" + m + ".length; " + c + "++) { var " + p + " = " + m + "[" + c + "]; " : " for (var " + p + " in " + n + ") { ", t += " " + u + " = " + e.usePattern(y) + ".test(" + p + "); if (" + u + ") break; } ";
                    var b = e.util.escapeQuotes(y);
                    t += " if (!" + u + ") { " + d + " = false;  var err =   ", !1 !== e.createErrors ? (t += " { keyword: 'patternRequired' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { missingPattern: '" + b + "' } ", !1 !== e.opts.messages && (t += " , message: 'should have property matching pattern \\'" + b + "\\'' "), e.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ", v && (P += "}", t += " else { ");
                }
                return t += "" + P;
            };
        },
        {}
    ],
    "u2zM": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(t) {
                return e.definition = {
                    type: "object",
                    inline: require1("./dotjs/patternRequired"),
                    statements: !0,
                    errors: "full",
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string",
                            format: "regex"
                        },
                        uniqueItems: !0
                    }
                }, t.addKeyword("patternRequired", e.definition), t;
            };
        },
        {
            "./dotjs/patternRequired": "OTUE"
        }
    ],
    "mlCb": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function(e, r, a) {
                var s = " ", t = e.level, o = e.dataLevel, h = e.schema[r], l = e.schemaPath + e.util.getProperty(r), i = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, v = "data" + (o || ""), n = "valid" + t, d = "errs__" + t, m = e.util.copy(e), p = "";
                m.level++;
                var u, f = "valid" + m.level, P = "ifPassed" + e.level, E = m.baseId;
                s += "var " + P + ";";
                var w = h;
                if (w) for(var y, b = -1, g = w.length - 1; b < g;){
                    if (y = w[b += 1], b && !u && (s += " if (!" + P + ") { ", p += "}"), y.if && (e.opts.strictKeywords ? "object" == typeof y.if && Object.keys(y.if).length > 0 : e.util.schemaHasRules(y.if, e.RULES.all))) {
                        s += " var " + d + " = errors;   ";
                        var R = e.compositeRule;
                        if (e.compositeRule = m.compositeRule = !0, m.createErrors = !1, m.schema = y.if, m.schemaPath = l + "[" + b + "].if", m.errSchemaPath = i + "/" + b + "/if", s += "  " + e.validate(m) + " ", m.baseId = E, m.createErrors = !0, e.compositeRule = m.compositeRule = R, s += " " + P + " = " + f + "; if (" + P + ") {  ", "boolean" == typeof y.then) {
                            if (!1 === y.then) {
                                (I = I || []).push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: 'switch' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { caseIndex: " + b + " } ", !1 !== e.opts.messages && (s += " , message: 'should pass \"switch\" keyword validation' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ";
                                var S = s;
                                s = I.pop(), !e.compositeRule && c ? e.async ? s += " throw new ValidationError([" + S + "]); " : s += " validate.errors = [" + S + "]; return false; " : s += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                            }
                            s += " var " + f + " = " + y.then + "; ";
                        } else m.schema = y.then, m.schemaPath = l + "[" + b + "].then", m.errSchemaPath = i + "/" + b + "/then", s += "  " + e.validate(m) + " ", m.baseId = E;
                        s += "  } else {  errors = " + d + "; if (vErrors !== null) { if (" + d + ") vErrors.length = " + d + "; else vErrors = null; } } ";
                    } else if (s += " " + P + " = true;  ", "boolean" == typeof y.then) {
                        if (!1 === y.then) {
                            var I;
                            (I = I || []).push(s), s = "", !1 !== e.createErrors ? (s += " { keyword: 'switch' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { caseIndex: " + b + " } ", !1 !== e.opts.messages && (s += " , message: 'should pass \"switch\" keyword validation' "), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ";
                            S = s;
                            s = I.pop(), !e.compositeRule && c ? e.async ? s += " throw new ValidationError([" + S + "]); " : s += " validate.errors = [" + S + "]; return false; " : s += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                        }
                        s += " var " + f + " = " + y.then + "; ";
                    } else m.schema = y.then, m.schemaPath = l + "[" + b + "].then", m.errSchemaPath = i + "/" + b + "/then", s += "  " + e.validate(m) + " ", m.baseId = E;
                    u = y.continue;
                }
                return s += p + "var " + n + " = " + f + ";";
            };
        },
        {}
    ],
    "KC2b": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./_util");
            module1.exports = function i(t) {
                if (!t.RULES.keywords.switch || !t.RULES.keywords.if) {
                    var r = e.metaSchemaRef(t);
                    return i.definition = {
                        inline: require1("./dotjs/switch"),
                        statements: !0,
                        errors: "full",
                        metaSchema: {
                            type: "array",
                            items: {
                                required: [
                                    "then"
                                ],
                                properties: {
                                    if: r,
                                    then: {
                                        anyOf: [
                                            {
                                                type: "boolean"
                                            },
                                            r
                                        ]
                                    },
                                    continue: {
                                        type: "boolean"
                                    }
                                },
                                additionalProperties: !1,
                                dependencies: {
                                    continue: [
                                        "if"
                                    ]
                                }
                            }
                        }
                    }, t.addKeyword("switch", i.definition), t;
                }
            };
        },
        {
            "./_util": "R4Fp",
            "./dotjs/switch": "mlCb"
        }
    ],
    "mwue": [
        function(require1, module1, exports) {
            "use strict";
            var e = require1("./_util");
            module1.exports = function r(t) {
                if (!t._opts.$data) return console.warn("keyword select requires $data option"), t;
                var a = e.metaSchemaRef(t), n = [];
                return r.definition = {
                    validate: function e(r, t, a) {
                        if (void 0 === a.selectCases) throw new Error('keyword "selectCases" is absent');
                        var n = o(a, !1), i = n.cases[r];
                        if (void 0 === i && (i = n.default), "boolean" == typeof i) return i;
                        var s = i(t);
                        return s || (e.errors = i.errors), s;
                    },
                    $data: !0,
                    metaSchema: {
                        type: [
                            "string",
                            "number",
                            "boolean",
                            "null"
                        ]
                    }
                }, t.addKeyword("select", r.definition), t.addKeyword("selectCases", {
                    compile: function(e, r) {
                        var t = o(r);
                        for(var a in e)t.cases[a] = i(e[a]);
                        return function() {
                            return !0;
                        };
                    },
                    valid: !0,
                    metaSchema: {
                        type: "object",
                        additionalProperties: a
                    }
                }), t.addKeyword("selectDefault", {
                    compile: function(e, r) {
                        return o(r).default = i(e), function() {
                            return !0;
                        };
                    },
                    valid: !0,
                    metaSchema: a
                }), t;
                function o(e, r) {
                    var t;
                    return n.some(function(r) {
                        if (r.parentSchema === e) return t = r, !0;
                    }), t || !1 === r || (t = {
                        parentSchema: e,
                        cases: {},
                        default: !0
                    }, n.push(t)), t;
                }
                function i(e) {
                    return "boolean" == typeof e ? e : t.compile(e);
                }
            };
        },
        {
            "./_util": "R4Fp"
        }
    ],
    "selR": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = function e(r) {
                var n = {
                    trimLeft: function(e) {
                        return e.replace(/^[\s]+/, "");
                    },
                    trimRight: function(e) {
                        return e.replace(/[\s]+$/, "");
                    },
                    trim: function(e) {
                        return e.trim();
                    },
                    toLowerCase: function(e) {
                        return e.toLowerCase();
                    },
                    toUpperCase: function(e) {
                        return e.toUpperCase();
                    },
                    toEnumCase: function(e, r) {
                        return r.hash[t(e)] || e;
                    }
                };
                return e.definition = {
                    type: "string",
                    errors: !1,
                    modifying: !0,
                    valid: !0,
                    compile: function(e, r) {
                        var i;
                        if (-1 !== e.indexOf("toEnumCase")) {
                            if (i = {
                                hash: {}
                            }, !r.enum) throw new Error('Missing enum. To use `transform:["toEnumCase"]`, `enum:[...]` is required.');
                            for(var o = r.enum.length; o--; o){
                                var u = r.enum[o];
                                if ("string" == typeof u) {
                                    var s = t(u);
                                    if (i.hash[s]) throw new Error('Invalid enum uniqueness. To use `transform:["toEnumCase"]`, all values must be unique when case insensitive.');
                                    i.hash[s] = u;
                                }
                            }
                        }
                        return function(r, t, o, u) {
                            if (o) {
                                for(var s = 0, a = e.length; s < a; s++)r = n[e[s]](r, i);
                                o[u] = r;
                            }
                        };
                    },
                    metaSchema: {
                        type: "array",
                        items: {
                            type: "string",
                            enum: [
                                "trimLeft",
                                "trimRight",
                                "trim",
                                "toLowerCase",
                                "toUpperCase",
                                "toEnumCase"
                            ]
                        }
                    }
                }, r.addKeyword("transform", e.definition), r;
                function t(e) {
                    return e.toLowerCase();
                }
            };
        },
        {}
    ],
    "KP4Q": [
        function(require1, module1, exports) {
            "use strict";
            module1.exports = {
                instanceof: require1("./instanceof"),
                range: require1("./range"),
                regexp: require1("./regexp"),
                typeof: require1("./typeof"),
                dynamicDefaults: require1("./dynamicDefaults"),
                allRequired: require1("./allRequired"),
                anyRequired: require1("./anyRequired"),
                oneRequired: require1("./oneRequired"),
                prohibited: require1("./prohibited"),
                uniqueItemProperties: require1("./uniqueItemProperties"),
                deepProperties: require1("./deepProperties"),
                deepRequired: require1("./deepRequired"),
                formatMinimum: require1("./formatMinimum"),
                formatMaximum: require1("./formatMaximum"),
                patternRequired: require1("./patternRequired"),
                switch: require1("./switch"),
                select: require1("./select"),
                transform: require1("./transform")
            };
        },
        {
            "./instanceof": "dhP9",
            "./range": "uBCt",
            "./regexp": "AtCq",
            "./typeof": "yoml",
            "./dynamicDefaults": "FbE8",
            "./allRequired": "CJDR",
            "./anyRequired": "n1DR",
            "./oneRequired": "XrCF",
            "./prohibited": "MFGI",
            "./uniqueItemProperties": "m7Ap",
            "./deepProperties": "kIuQ",
            "./deepRequired": "KB8y",
            "./formatMinimum": "J927",
            "./formatMaximum": "dgLz",
            "./patternRequired": "u2zM",
            "./switch": "KC2b",
            "./select": "mwue",
            "./transform": "selR"
        }
    ],
    "n1A8": [
        function(require1, module1, exports) {
            "use strict";
            var r = require1("./keywords");
            function e(e, t) {
                if (Array.isArray(t)) {
                    for(var o = 0; o < t.length; o++)n(t[o])(e);
                    return e;
                }
                if (t) return n(t)(e), e;
                for(t in r)n(t)(e);
                return e;
            }
            function n(e) {
                var n = r[e];
                if (!n) throw new Error("Unknown keyword " + e);
                return n;
            }
            module1.exports = e, e.get = n;
        },
        {
            "./keywords": "KP4Q"
        }
    ],
    "STvH": [
        function(require1, module1, exports) {
            "use strict";
            function r(r) {
                if ("undefined" == typeof Symbol || null == r[Symbol.iterator]) {
                    if (Array.isArray(r) || (r = n(r))) {
                        var t = 0, e = function() {};
                        return {
                            s: e,
                            n: function() {
                                return t >= r.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: r[t++]
                                };
                            },
                            e: function(r) {
                                throw r;
                            },
                            f: e
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var o, a, i = !0, u = !1;
                return {
                    s: function() {
                        o = r[Symbol.iterator]();
                    },
                    n: function() {
                        var r = o.next();
                        return i = r.done, r;
                    },
                    e: function(r) {
                        u = !0, a = r;
                    },
                    f: function() {
                        try {
                            i || null == o.return || o.return();
                        } finally{
                            if (u) throw a;
                        }
                    }
                };
            }
            function t(r) {
                return a(r) || o(r) || n(r) || e();
            }
            function e() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function n(r, t) {
                if (r) {
                    if ("string" == typeof r) return i(r, t);
                    var e = Object.prototype.toString.call(r).slice(8, -1);
                    return "Object" === e && r.constructor && (e = r.constructor.name), "Map" === e || "Set" === e ? Array.from(e) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? i(r, t) : void 0;
                }
            }
            function o(r) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(r)) return Array.from(r);
            }
            function a(r) {
                if (Array.isArray(r)) return i(r);
            }
            function i(r, t) {
                (null == t || t > r.length) && (t = r.length);
                for(var e = 0, n = new Array(t); e < t; e++)n[e] = r[e];
                return n;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.validate = y, Object.defineProperty(exports, "ValidationError", {
                enumerable: !0,
                get: function() {
                    return c.default;
                }
            });
            var u = f(require1("./keywords/absolutePath")), c = f(require1("./ValidationError"));
            function f(r) {
                return r && r.__esModule ? r : {
                    default: r
                };
            }
            var l = require1("ajv"), d = require1("ajv-keywords"), s = new l({
                allErrors: !0,
                verbose: !0,
                $data: !0
            });
            function y(r, e, n) {
                var o = [];
                if (Array.isArray(e) ? ((o = Array.from(e, function(t) {
                    return h(r, t);
                })).forEach(function(r, t) {
                    r.forEach(function r(e) {
                        e.dataPath = "[".concat(t, "]").concat(e.dataPath), e.children && e.children.forEach(r);
                    });
                }), o = o.reduce(function(r, e) {
                    return r.push.apply(r, t(e)), r;
                }, [])) : o = h(r, e), o.length > 0) throw new c.default(o, r, n);
            }
            function h(r, t) {
                var e = s.compile(r);
                return e(t) ? [] : e.errors ? m(e.errors) : [];
            }
            function m(t) {
                var e, n = [], o = r(t);
                try {
                    var a = function() {
                        var r = e.value, t = r.dataPath, o = [];
                        n = n.filter(function(r) {
                            return !r.dataPath.includes(t) || (r.children && (o = o.concat(r.children.slice(0))), r.children = void 0, o.push(r), !1);
                        }), o.length && (r.children = o), n.push(r);
                    };
                    for(o.s(); !(e = o.n()).done;)a();
                } catch (i) {
                    o.e(i);
                } finally{
                    o.f();
                }
                return n;
            }
            d(s, [
                "instanceof",
                "formatMinimum",
                "formatMaximum",
                "patternRequired"
            ]), (0, u.default)(s);
        },
        {
            "./keywords/absolutePath": "iIhC",
            "./ValidationError": "ySUA",
            "ajv": "hi5j",
            "ajv-keywords": "n1A8"
        }
    ],
    "pA46": [
        function(require1, module1, exports) {
            "use strict";
            var a = require1("./validate"), r = a.validate, i = a.ValidationError;
            module1.exports = {
                validate: r,
                ValidationError: i
            };
        },
        {
            "./validate": "STvH"
        }
    ],
    "t7hQ": [
        function(require1, module1, exports) {
            function r(r, n) {
                return i(r) || o(r, n) || e(r, n) || t();
            }
            function t() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function e(r, t) {
                if (r) {
                    if ("string" == typeof r) return n(r, t);
                    var e = Object.prototype.toString.call(r).slice(8, -1);
                    return "Object" === e && r.constructor && (e = r.constructor.name), "Map" === e || "Set" === e ? Array.from(e) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? n(r, t) : void 0;
                }
            }
            function n(r, t) {
                (null == t || t > r.length) && (t = r.length);
                for(var e = 0, n = new Array(t); e < t; e++)n[e] = r[e];
                return n;
            }
            function o(r, t) {
                if ("undefined" != typeof Symbol && Symbol.iterator in Object(r)) {
                    var e = [], n = !0, o = !1, i = void 0;
                    try {
                        for(var a, u = r[Symbol.iterator](); !(n = (a = u.next()).done) && (e.push(a.value), !t || e.length !== t); n = !0);
                    } catch (l) {
                        o = !0, i = l;
                    } finally{
                        try {
                            n || null == u.return || u.return();
                        } finally{
                            if (o) throw i;
                        }
                    }
                    return e;
                }
            }
            function i(r) {
                if (Array.isArray(r)) return r;
            }
            var a = require1("schema-utils"), u = a.validate;
            function l(r, t) {
                u(t, r);
            }
            function c(t, e) {
                for(var n = {}, o = 0, i = Object.entries(e); o < i.length; o++){
                    var a = r(i[o], 2), u = a[0], l = a[1];
                    n[u] = t[u], void 0 === n[u] && (n[u] = l.default), l.process && (n[u] = l.process(n[u]));
                }
                return n;
            }
            module1.exports = {
                validateOptions: l,
                processOptions: c
            };
        },
        {
            "schema-utils": "pA46"
        }
    ],
    "uYXM": [
        function(require1, module1, exports) {
            module1.exports = {
                type: "object",
                properties: {
                    filerDir: {
                        type: "string"
                    },
                    shimsDir: {
                        type: "string"
                    },
                    shimFs: {
                        type: "boolean"
                    },
                    shimPath: {
                        type: "boolean"
                    },
                    fsProvider: {
                        type: "string"
                    },
                    fsProviderDir: {
                        type: "string"
                    }
                }
            };
        },
        {}
    ],
    "qUtu": [
        function(require1, module1, exports) {
            var process = require1("process");
            var e = require1("process"), r = require1("path"), s = "<rootDir>", o = e.cwd();
            module1.exports = {
                filerDir: {
                    process: function(e) {
                        return e ? r.resolve(e.replace(s, o)) : r.join(o, "node_modules", "filer");
                    }
                },
                shimsDir: {
                    process: function(e) {
                        return e ? r.resolve(e.replace(s, o)) : r.join(o, "node_modules", "filer", "shims");
                    }
                },
                fsProviderDir: {
                    process: function(e) {
                        return e ? r.resolve(e.replace(s, o)) : r.join(o, "node_modules", "filer", "shims", "providers");
                    }
                },
                shimFs: {
                    default: !0
                },
                shimPath: {
                    default: !0
                },
                fsProvider: {
                    default: "default"
                }
            };
        },
        {
            "path": "UUq2",
            "process": "pBGv"
        }
    ],
    "Ge14": [
        function(require1, module1, exports) {
            function e(e, r) {
                if (!(e instanceof r)) throw new TypeError("Cannot call a class as a function");
            }
            function r(e, r) {
                for(var i = 0; i < r.length; i++){
                    var o = r[i];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
                }
            }
            function i(e, i, o) {
                return i && r(e.prototype, i), o && r(e, o), e;
            }
            var o = require1("path"), s = require1("./utils"), t = "filer-webpack-plugin", n = require1("./schema"), a = require1("./processors");
            module1.exports = function() {
                function r() {
                    var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    e(this, r), s.validateOptions(i, n), this.options = s.processOptions(i, a);
                }
                return i(r, [
                    {
                        key: "apply",
                        value: function(e) {
                            var r = this;
                            e.hooks.normalModuleFactory.tap(t, function(e) {
                                e.hooks.resolve.tap(t, function(e) {
                                    if ("fsProvider" === e.request && e.context === r.options.shimsDir) return r.resolveFsProvider(e);
                                    if (!e.context.startsWith(r.options.filerDir)) switch(e.request){
                                        case "fs":
                                            if (!r.options.shimFs) return;
                                            return r.applyFsShim(e);
                                        case "path":
                                            if (!r.options.shimPath) return;
                                            return r.applyPathShim(e);
                                        default:
                                            return;
                                    }
                                });
                            });
                        }
                    },
                    {
                        key: "resolveFsProvider",
                        value: function(e) {
                            switch(this.options.fsProvider){
                                case "default":
                                    e.request = o.join(this.options.fsProviderDir, "default.js");
                                    break;
                                case "indexeddb":
                                    e.request = o.join(this.options.fsProviderDir, "indexeddb.js");
                                    break;
                                case "memory":
                                    e.request = o.join(this.options.fsProviderDir, "memory.js");
                                    break;
                                case "custom":
                                    e.request = o.join(this.options.fsProviderDir, "custom.js");
                                    break;
                                default:
                                    throw new Error([
                                        "Invalid option for fsProvider.",
                                        "fsProvider must be one of 'default', 'indexeddb', 'memory' or 'custom'.",
                                        "If using a custom fsProvider, you must also provide the fsProviderDir option."
                                    ].join(" "));
                            }
                        }
                    },
                    {
                        key: "applyFsShim",
                        value: function(e) {
                            e.request = o.join(this.options.shimsDir, "fs.js");
                        }
                    },
                    {
                        key: "applyPathShim",
                        value: function(e) {
                            e.request = o.join(this.options.shimsDir, "path.js");
                        }
                    }
                ]), r;
            }();
        },
        {
            "path": "UUq2",
            "./utils": "t7hQ",
            "./schema": "uYXM",
            "./processors": "qUtu"
        }
    ],
    "Focm": [
        function(require1, module1, exports) {
            var Buffer = require1("buffer").Buffer;
            var e = require1("buffer").Buffer, r = null, l = null;
            module1.exports = l = {
                FileSystem: require1("./filesystem/interface.js"),
                Buffer: e,
                Path: require1("./path.js"),
                path: require1("./path.js"),
                Errors: require1("./errors.js"),
                Shell: require1("./shell/shell.js"),
                FilerWebpackPlugin: require1("./webpack-plugin")
            }, Object.defineProperty(l, "fs", {
                enumerable: !0,
                get: function() {
                    return r || (r = new l.FileSystem), r;
                }
            });
        },
        {
            "./filesystem/interface.js": "GMi4",
            "./path.js": "UzoP",
            "./errors.js": "p8GN",
            "./shell/shell.js": "D1Ra",
            "./webpack-plugin": "Ge14",
            "buffer": "dskh"
        }
    ]
}, {}, [
    "Focm"
], "Filer") //# sourceMappingURL=/filer.min.js.map
;


var $7487250c9841db87$exports = {};
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var $7487250c9841db87$var$R = typeof Reflect === "object" ? Reflect : null;
var $7487250c9841db87$var$ReflectApply = $7487250c9841db87$var$R && typeof $7487250c9841db87$var$R.apply === "function" ? $7487250c9841db87$var$R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var $7487250c9841db87$var$ReflectOwnKeys;
if ($7487250c9841db87$var$R && typeof $7487250c9841db87$var$R.ownKeys === "function") $7487250c9841db87$var$ReflectOwnKeys = $7487250c9841db87$var$R.ownKeys;
else if (Object.getOwnPropertySymbols) $7487250c9841db87$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else $7487250c9841db87$var$ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function $7487250c9841db87$var$ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var $7487250c9841db87$var$NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function $7487250c9841db87$var$EventEmitter() {
    $7487250c9841db87$var$EventEmitter.init.call(this);
}
$7487250c9841db87$exports = $7487250c9841db87$var$EventEmitter;
$7487250c9841db87$exports.once = $7487250c9841db87$var$once;
// Backwards-compat with node 0.10.x
$7487250c9841db87$var$EventEmitter.EventEmitter = $7487250c9841db87$var$EventEmitter;
$7487250c9841db87$var$EventEmitter.prototype._events = undefined;
$7487250c9841db87$var$EventEmitter.prototype._eventsCount = 0;
$7487250c9841db87$var$EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var $7487250c9841db87$var$defaultMaxListeners = 10;
function $7487250c9841db87$var$checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty($7487250c9841db87$var$EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return $7487250c9841db87$var$defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || $7487250c9841db87$var$NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        $7487250c9841db87$var$defaultMaxListeners = arg;
    }
});
$7487250c9841db87$var$EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
$7487250c9841db87$var$EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || $7487250c9841db87$var$NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function $7487250c9841db87$var$_getMaxListeners(that) {
    if (that._maxListeners === undefined) return $7487250c9841db87$var$EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
$7487250c9841db87$var$EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $7487250c9841db87$var$_getMaxListeners(this);
};
$7487250c9841db87$var$EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") $7487250c9841db87$var$ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = $7487250c9841db87$var$arrayClone(handler, len);
        for(var i = 0; i < len; ++i)$7487250c9841db87$var$ReflectApply(listeners[i], this, args);
    }
    return true;
};
function $7487250c9841db87$var$_addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    $7487250c9841db87$var$checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = $7487250c9841db87$var$_getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            $7487250c9841db87$var$ProcessEmitWarning(w);
        }
    }
    return target;
}
$7487250c9841db87$var$EventEmitter.prototype.addListener = function addListener(type, listener) {
    return $7487250c9841db87$var$_addListener(this, type, listener, false);
};
$7487250c9841db87$var$EventEmitter.prototype.on = $7487250c9841db87$var$EventEmitter.prototype.addListener;
$7487250c9841db87$var$EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return $7487250c9841db87$var$_addListener(this, type, listener, true);
};
function $7487250c9841db87$var$onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function $7487250c9841db87$var$_onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = $7487250c9841db87$var$onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
$7487250c9841db87$var$EventEmitter.prototype.once = function once(type, listener) {
    $7487250c9841db87$var$checkListener(listener);
    this.on(type, $7487250c9841db87$var$_onceWrap(this, type, listener));
    return this;
};
$7487250c9841db87$var$EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    $7487250c9841db87$var$checkListener(listener);
    this.prependListener(type, $7487250c9841db87$var$_onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
$7487250c9841db87$var$EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    $7487250c9841db87$var$checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else $7487250c9841db87$var$spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
$7487250c9841db87$var$EventEmitter.prototype.off = $7487250c9841db87$var$EventEmitter.prototype.removeListener;
$7487250c9841db87$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function $7487250c9841db87$var$_listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? $7487250c9841db87$var$unwrapListeners(evlistener) : $7487250c9841db87$var$arrayClone(evlistener, evlistener.length);
}
$7487250c9841db87$var$EventEmitter.prototype.listeners = function listeners(type) {
    return $7487250c9841db87$var$_listeners(this, type, true);
};
$7487250c9841db87$var$EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return $7487250c9841db87$var$_listeners(this, type, false);
};
$7487250c9841db87$var$EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return $7487250c9841db87$var$listenerCount.call(emitter, type);
};
$7487250c9841db87$var$EventEmitter.prototype.listenerCount = $7487250c9841db87$var$listenerCount;
function $7487250c9841db87$var$listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
$7487250c9841db87$var$EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? $7487250c9841db87$var$ReflectOwnKeys(this._events) : [];
};
function $7487250c9841db87$var$arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function $7487250c9841db87$var$spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function $7487250c9841db87$var$unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function $7487250c9841db87$var$once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        $7487250c9841db87$var$eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") $7487250c9841db87$var$addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function $7487250c9841db87$var$addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") $7487250c9841db87$var$eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function $7487250c9841db87$var$eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}


let $3132870559d60e53$var$virtualGlobalObject = {};
let $3132870559d60e53$var$env = "browser";
function $3132870559d60e53$var$setupGlobalObject() {
    if (typeof window !== "undefined") {
        window.globalObject = window;
        $3132870559d60e53$var$env = "browser";
        return window; // browser
    }
    if (typeof self !== "undefined") {
        self.globalObject = self;
        self.import = importScripts;
        $3132870559d60e53$var$env = "web-worker";
        return self; // web worker
    }
    if (typeof $parcel$global !== "undefined") {
        $parcel$global.globalObject = $parcel$global;
        $3132870559d60e53$var$env = "nodejs. Not sure why you need virtual fs in node!";
        return $parcel$global; //nodejs
    }
    return $3132870559d60e53$var$virtualGlobalObject;
}
$3132870559d60e53$var$setupGlobalObject();
const $3132870559d60e53$var$urlParams = new URLSearchParams(location.search);
globalObject.Filer = $8adf1cfaed2eb5b1$exports;
if (!globalObject.Buffer) globalObject.Buffer = $3132870559d60e53$require$Buffer;
if (!globalObject.EventEmitter) globalObject.EventEmitter = $7487250c9841db87$exports;
globalObject.virtualfs = {
    urlParams: $3132870559d60e53$var$urlParams,
    debugMode: globalObject.debugMode || $3132870559d60e53$var$urlParams.get("debug") === "true",
    env: $3132870559d60e53$var$env
};
console.log(`PhoenixFS: virtual fs started in debugMode:${virtualfs.debugMode} on environment: ${virtualfs.env}`);
var $e3f139c5065f0041$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ var $54aff2427aaf4272$exports = {};
"use strict";

var $xaL3N = parcelRequire("xaL3N");
var $54aff2427aaf4272$require$Buffer = $xaL3N.Buffer;
var $33aba040e5f4285a$export$e46ffb123c920c9f;
//------------------------------------------------------------------------------
var $33aba040e5f4285a$export$99ac9f64d7386375;
"use strict";
var $33aba040e5f4285a$var$BOMChar = "\uFEFF";
$33aba040e5f4285a$export$e46ffb123c920c9f = $33aba040e5f4285a$var$PrependBOMWrapper;
function $33aba040e5f4285a$var$PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}
$33aba040e5f4285a$var$PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = $33aba040e5f4285a$var$BOMChar + str;
        this.addBOM = false;
    }
    return this.encoder.write(str);
};
$33aba040e5f4285a$var$PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
};
$33aba040e5f4285a$export$99ac9f64d7386375 = $33aba040e5f4285a$var$StripBOMWrapper;
function $33aba040e5f4285a$var$StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}
$33aba040e5f4285a$var$StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) return res;
    if (res[0] === $33aba040e5f4285a$var$BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function") this.options.stripBOM();
    }
    this.pass = true;
    return res;
};
$33aba040e5f4285a$var$StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
};


var $54aff2427aaf4272$var$iconv = $54aff2427aaf4272$exports;
// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
$54aff2427aaf4272$var$iconv.encodings = null;
// Characters emitted in case of error.
$54aff2427aaf4272$var$iconv.defaultCharUnicode = "";
$54aff2427aaf4272$var$iconv.defaultCharSingleByte = "?";
// Public API.
$54aff2427aaf4272$var$iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.
    var encoder = $54aff2427aaf4272$var$iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? $54aff2427aaf4272$require$Buffer.concat([
        res,
        trail
    ]) : res;
};
$54aff2427aaf4272$var$iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
        if (!$54aff2427aaf4272$var$iconv.skipDecodeWarning) {
            console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
            $54aff2427aaf4272$var$iconv.skipDecodeWarning = true;
        }
        buf = $54aff2427aaf4272$require$Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }
    var decoder = $54aff2427aaf4272$var$iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
};
$54aff2427aaf4272$var$iconv.encodingExists = function encodingExists(enc) {
    try {
        $54aff2427aaf4272$var$iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
};
// Legacy aliases to convert functions
$54aff2427aaf4272$var$iconv.toEncoding = $54aff2427aaf4272$var$iconv.encode;
$54aff2427aaf4272$var$iconv.fromEncoding = $54aff2427aaf4272$var$iconv.decode;
// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
$54aff2427aaf4272$var$iconv._codecDataCache = {};

$54aff2427aaf4272$var$iconv.getCodec = function getCodec(encoding) {
    if (!$54aff2427aaf4272$var$iconv.encodings) $54aff2427aaf4272$var$iconv.encodings = (parcelRequire("7eWHE")); // Lazy load all encoding definitions.
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = $54aff2427aaf4272$var$iconv._canonicalizeEncoding(encoding);
    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while(true){
        var codec = $54aff2427aaf4272$var$iconv._codecDataCache[enc];
        if (codec) return codec;
        var codecDef = $54aff2427aaf4272$var$iconv.encodings[enc];
        switch(typeof codecDef){
            case "string":
                enc = codecDef;
                break;
            case "object":
                for(var key in codecDef)codecOptions[key] = codecDef[key];
                if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                enc = codecDef.type;
                break;
            case "function":
                if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, $54aff2427aaf4272$var$iconv);
                $54aff2427aaf4272$var$iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;
            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
    }
};
$54aff2427aaf4272$var$iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
};
$54aff2427aaf4272$var$iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = $54aff2427aaf4272$var$iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM) encoder = new $33aba040e5f4285a$export$e46ffb123c920c9f(encoder, options);
    return encoder;
};
$54aff2427aaf4272$var$iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = $54aff2427aaf4272$var$iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new $33aba040e5f4285a$export$99ac9f64d7386375(decoder, options);
    return decoder;
};

// Streaming API
// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
// If you would like to enable it explicitly, please add the following code to your app:
// > iconv.enableStreamingAPI(require('stream'));
$54aff2427aaf4272$var$iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
    if ($54aff2427aaf4272$var$iconv.supportsStreams) return;
    // Dependency-inject stream module to create IconvLite stream classes.
    var streams = (parcelRequire("euIxF"))(stream_module);
    // Not public API yet, but expose the stream classes.
    $54aff2427aaf4272$var$iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    $54aff2427aaf4272$var$iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    // Streaming API.
    $54aff2427aaf4272$var$iconv.encodeStream = function encodeStream(encoding, options) {
        return new $54aff2427aaf4272$var$iconv.IconvLiteEncoderStream($54aff2427aaf4272$var$iconv.getEncoder(encoding, options), options);
    };
    $54aff2427aaf4272$var$iconv.decodeStream = function decodeStream(encoding, options) {
        return new $54aff2427aaf4272$var$iconv.IconvLiteDecoderStream($54aff2427aaf4272$var$iconv.getDecoder(encoding, options), options);
    };
    $54aff2427aaf4272$var$iconv.supportsStreams = true;
};
// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
var $54aff2427aaf4272$var$stream_module;

try {
    $54aff2427aaf4272$var$stream_module = (parcelRequire("lb6jJ"));
} catch (e) {}
if ($54aff2427aaf4272$var$stream_module && $54aff2427aaf4272$var$stream_module.Transform) $54aff2427aaf4272$var$iconv.enableStreamingAPI($54aff2427aaf4272$var$stream_module);
else // In rare cases where 'stream' module is not available by default, throw a helpful exception.
$54aff2427aaf4272$var$iconv.encodeStream = $54aff2427aaf4272$var$iconv.decodeStream = function() {
    throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
};



var $FkHbz = parcelRequire("FkHbz");
var $ee841df9a5ce9c95$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 * Copyright (c) 2012-2015 Rod Vagg (@rvagg)
 * Based on : https://github.com/rvagg/node-errno
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*eslint-env es6*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ /** All phoenix shell errors and their description.
 *
 * This module should be functionally as light weight as possible with minimal deps as it is a shell component.
 * **/ const $ee841df9a5ce9c95$var$ERROR_CODES = {
    ENOENT: "ENOENT",
    UNKNOWN: "UNKNOWN",
    OK: "OK",
    EOF: "EOF",
    EADDRINFO: "EADDRINFO",
    EACCES: "EACCES",
    EAGAIN: "EAGAIN",
    EADDRINUSE: "EADDRINUSE",
    EADDRNOTAVAIL: "EADDRNOTAVAIL",
    EAFNOSUPPORT: "EAFNOSUPPORT",
    EALREADY: "EALREADY",
    EBADF: "EBADF",
    EBUSY: "EBUSY",
    ECONNABORTED: "ECONNABORTED",
    ECONNREFUSED: "ECONNREFUSED",
    ECONNRESET: "ECONNRESET",
    EDESTADDRREQ: "EDESTADDRREQ",
    EFAULT: "EFAULT",
    EHOSTUNREACH: "EHOSTUNREACH",
    EINTR: "EINTR",
    EINVAL: "EINVAL",
    EISCONN: "EISCONN",
    EMFILE: "EMFILE",
    EMSGSIZE: "EMSGSIZE",
    ENETDOWN: "ENETDOWN",
    ENETUNREACH: "ENETUNREACH",
    ENFILE: "ENFILE",
    ENOBUFS: "ENOBUFS",
    ENOMEM: "ENOMEM",
    ENOTDIR: "ENOTDIR",
    EISDIR: "EISDIR",
    ENONET: "ENONET",
    ENOTCONN: "ENOTCONN",
    ENOTSOCK: "ENOTSOCK",
    ENOTSUP: "ENOTSUP",
    ENOSYS: "ENOSYS",
    EPIPE: "EPIPE",
    EPROTO: "EPROTO",
    EPROTONOSUPPORT: "EPROTONOSUPPORT",
    EPROTOTYPE: "EPROTOTYPE",
    ETIMEDOUT: "ETIMEDOUT",
    ECHARSET: "ECHARSET",
    EAIFAMNOSUPPORT: "EAIFAMNOSUPPORT",
    EAISERVICE: "EAISERVICE",
    EAISOCKTYPE: "EAISOCKTYPE",
    ESHUTDOWN: "ESHUTDOWN",
    EEXIST: "EEXIST",
    ESRCH: "ESRCH",
    ENAMETOOLONG: "ENAMETOOLONG",
    EPERM: "EPERM",
    ELOOP: "ELOOP",
    EXDEV: "EXDEV",
    ENOTEMPTY: "ENOTEMPTY",
    ENOSPC: "ENOSPC",
    EIO: "EIO",
    EROFS: "EROFS",
    ENODEV: "ENODEV",
    ESPIPE: "ESPIPE",
    ECANCELED: "ECANCELED"
};
const $ee841df9a5ce9c95$var$FS_ERROR_CODES = {
    ENOENT: $ee841df9a5ce9c95$var$ERROR_CODES.ENOENT,
    EOF: $ee841df9a5ce9c95$var$ERROR_CODES.EOF,
    EACCES: $ee841df9a5ce9c95$var$ERROR_CODES.EACCES,
    EAGAIN: $ee841df9a5ce9c95$var$ERROR_CODES.EAGAIN,
    EBADF: $ee841df9a5ce9c95$var$ERROR_CODES.EBADF,
    EBUSY: $ee841df9a5ce9c95$var$ERROR_CODES.EBUSY,
    EINVAL: $ee841df9a5ce9c95$var$ERROR_CODES.EINVAL,
    EMFILE: $ee841df9a5ce9c95$var$ERROR_CODES.EMFILE,
    ENFILE: $ee841df9a5ce9c95$var$ERROR_CODES.ENFILE,
    ENOBUFS: $ee841df9a5ce9c95$var$ERROR_CODES.ENOBUFS,
    ENOTDIR: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTDIR,
    EISDIR: $ee841df9a5ce9c95$var$ERROR_CODES.EISDIR,
    ENOSYS: $ee841df9a5ce9c95$var$ERROR_CODES.ENOSYS,
    ECHARSET: $ee841df9a5ce9c95$var$ERROR_CODES.ECHARSET,
    EEXIST: $ee841df9a5ce9c95$var$ERROR_CODES.EEXIST,
    ENAMETOOLONG: $ee841df9a5ce9c95$var$ERROR_CODES.ENAMETOOLONG,
    EPERM: $ee841df9a5ce9c95$var$ERROR_CODES.EPERM,
    ELOOP: $ee841df9a5ce9c95$var$ERROR_CODES.ELOOP,
    EXDEV: $ee841df9a5ce9c95$var$ERROR_CODES.EXDEV,
    ENOTEMPTY: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTEMPTY,
    ENOSPC: $ee841df9a5ce9c95$var$ERROR_CODES.ENOSPC,
    EIO: $ee841df9a5ce9c95$var$ERROR_CODES.EIO,
    EROFS: $ee841df9a5ce9c95$var$ERROR_CODES.EROFS,
    ESPIPE: $ee841df9a5ce9c95$var$ERROR_CODES.ESPIPE,
    ECANCELED: $ee841df9a5ce9c95$var$ERROR_CODES.ECANCELED //operation canceled
};
const $ee841df9a5ce9c95$var$ALL_ERRORS = [
    {
        errno: -2,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOENT,
        description: "no such file or directory"
    },
    {
        errno: -1,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.UNKNOWN,
        description: "unknown error"
    },
    {
        errno: 0,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.OK,
        description: "success"
    },
    {
        errno: 1,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EOF,
        description: "end of file"
    },
    {
        errno: 2,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EADDRINFO,
        description: "getaddrinfo error"
    },
    {
        errno: 3,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EACCES,
        description: "permission denied"
    },
    {
        errno: 4,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EAGAIN,
        description: "resource temporarily unavailable"
    },
    {
        errno: 5,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EADDRINUSE,
        description: "address already in use"
    },
    {
        errno: 6,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EADDRNOTAVAIL,
        description: "address not available"
    },
    {
        errno: 7,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EAFNOSUPPORT,
        description: "address family not supported"
    },
    {
        errno: 8,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EALREADY,
        description: "connection already in progress"
    },
    {
        errno: 9,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EBADF,
        description: "bad file descriptor"
    },
    {
        errno: 10,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EBUSY,
        description: "resource busy or locked"
    },
    {
        errno: 11,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ECONNABORTED,
        description: "software caused connection abort"
    },
    {
        errno: 12,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ECONNREFUSED,
        description: "connection refused"
    },
    {
        errno: 13,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ECONNRESET,
        description: "connection reset by peer"
    },
    {
        errno: 14,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EDESTADDRREQ,
        description: "destination address required"
    },
    {
        errno: 15,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EFAULT,
        description: "bad address in system call argument"
    },
    {
        errno: 16,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EHOSTUNREACH,
        description: "host is unreachable"
    },
    {
        errno: 17,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EINTR,
        description: "interrupted system call"
    },
    {
        errno: 18,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EINVAL,
        description: "invalid argument"
    },
    {
        errno: 19,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EISCONN,
        description: "socket is already connected"
    },
    {
        errno: 20,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EMFILE,
        description: "too many open files"
    },
    {
        errno: 21,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EMSGSIZE,
        description: "message/datagram too long"
    },
    {
        errno: 22,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENETDOWN,
        description: "network is down"
    },
    {
        errno: 23,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENETUNREACH,
        description: "network is unreachable"
    },
    {
        errno: 24,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENFILE,
        description: "file table overflow"
    },
    {
        errno: 25,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOBUFS,
        description: "no buffer space available"
    },
    {
        errno: 26,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOMEM,
        description: "not enough memory/ high virtual memory usage"
    },
    {
        errno: 27,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTDIR,
        description: "not a directory"
    },
    {
        errno: 28,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EISDIR,
        description: "illegal operation on a directory"
    },
    {
        errno: 29,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENONET,
        description: "machine is not on the network"
    },
    {
        errno: 31,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTCONN,
        description: "socket is not connected"
    },
    {
        errno: 32,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTSOCK,
        description: "socket operation on non-socket"
    },
    {
        errno: 33,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTSUP,
        description: "operation not supported on socket"
    },
    {
        errno: 34,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOENT,
        description: "no such file or directory"
    },
    {
        errno: 35,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOSYS,
        description: "function not implemented"
    },
    {
        errno: 36,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EPIPE,
        description: "broken pipe"
    },
    {
        errno: 37,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EPROTO,
        description: "protocol error"
    },
    {
        errno: 38,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EPROTONOSUPPORT,
        description: "protocol not supported"
    },
    {
        errno: 39,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EPROTOTYPE,
        description: "protocol wrong type for socket"
    },
    {
        errno: 40,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ETIMEDOUT,
        description: "connection timed out"
    },
    {
        errno: 41,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ECHARSET,
        description: "invalid Unicode character"
    },
    {
        errno: 42,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EAIFAMNOSUPPORT,
        description: "address family for hostname not supported"
    },
    {
        errno: 44,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EAISERVICE,
        description: "servname not supported for ai_socktype"
    },
    {
        errno: 45,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EAISOCKTYPE,
        description: "ai_socktype not supported"
    },
    {
        errno: 46,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ESHUTDOWN,
        description: "cannot send after transport endpoint shutdown"
    },
    {
        errno: 47,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EEXIST,
        description: "file already exists"
    },
    {
        errno: 48,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ESRCH,
        description: "no such process"
    },
    {
        errno: 49,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENAMETOOLONG,
        description: "name too long"
    },
    {
        errno: 50,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EPERM,
        description: "operation not permitted"
    },
    {
        errno: 51,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ELOOP,
        description: "too many symbolic links encountered"
    },
    {
        errno: 52,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EXDEV,
        description: "cross-device link not permitted"
    },
    {
        errno: 53,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOTEMPTY,
        description: "directory not empty"
    },
    {
        errno: 54,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENOSPC,
        description: "no space left on device"
    },
    {
        errno: 55,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EIO,
        description: "i/o error"
    },
    {
        errno: 56,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.EROFS,
        description: "read-only file system"
    },
    {
        errno: 57,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ENODEV,
        description: "no such device"
    },
    {
        errno: 58,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ESPIPE,
        description: "invalid seek"
    },
    {
        errno: 59,
        code: $ee841df9a5ce9c95$var$ERROR_CODES.ECANCELED,
        description: "operation canceled"
    }
];
let $ee841df9a5ce9c95$var$ERRNO_TO_ERROR_MAP = {};
let $ee841df9a5ce9c95$var$CODE_TO_ERROR_MAP = {};
$ee841df9a5ce9c95$var$ALL_ERRORS.forEach(function(error) {
    $ee841df9a5ce9c95$var$ERRNO_TO_ERROR_MAP[error.errno] = error;
    $ee841df9a5ce9c95$var$CODE_TO_ERROR_MAP[error.code] = error;
});
const $ee841df9a5ce9c95$var$ERR_CODES = {
    ERROR_CODES: $ee841df9a5ce9c95$var$ERROR_CODES,
    FS_ERROR_CODES: $ee841df9a5ce9c95$var$FS_ERROR_CODES,
    ALL_ERRORS: $ee841df9a5ce9c95$var$ALL_ERRORS,
    ERRNO_TO_ERROR_MAP: $ee841df9a5ce9c95$var$ERRNO_TO_ERROR_MAP,
    CODE_TO_ERROR_MAP: $ee841df9a5ce9c95$var$CODE_TO_ERROR_MAP
};
const $ee841df9a5ce9c95$var$Errors = {};
[
    /**
     * node.js errors - we only use some of these, add as needed.
     */ //'-1:UNKNOWN:unknown error',
    //'0:OK:success',
    "1:EOF:end of file",
    //'2:EADDRINFO:getaddrinfo error',
    "3:EACCES:permission denied",
    "4:EAGAIN:resource temporarily unavailable",
    //'5:EADDRINUSE:address already in use',
    //'6:EADDRNOTAVAIL:address not available',
    //'7:EAFNOSUPPORT:address family not supported',
    //'8:EALREADY:connection already in progress',
    "9:EBADF:bad file descriptor",
    "10:EBUSY:resource busy or locked",
    //'11:ECONNABORTED:software caused connection abort',
    //'12:ECONNREFUSED:connection refused',
    //'13:ECONNRESET:connection reset by peer',
    //'14:EDESTADDRREQ:destination address required',
    //'15:EFAULT:bad address in system call argument',
    //'16:EHOSTUNREACH:host is unreachable',
    //'17:EINTR:interrupted system call',
    "18:EINVAL:invalid argument",
    //'19:EISCONN:socket is already connected',
    "20:EMFILE:too many open files",
    //'21:EMSGSIZE:message too long',
    //'22:ENETDOWN:network is down',
    //'23:ENETUNREACH:network is unreachable',
    "24:ENFILE:file table overflow",
    "25:ENOBUFS:no buffer space available",
    //'26:ENOMEM:not enough memory',
    "27:ENOTDIR:not a directory",
    "28:EISDIR:illegal operation on a directory",
    //'29:ENONET:machine is not on the network',
    // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js
    //'31:ENOTCONN:socket is not connected',
    //'32:ENOTSOCK:socket operation on non-socket',
    //'33:ENOTSUP:operation not supported on socket',
    "34:ENOENT:no such file or directory",
    "35:ENOSYS:function not implemented",
    //'36:EPIPE:broken pipe',
    //'37:EPROTO:protocol error',
    //'38:EPROTONOSUPPORT:protocol not supported',
    //'39:EPROTOTYPE:protocol wrong type for socket',
    //'40:ETIMEDOUT:connection timed out',
    "41:ECHARSET:invalid Unicode character",
    //'42:EAIFAMNOSUPPORT:address family for hostname not supported',
    // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js
    //'44:EAISERVICE:servname not supported for ai_socktype',
    //'45:EAISOCKTYPE:ai_socktype not supported',
    //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',
    "47:EEXIST:file already exists",
    //'48:ESRCH:no such process',
    "49:ENAMETOOLONG:name too long",
    "50:EPERM:operation not permitted",
    "51:ELOOP:too many symbolic links encountered",
    "52:EXDEV:cross-device link not permitted",
    "53:ENOTEMPTY:directory not empty",
    "54:ENOSPC:no space left on device",
    "55:EIO:i/o error",
    "56:EROFS:read-only file system",
    //'57:ENODEV:no such device',
    "58:ESPIPE:invalid seek",
    "59:ECANCELED:operation canceled",
    /**
     * Phoenix/Filer specific errors
     */ "1000:ENOTMOUNTED:not mounted",
    "1001:EFILESYSTEMERROR:missing super node, use 'FORMAT' flag to format filesystem.",
    "1002:ENOATTR:attribute does not exist"
].forEach(function(e) {
    e = e.split(":");
    var errno = +e[0];
    var errName = e[1];
    var defaultMessage = e[2];
    function FilerError(msg, path) {
        Error.call(this);
        this.name = errName;
        this.code = errName;
        this.errno = errno;
        this.message = msg || defaultMessage;
        if (path) this.path = path;
        this.stack = new Error(this.message).stack;
    }
    FilerError.prototype = Object.create(Error.prototype);
    FilerError.prototype.constructor = FilerError;
    FilerError.prototype.toString = function() {
        var pathInfo = this.path ? ", '" + this.path + "'" : "";
        return this.name + ": " + this.message + pathInfo;
    };
    // We expose the error as both Errors.EINVAL and Errors[18]
    $ee841df9a5ce9c95$var$Errors[errName] = $ee841df9a5ce9c95$var$Errors[errno] = FilerError;
});
$ee841df9a5ce9c95$exports = {
    Errors: $ee841df9a5ce9c95$var$Errors,
    ERR_CODES: $ee841df9a5ce9c95$var$ERR_CODES
};


var $e3f139c5065f0041$require$ERR_CODES = $ee841df9a5ce9c95$exports.ERR_CODES;
var $e3f139c5065f0041$require$Errors = $ee841df9a5ce9c95$exports.Errors;
var $bd5c47de9e98f4fa$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 
var $kznHi = parcelRequire("kznHi");
var $bd5c47de9e98f4fa$require$Buffer = $kznHi.Buffer;
var $d71a2f6bd42cb0cc$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 
var $d71a2f6bd42cb0cc$require$Errors = $ee841df9a5ce9c95$exports.Errors;
var $983f70f1027f6cfd$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ /**
 * Persists serialised mounted native file system handles to indexed db to usage across tabs and sessions.
**/ var $2ef5299e07961cfe$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ /* jshint ignore:start */ const $2ef5299e07961cfe$var$Constants = {
    MOUNT_DEVICE_NAME: "nativeFsAccess",
    TAURI_DEVICE_NAME: "tauri",
    TAURI_WS_DEVICE_NAME: "tauriWS",
    KIND_FILE: "file",
    KIND_DIRECTORY: "directory",
    NODE_TYPE_FILE: "FILE",
    NODE_TYPE_DIRECTORY: "DIRECTORY",
    IDB_RW_TYPE: "readwrite",
    MOUNT_POINT_ROOT: "/mnt",
    TAURI_ROOT: "/tauri",
    BINARY_ENCODING: "binary",
    BYTE_ARRAY_ENCODING: "byte_array",
    WATCH_EVENTS: {
        ADD_FILE: "add",
        ADD_DIR: "addDir",
        CHANGE: "change",
        UNLINK_FILE: "unlink",
        UNLINK_DIR: "unlinkDir"
    }
};
$2ef5299e07961cfe$exports = {
    Constants: $2ef5299e07961cfe$var$Constants
};


var $983f70f1027f6cfd$require$Constants = $2ef5299e07961cfe$exports.Constants;
var $c0e8621a15003181$exports = {};
const $c0e8621a15003181$var$idb = function(e) {
    "use strict";
    let t, n;
    const r = new WeakMap, o = new WeakMap, s = new WeakMap, a = new WeakMap, i = new WeakMap;
    let c = {
        get (e, t, n) {
            if (e instanceof IDBTransaction) {
                if ("done" === t) return o.get(e);
                if ("objectStoreNames" === t) return e.objectStoreNames || s.get(e);
                if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
            }
            return p(e[t]);
        },
        set: (e, t, n)=>(e[t] = n, !0),
        has: (e, t)=>e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
    };
    function u(e) {
        return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (n || (n = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey
        ])).includes(e) ? function(...t) {
            return e.apply(f(this), t), p(r.get(this));
        } : function(...t) {
            return p(e.apply(f(this), t));
        } : function(t, ...n) {
            const r = e.call(f(this), t, ...n);
            return s.set(r, t.sort ? t.sort() : [
                t
            ]), p(r);
        };
    }
    function d(e) {
        var n;
        return "function" == typeof e ? u(e) : (e instanceof IDBTransaction && function(e) {
            if (o.has(e)) return;
            const t = new Promise((t, n)=>{
                const r = ()=>{
                    e.removeEventListener("complete", o), e.removeEventListener("error", s), e.removeEventListener("abort", s);
                }, o = ()=>{
                    t(), r();
                }, s = ()=>{
                    n(e.error || new DOMException("AbortError", "AbortError")), r();
                };
                e.addEventListener("complete", o), e.addEventListener("error", s), e.addEventListener("abort", s);
            });
            o.set(e, t);
        }(e), n = e, (t || (t = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction
        ])).some((e)=>n instanceof e) ? new Proxy(e, c) : e);
    }
    function p(e) {
        if (e instanceof IDBRequest) return function(e) {
            const t = new Promise((t, n)=>{
                const r = ()=>{
                    e.removeEventListener("success", o), e.removeEventListener("error", s);
                }, o = ()=>{
                    t(p(e.result)), r();
                }, s = ()=>{
                    n(e.error), r();
                };
                e.addEventListener("success", o), e.addEventListener("error", s);
            });
            return t.then((t)=>{
                t instanceof IDBCursor && r.set(t, e);
            }).catch(()=>{}), i.set(t, e), t;
        }(e);
        if (a.has(e)) return a.get(e);
        const t = d(e);
        return t !== e && (a.set(e, t), i.set(t, e)), t;
    }
    const f = (e)=>i.get(e);
    const l = [
        "get",
        "getKey",
        "getAll",
        "getAllKeys",
        "count"
    ], D = [
        "put",
        "add",
        "delete",
        "clear"
    ], v = new Map;
    function b(e, t) {
        if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return;
        if (v.get(t)) return v.get(t);
        const n = t.replace(/FromIndex$/, ""), r = t !== n, o = D.includes(n);
        if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !o && !l.includes(n)) return;
        const s = async function(e, ...t) {
            const s = this.transaction(e, o ? "readwrite" : "readonly");
            let a = s.store;
            return r && (a = a.index(t.shift())), (await Promise.all([
                a[n](...t),
                o && s.done
            ]))[0];
        };
        return v.set(t, s), s;
    }
    return c = ((e)=>({
            ...e,
            get: (t, n, r)=>b(t, n) || e.get(t, n, r),
            has: (t, n)=>!!b(t, n) || e.has(t, n)
        }))(c), e.deleteDB = function(e, { blocked: t } = {}) {
        const n = indexedDB.deleteDatabase(e);
        return t && n.addEventListener("blocked", ()=>t()), p(n).then(()=>{});
    }, e.openDB = function(e, t, { blocked: n, upgrade: r, blocking: o, terminated: s } = {}) {
        const a = indexedDB.open(e, t), i = p(a);
        return r && a.addEventListener("upgradeneeded", (e)=>{
            r(p(a.result), e.oldVersion, e.newVersion, p(a.transaction));
        }), n && a.addEventListener("blocked", ()=>n()), i.then((e)=>{
            s && e.addEventListener("close", ()=>s()), o && e.addEventListener("versionchange", ()=>o());
        }).catch(()=>{}), i;
    }, e.unwrap = f, e.wrap = p, e;
}({});
$c0e8621a15003181$exports = {
    idb: $c0e8621a15003181$var$idb
};


var $983f70f1027f6cfd$require$idb = $c0e8621a15003181$exports.idb;
const $983f70f1027f6cfd$var$PHOENIX_MOUNTS_DB_NAME = "PHOENIX_MOUNTS";
const $983f70f1027f6cfd$var$STORE_NAME = "FS_ACCESS";
const $983f70f1027f6cfd$var$MOUNT_POINTS_KEY = "MOUNT_POINTS";
const $983f70f1027f6cfd$var$VERSION_1 = 1;
let $983f70f1027f6cfd$var$db = null;
let $983f70f1027f6cfd$var$_currentMounts = {};
async function $983f70f1027f6cfd$var$_ensureDB() {
    if ($983f70f1027f6cfd$var$db) return;
    $983f70f1027f6cfd$var$db = await $983f70f1027f6cfd$require$idb.openDB($983f70f1027f6cfd$var$PHOENIX_MOUNTS_DB_NAME, $983f70f1027f6cfd$var$VERSION_1, {
        upgrade (db) {
            db.createObjectStore($983f70f1027f6cfd$var$STORE_NAME);
        }
    });
}
async function $983f70f1027f6cfd$var$addMountPoint(mountName, handle) {
    await $983f70f1027f6cfd$var$_ensureDB();
    const tx = $983f70f1027f6cfd$var$db.transaction($983f70f1027f6cfd$var$STORE_NAME, $983f70f1027f6cfd$require$Constants.IDB_RW_TYPE);
    const store = tx.objectStore($983f70f1027f6cfd$var$STORE_NAME);
    $983f70f1027f6cfd$var$_currentMounts = await store.get($983f70f1027f6cfd$var$MOUNT_POINTS_KEY) || {};
    $983f70f1027f6cfd$var$_currentMounts[mountName] = handle;
    await store.put($983f70f1027f6cfd$var$_currentMounts, $983f70f1027f6cfd$var$MOUNT_POINTS_KEY);
    await tx.done;
}
async function $983f70f1027f6cfd$var$refreshMountPoints() {
    await $983f70f1027f6cfd$var$_ensureDB();
    const tx = $983f70f1027f6cfd$var$db.transaction($983f70f1027f6cfd$var$STORE_NAME, $983f70f1027f6cfd$require$Constants.IDB_RW_TYPE);
    const store = tx.objectStore($983f70f1027f6cfd$var$STORE_NAME);
    $983f70f1027f6cfd$var$_currentMounts = await store.get($983f70f1027f6cfd$var$MOUNT_POINTS_KEY) || {};
    await tx.done;
    return $983f70f1027f6cfd$var$_currentMounts;
}
function $983f70f1027f6cfd$var$getMountPoints() {
    return $983f70f1027f6cfd$var$_currentMounts;
}
const $983f70f1027f6cfd$var$MountPointsStore = {
    addMountPoint: $983f70f1027f6cfd$var$addMountPoint,
    getMountPoints: $983f70f1027f6cfd$var$getMountPoints,
    refreshMountPoints: $983f70f1027f6cfd$var$refreshMountPoints
};
$983f70f1027f6cfd$exports = {
    MountPointsStore: $983f70f1027f6cfd$var$MountPointsStore
};


var $d71a2f6bd42cb0cc$require$MountPointsStore = $983f70f1027f6cfd$exports.MountPointsStore;

var $d71a2f6bd42cb0cc$require$Constants = $2ef5299e07961cfe$exports.Constants;
const $d71a2f6bd42cb0cc$var$MOUNT_POINT_CHANGED_NOTIFICATION = "PHOENIX_MOUNT_POINT_CHANGED_NOTIFICATION";
let $d71a2f6bd42cb0cc$var$MAX_NUM_MOUNTS = 1000000;
let $d71a2f6bd42cb0cc$var$_channel = null;
/**
 * Check if the given path is a subpath of the '/mnt' folder.
 * @param path
 */ function $d71a2f6bd42cb0cc$var$isMountSubPath(path) {
    if (typeof path !== "string") return false;
    let mntSubPathStart = $d71a2f6bd42cb0cc$require$Constants.MOUNT_POINT_ROOT + "/";
    if (path) {
        path = globalObject.path.normalize(path);
        if (path.startsWith(mntSubPathStart) && path.length > mntSubPathStart.length) return true;
    }
    return false;
}
/**
 * Check if the given path is '/mnt' folder.
 * @param path
 */ function $d71a2f6bd42cb0cc$var$isMountPath(path) {
    if (typeof path !== "string") return false;
    if (path) {
        path = globalObject.path.normalize(path);
        if (path === $d71a2f6bd42cb0cc$require$Constants.MOUNT_POINT_ROOT) return true;
    }
    return false;
}
function $d71a2f6bd42cb0cc$var$_setupBroadcastChannel() {
    if ($d71a2f6bd42cb0cc$var$_channel) return;
    if (typeof BroadcastChannel === "undefined") {
        /* eslint no-console: 0 */ console.warn("BroadcastChannel not supported. Mount point changes wont reflect across tabs.");
        return;
    }
    $d71a2f6bd42cb0cc$var$_channel = new BroadcastChannel($d71a2f6bd42cb0cc$var$MOUNT_POINT_CHANGED_NOTIFICATION);
}
function $d71a2f6bd42cb0cc$var$_broadcastMountPointChanged() {
    $d71a2f6bd42cb0cc$var$_setupBroadcastChannel();
    $d71a2f6bd42cb0cc$var$_channel.postMessage($d71a2f6bd42cb0cc$var$MOUNT_POINT_CHANGED_NOTIFICATION);
}
function $d71a2f6bd42cb0cc$var$_listenToMountPointChanges() {
    $d71a2f6bd42cb0cc$var$_setupBroadcastChannel();
    $d71a2f6bd42cb0cc$var$_channel.onmessage = async function(event) {
        if (event.data === $d71a2f6bd42cb0cc$var$MOUNT_POINT_CHANGED_NOTIFICATION) await $d71a2f6bd42cb0cc$require$MountPointsStore.refreshMountPoints();
    };
}
/**
 * Checks if the given handleToMount is same as or a subdir of all existing mounts
 * @param handleToMount
 * @returns {*[]} array of details of handleToMount relative to existing mount
 * @private
 */ function $d71a2f6bd42cb0cc$var$_resolveFileHandle(handleToMount) {
    let allMountPointResolutions = [];
    const currentMounts = $d71a2f6bd42cb0cc$require$MountPointsStore.getMountPoints();
    for (const [mountName, handle] of Object.entries(currentMounts))allMountPointResolutions.push(new Promise((resolve)=>{
        const isSameEntryPromise = handle.isSameEntry(handleToMount);
        const isSubEntryPromise = handle.resolve(handleToMount);
        Promise.all([
            isSameEntryPromise,
            isSubEntryPromise
        ]).then((mountDetail)=>{
            let isSameEntry = mountDetail[0] || false;
            let subPathList = mountDetail[1] || [];
            resolve({
                existingMountName: mountName,
                isSameEntry: isSameEntry,
                subPath: subPathList.join("/")
            });
        });
    }));
    return allMountPointResolutions;
}
function $d71a2f6bd42cb0cc$var$_getPathIfAlreadyMounted(handleToMount) {
    return new Promise((resolve)=>{
        let allMountPointResolutions = $d71a2f6bd42cb0cc$var$_resolveFileHandle(handleToMount);
        Promise.all(allMountPointResolutions).then((values)=>{
            for(let i = 0; i < values.length; i++){
                let mountName = values[i].existingMountName;
                if (values[i].isSameEntry) {
                    resolve(`${$d71a2f6bd42cb0cc$require$Constants.MOUNT_POINT_ROOT}/${mountName}`);
                    return;
                } else if (values[i].subPath.length >= 1) {
                    resolve(`${$d71a2f6bd42cb0cc$require$Constants.MOUNT_POINT_ROOT}/${mountName}/${values[i].subPath}`);
                    return;
                }
            }
            resolve(null);
        });
    });
}
function $d71a2f6bd42cb0cc$var$_getNewMountName(handleToMount) {
    let name = handleToMount.name;
    const currentMounts = $d71a2f6bd42cb0cc$require$MountPointsStore.getMountPoints();
    if (!currentMounts[name]) return name;
    for(let i = 0; i < $d71a2f6bd42cb0cc$var$MAX_NUM_MOUNTS; i++){
        let mountName = `${name}_${i}`;
        if (!currentMounts[mountName]) return mountName;
    }
}
/**
 * If the new handle is the same as or a subdir of an existing mount, we return the existing mount path
 * resolved to the given handle. Eg, if a folder `a` with subdir `b` is mounted to `mnt/a`;if we try to mount subdir `b`
 * then, we will return `mnt/a/b` as `b` is a subdirectory of an already mounted directory.
 * @param handleToMount
 * @param currentMounts {mountName1:handle1, ...}
 * @private
 */ function $d71a2f6bd42cb0cc$var$_mountHandle(handleToMount) {
    return new Promise(async (resolve, reject)=>{
        // eslint async executors are needed here. we explicitly catch so it's fine.
        try {
            let path = await $d71a2f6bd42cb0cc$var$_getPathIfAlreadyMounted(handleToMount);
            if (path) resolve(path);
            else {
                let mountName = $d71a2f6bd42cb0cc$var$_getNewMountName(handleToMount);
                if (!mountName) reject("Mount name not fount");
                else {
                    await $d71a2f6bd42cb0cc$require$MountPointsStore.addMountPoint(mountName, handleToMount);
                    resolve(`${$d71a2f6bd42cb0cc$require$Constants.MOUNT_POINT_ROOT}/${mountName}`);
                }
            }
        } catch (e) {
            reject(e);
        }
    });
}
/**
 * Mounts a native folder, using a provided directory handle or prompting the user with a directory picker if no handle is provided.
 *
 * @param {Object|null} [optionalDirHandle] - An optional directory handle to use for mounting. If not provided, the function will prompt the user to select a directory.
 * @param {Function} callback - A callback function that will be called once the mounting process completes or fails. The callback will be passed two parameters: an error (or null if no error) and an array containing the mounted path (or null if mounting failed).
 *
 * @example
 * // Using the directory picker
 * mountNativeFolder(function(error, [mountPath]) {
 *     if (error) {
 *         console.error("Error mounting directory:", error);
 *     } else {
 *         console.log("Directory mounted at:", mountPath);
 *     }
 * });
 *
 * @example
 * // Using a provided directory handle
 * const dirHandle = { /* ... directory handle ... * / };
 * mountNativeFolder(dirHandle, function(error, [mountPath]) {
 *     if (error) {
 *         console.error("Error mounting directory:", error);
 *     } else {
 *         console.log("Directory mounted at:", mountPath);
 *     }
 * });
 */ function $d71a2f6bd42cb0cc$var$mountNativeFolder(optionalDirHandle, callback) {
    if (!callback) {
        callback = optionalDirHandle;
        optionalDirHandle = null;
    }
    let mountedPath = null;
    let error = null;
    $d71a2f6bd42cb0cc$require$MountPointsStore.refreshMountPoints().then(()=>optionalDirHandle || globalObject.showDirectoryPicker()).then((directoryHandle)=>$d71a2f6bd42cb0cc$var$_mountHandle(directoryHandle)).then((mountPath)=>mountedPath = mountPath).then(()=>$d71a2f6bd42cb0cc$var$_broadcastMountPointChanged()).catch(function(err) {
        error = new $d71a2f6bd42cb0cc$require$Errors.ENOTMOUNTED(err);
    }).finally(()=>{
        if (callback) callback(error, [
            mountedPath
        ]);
        else if (error) throw new $d71a2f6bd42cb0cc$require$Errors.ENOTMOUNTED(error);
    });
}
async function $d71a2f6bd42cb0cc$var$_verifyOrRequestPermission(handle) {
    const options = {
        mode: "read"
    };
    // Check if permission was already granted. If so, return true.
    try {
        let status = await handle.queryPermission(options);
        if (status === "granted") return null;
        status = await handle.requestPermission(options);
        if (status === "granted") return null;
        else return new $d71a2f6bd42cb0cc$require$Errors.EACCES(`Dir permissions not granted ${handle.name}`);
    } catch (e) {
        if (e.code === e.NOT_FOUND_ERR) return new $d71a2f6bd42cb0cc$require$Errors.ENOENT(`Dir does not exist ${handle.name}`, e);
        else return new $d71a2f6bd42cb0cc$require$Errors.EIO(`Phoenix fs could not read directory ${handle.name}`, e);
    }
}
async function $d71a2f6bd42cb0cc$var$_findLeafNode(currentNode, pathArray, currentIndex, callback) {
    let pathLength = pathArray.length;
    if (currentIndex === pathLength) {
        callback(null, currentNode);
        return;
    }
    let childName = pathArray[currentIndex];
    let childDirHandle = null;
    let childFileHandle = null;
    try {
        childDirHandle = await currentNode.getDirectoryHandle(childName);
    } catch (e) {
    // do nothing
    }
    try {
        childFileHandle = await currentNode.getFileHandle(childName);
    } catch (e) {
    // do nothing
    }
    if (childFileHandle && currentIndex === pathLength - 1) // the last node is a file
    callback(null, childFileHandle);
    else if (childDirHandle) $d71a2f6bd42cb0cc$var$_findLeafNode(childDirHandle, pathArray, currentIndex + 1, callback);
    else {
        let path = pathArray.join("/");
        callback(new $d71a2f6bd42cb0cc$require$Errors.ENOENT("File/Dir does not exist: ", path));
    }
}
async function $d71a2f6bd42cb0cc$var$getHandleFromPath(normalisedPath, callback) {
    const pathNodes = normalisedPath.split("/");
    const currentMounts = $d71a2f6bd42cb0cc$require$MountPointsStore.getMountPoints();
    if (pathNodes.length < 3 || pathNodes[0] !== "" || pathNodes[1] !== "mnt") callback(new $d71a2f6bd42cb0cc$require$Errors.EINVAL("Cannot operate on path " + normalisedPath));
    let mountPoint = currentMounts[pathNodes[2]];
    if (!mountPoint) {
        callback(new $d71a2f6bd42cb0cc$require$Errors.ENOENT("Path does not exist: ", normalisedPath));
        return;
    }
    let error = await $d71a2f6bd42cb0cc$var$_verifyOrRequestPermission(mountPoint);
    if (error) {
        callback(error);
        return;
    }
    $d71a2f6bd42cb0cc$var$_findLeafNode(mountPoint, pathNodes, 3, callback);
}
async function $d71a2f6bd42cb0cc$var$getHandleFromPathIfPresent(normalisedPath) {
    return new Promise((resolve)=>{
        $d71a2f6bd42cb0cc$var$getHandleFromPath(normalisedPath, (err, handle)=>{
            if (err) resolve(null);
            else resolve(handle);
        });
    });
}
function $d71a2f6bd42cb0cc$var$getMountPoints() {
    return $d71a2f6bd42cb0cc$require$MountPointsStore.getMountPoints();
}
function $d71a2f6bd42cb0cc$var$refreshMountPoints() {
    return $d71a2f6bd42cb0cc$require$MountPointsStore.refreshMountPoints();
}
$d71a2f6bd42cb0cc$var$_listenToMountPointChanges();
const $d71a2f6bd42cb0cc$var$Mounts = {
    mountNativeFolder: $d71a2f6bd42cb0cc$var$mountNativeFolder,
    isMountPath: $d71a2f6bd42cb0cc$var$isMountPath,
    isMountSubPath: $d71a2f6bd42cb0cc$var$isMountSubPath,
    getHandleFromPath: $d71a2f6bd42cb0cc$var$getHandleFromPath,
    getMountPoints: $d71a2f6bd42cb0cc$var$getMountPoints,
    refreshMountPoints: $d71a2f6bd42cb0cc$var$refreshMountPoints,
    getHandleFromPathIfPresent: $d71a2f6bd42cb0cc$var$getHandleFromPathIfPresent
};
$d71a2f6bd42cb0cc$exports = {
    Mounts: $d71a2f6bd42cb0cc$var$Mounts
};


var $bd5c47de9e98f4fa$require$Mounts = $d71a2f6bd42cb0cc$exports.Mounts;

var $bd5c47de9e98f4fa$require$Errors = $ee841df9a5ce9c95$exports.Errors;
var $bd5c47de9e98f4fa$require$ERR_CODES = $ee841df9a5ce9c95$exports.ERR_CODES;

var $bd5c47de9e98f4fa$require$Constants = $2ef5299e07961cfe$exports.Constants;
var $659ab4db13967c07$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ /*global globalObject*/ // jshint ignore: start
/*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 


var $kznHi = parcelRequire("kznHi");
var $659ab4db13967c07$require$Buffer = $kznHi.Buffer;

var $659ab4db13967c07$require$Constants = $2ef5299e07961cfe$exports.Constants;
const $659ab4db13967c07$var$TAURI_PATH_PREFIX = $659ab4db13967c07$require$Constants.TAURI_ROOT + "/";
const $659ab4db13967c07$var$IS_WINDOWS = navigator.userAgent.includes("Windows");
function $659ab4db13967c07$var$_dateFromMs(ms) {
    if (ms === null || ms === undefined) return null;
    return new Date(Number(ms));
}
function $659ab4db13967c07$var$Stats(path, fileNode, devName) {
    this.dev = devName;
    this.node = fileNode.id;
    this.type = fileNode.type;
    this.size = fileNode.size;
    this.nlinks = fileNode.nlinks;
    this.nlink = fileNode.nlinks;
    // Date objects
    this.atime = $659ab4db13967c07$var$_dateFromMs(fileNode.atime);
    this.mtime = $659ab4db13967c07$var$_dateFromMs(fileNode.mtime);
    this.ctime = $659ab4db13967c07$var$_dateFromMs(fileNode.ctime);
    // Unix timestamp MS Numbers
    this.atimeMs = fileNode.atime;
    this.mtimeMs = fileNode.mtime;
    this.ctimeMs = fileNode.ctime;
    this.version = fileNode.version;
    this.mode = fileNode.mode;
    this.readonly = fileNode.readonly;
    this.name = globalObject.path.basename(path);
}
$659ab4db13967c07$var$Stats.prototype.isFile = function() {
    return this.type === $659ab4db13967c07$require$Constants.NODE_TYPE_FILE;
};
$659ab4db13967c07$var$Stats.prototype.isDirectory = function() {
    return this.type === $659ab4db13967c07$require$Constants.NODE_TYPE_DIRECTORY;
};
$659ab4db13967c07$var$Stats.prototype.isSymbolicLink = function() {
    return this.type === $659ab4db13967c07$require$Constants.NODE_TYPE_SYMBOLIC_LINK;
};
// These will always be false in Filer.
$659ab4db13967c07$var$Stats.prototype.isSocket = $659ab4db13967c07$var$Stats.prototype.isFIFO = $659ab4db13967c07$var$Stats.prototype.isCharacterDevice = $659ab4db13967c07$var$Stats.prototype.isBlockDevice = function() {
    return false;
};
function $659ab4db13967c07$var$_getType(handle) {
    switch(handle.kind){
        case $659ab4db13967c07$require$Constants.KIND_FILE:
            return $659ab4db13967c07$require$Constants.NODE_TYPE_FILE;
        case $659ab4db13967c07$require$Constants.KIND_DIRECTORY:
            return $659ab4db13967c07$require$Constants.NODE_TYPE_DIRECTORY;
        default:
            return null;
    }
}
async function $659ab4db13967c07$var$_getDetails(nativeFsHandle) {
    let file = null;
    let details = {};
    switch(nativeFsHandle.kind){
        case $659ab4db13967c07$require$Constants.KIND_FILE:
            file = await nativeFsHandle.getFile();
            details.size = file.size;
            details.mtime = file.lastModified;
            return details;
        case $659ab4db13967c07$require$Constants.KIND_DIRECTORY:
        default:
            return details;
    }
}
const $659ab4db13967c07$var$createStatObject = async function(path, handle) {
    let details = await $659ab4db13967c07$var$_getDetails(handle);
    let fileDetails = {
        type: $659ab4db13967c07$var$_getType(handle),
        size: details.size,
        mtime: details.mtime
    };
    return new $659ab4db13967c07$var$Stats(path, fileDetails, $659ab4db13967c07$require$Constants.MOUNT_DEVICE_NAME);
};
const $659ab4db13967c07$var$createDummyStatObject = function(path, isDir, deviceName) {
    let fileDetails = {
        type: isDir ? $659ab4db13967c07$require$Constants.NODE_TYPE_DIRECTORY : $659ab4db13967c07$require$Constants.NODE_TYPE_FILE,
        size: 0
    };
    return new $659ab4db13967c07$var$Stats(path, fileDetails, deviceName);
};
const $659ab4db13967c07$var$createFromTauriStat = function(vfsPath, stats) {
    let type = $659ab4db13967c07$require$Constants.NODE_TYPE_DIRECTORY;
    if (stats.isFile) type = $659ab4db13967c07$require$Constants.NODE_TYPE_FILE;
    else if (stats.isSymlink) type = $659ab4db13967c07$require$Constants.NODE_TYPE_SYMBOLIC_LINK;
    stats.permissions = stats.permissions || {};
    let fileDetails = {
        type: type,
        size: stats.size,
        mode: stats.mode || stats.permissions.mode,
        readonly: stats.permissions.readonly,
        ctime: stats.createdAtMs,
        atime: stats.accessedAtMs,
        mtime: stats.modifiedAtMs,
        nlinks: stats.nlink
    };
    return new $659ab4db13967c07$var$Stats(vfsPath, fileDetails, `${$659ab4db13967c07$require$Constants.TAURI_DEVICE_NAME}_${stats.dev}`);
};
const $659ab4db13967c07$var$createFromNodeStat = function(vfsPath, stats) {
    let type = $659ab4db13967c07$require$Constants.NODE_TYPE_DIRECTORY;
    if (stats.isFile) type = $659ab4db13967c07$require$Constants.NODE_TYPE_FILE;
    else if (stats.isSymbolicLink) type = $659ab4db13967c07$require$Constants.NODE_TYPE_SYMBOLIC_LINK;
    stats.permissions = stats.permissions || {};
    let fileDetails = {
        type: type,
        size: stats.size,
        mode: stats.mode,
        readonly: stats.readonly,
        ctime: stats.ctimeMs,
        atime: stats.atimeMs,
        mtime: stats.mtimeMs,
        nlinks: stats.nlink
    };
    return new $659ab4db13967c07$var$Stats(vfsPath, fileDetails, `${$659ab4db13967c07$require$Constants.TAURI_WS_DEVICE_NAME}_${stats.dev}`);
};
function $659ab4db13967c07$var$validateFileOptions(options, enc, fileMode) {
    if (!options || typeof options === "function") options = {
        encoding: enc,
        flag: fileMode
    };
    else if (typeof options === "string") options = {
        encoding: options,
        flag: fileMode
    };
    options.encoding = options.encoding || enc;
    options.flag = options.flag || fileMode;
    return options;
}
const $659ab4db13967c07$var$NATIVE_ENCODINGS = [
    "utf8",
    "UTF8",
    "utf-8",
    "UTF-8"
];
// ArrayBuffer to string
function $659ab4db13967c07$var$getDecodedString(arrayBuffer, encoding) {
    if (!(arrayBuffer instanceof ArrayBuffer)) throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL(`ArrayBuffer expected to decode ${encoding}`);
    if (encoding === $659ab4db13967c07$require$Constants.BYTE_ARRAY_ENCODING) encoding = $659ab4db13967c07$require$Constants.BINARY_ENCODING;
    try {
        if ($659ab4db13967c07$var$NATIVE_ENCODINGS[encoding]) // for utf8 we use the browser native decoder.
        // The browser encoder does only utf-8, so we only use the native encoder/decoder for utf8.
        return new TextDecoder(encoding).decode(arrayBuffer);
        else return $54aff2427aaf4272$exports.decode($659ab4db13967c07$require$Buffer.from(arrayBuffer), encoding);
    } catch (e) {
        throw new (0, $ee841df9a5ce9c95$exports.Errors).ECHARSET(`${encoding} not supported ${e.message}`);
    }
}
function $659ab4db13967c07$var$getDecodedStringFromBuffer(buf, encoding) {
    if (!$659ab4db13967c07$require$Buffer.isBuffer(buf)) throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL(`Buffer expected to decode ${encoding}`);
    if (encoding === $659ab4db13967c07$require$Constants.BYTE_ARRAY_ENCODING) encoding = $659ab4db13967c07$require$Constants.BINARY_ENCODING;
    try {
        // for buffer, we directly use iconv for even utf 8 to prevent large file array copys
        return $54aff2427aaf4272$exports.decode(buf, encoding);
    } catch (e) {
        throw new (0, $ee841df9a5ce9c95$exports.Errors).ECHARSET(`${encoding} not supported ${e.message}`);
    }
}
// getEncodedArrayBuffer and getEncodedBuffer for performance. filer natively uses Buffer and tauri/fs access
// uses array buffer. So we have both to prevent unnecessary large data buffer<>arrayBuffer conversions.
function $659ab4db13967c07$var$getEncodedArrayBuffer(str, encoding) {
    if (typeof str !== "string") throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL(`String expected to Encode ${encoding} but got ${typeof str}`);
    if (encoding === $659ab4db13967c07$require$Constants.BYTE_ARRAY_ENCODING) encoding = $659ab4db13967c07$require$Constants.BINARY_ENCODING;
    try {
        if ($659ab4db13967c07$var$NATIVE_ENCODINGS[encoding]) {
            // for utf8 we use the browser native decoder.
            // The browser encoder does only utf-8, so we only use the native encoder/decoder for utf8.
            let encoder = new TextEncoder(encoding);
            return encoder.encode(str).buffer;
        } else {
            let buf = $54aff2427aaf4272$exports.encode(str, encoding);
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        }
    } catch (e) {
        throw new (0, $ee841df9a5ce9c95$exports.Errors).ECHARSET(`${encoding} not supported ${e.message}`);
    }
}
// getEncodedArrayBuffer and getEncodedBuffer for performance. filer natively uses Buffer and tauri/fs access
// uses array buffer. So we have both to prevent unnecessary large data buffer<>arrayBuffer conversions.
function $659ab4db13967c07$var$getEncodedBuffer(str, encoding) {
    if (typeof str !== "string") throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL(`String expected to Encode ${encoding} but got ${typeof str}`);
    if (encoding === $659ab4db13967c07$require$Constants.BYTE_ARRAY_ENCODING) encoding = $659ab4db13967c07$require$Constants.BINARY_ENCODING;
    try {
        if ($659ab4db13967c07$var$NATIVE_ENCODINGS[encoding]) {
            // for utf8 we use the browser native decoder.
            // The browser encoder does only utf-8, so we only use the native encoder/decoder for utf8.
            let encoder = new TextEncoder(encoding);
            return $659ab4db13967c07$require$Buffer.from(encoder.encode(str).buffer);
        } else return $54aff2427aaf4272$exports.encode(str, encoding);
    } catch (e) {
        throw new (0, $ee841df9a5ce9c95$exports.Errors).ECHARSET(`${encoding} not supported ${e.message}`);
    }
}
/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */ function $659ab4db13967c07$var$toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) return buf.buffer;
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
/**
 *
 * @param metadata {Object} Max size can be 4GB
 * @param bufferData {ArrayBuffer} [optional]
 * @return {ArrayBuffer}
 * @private
 */ function $659ab4db13967c07$var$mergeMetadataAndArrayBuffer(metadata, bufferData = new ArrayBuffer(0)) {
    if (typeof metadata !== "object") throw new Error("metadata should be an object, but was " + typeof metadata);
    if (!(bufferData instanceof ArrayBuffer)) throw new Error("Expected bufferData to be an instance of ArrayBuffer, but was " + typeof bufferData);
    const metadataString = JSON.stringify(metadata);
    const metadataUint8Array = new TextEncoder().encode(metadataString);
    const metadataBuffer = metadataUint8Array.buffer;
    const sizePrefixLength = 4; // 4 bytes for a 32-bit integer
    if (metadataBuffer.byteLength > 4294000000) throw new Error("metadata too large. Should be below 4,294MB, but was " + metadataBuffer.byteLength);
    const concatenatedBuffer = new ArrayBuffer(sizePrefixLength + metadataBuffer.byteLength + bufferData.byteLength);
    const concatenatedUint8Array = new Uint8Array(concatenatedBuffer);
    // Write the length of metadataBuffer as a 32-bit integer
    new DataView(concatenatedBuffer).setUint32(0, metadataBuffer.byteLength, true);
    // Copy the metadataUint8Array and bufferData (if provided) to the concatenatedUint8Array
    concatenatedUint8Array.set(metadataUint8Array, sizePrefixLength);
    if (bufferData.byteLength > 0) concatenatedUint8Array.set(new Uint8Array(bufferData), sizePrefixLength + metadataBuffer.byteLength);
    return concatenatedBuffer;
}
function $659ab4db13967c07$var$splitMetadataAndBuffer(concatenatedBuffer) {
    if (!(concatenatedBuffer instanceof ArrayBuffer)) throw new Error("Expected ArrayBuffer message from websocket");
    const sizePrefixLength = 4;
    const buffer1Length = new DataView(concatenatedBuffer).getUint32(0, true); // Little endian
    const buffer1 = concatenatedBuffer.slice(sizePrefixLength, sizePrefixLength + buffer1Length);
    let buffer2;
    if (concatenatedBuffer.byteLength > sizePrefixLength + buffer1Length) buffer2 = concatenatedBuffer.slice(sizePrefixLength + buffer1Length);
    return {
        metadata: JSON.parse(new TextDecoder().decode(buffer1)),
        bufferData: buffer2
    };
}
/**
 * Convert Phoenix virtual file system path to platform-specific paths.
 * For Windows, `/tauri/c/d/a.txt` will correspond to `c:\d\a.txt`.
 * For *nix systems (Linux/Mac/Unix), `/tauri/x/y/a.txt` will correspond to `/x/y/a.txt`.
 *
 * @param {string} phoenixFSPath - The Phoenix virtual file system path to be converted.
 * @returns {string} The platform-specific path.
 *
 * @throws {Errors.EINVAL} If the provided path doesn't start with `/tauri/` or cannot resolve to system path.
 *
 * @example
 * // On a Windows system
 * getTauriPlatformPath('/tauri/c/users/user/a.txt');  // Returns: 'c:\users\user\a.txt'
 *
 * // On a *nix system
 * getTauriPlatformPath('/tauri/home/user/a.txt');  // Returns: '/home/user/a.txt'
 */ function $659ab4db13967c07$var$getTauriPlatformPath(phoenixFSPath) {
    if (phoenixFSPath === $659ab4db13967c07$require$Constants.TAURI_ROOT) phoenixFSPath = $659ab4db13967c07$var$TAURI_PATH_PREFIX;
    if (!phoenixFSPath.startsWith($659ab4db13967c07$var$TAURI_PATH_PREFIX)) throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL("Invalid Phoenix FS path- tauri path prefix expected: " + phoenixFSPath);
    if ($659ab4db13967c07$var$IS_WINDOWS) {
        let parts = phoenixFSPath.split("/").slice(2);
        if (!parts[0].length) // maps to just ":\", no drive prefix available
        throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL("Invalid Phoenix FS path for windows: " + phoenixFSPath);
        return `${parts[0]}:\\${parts.slice(1).join("\\")}`;
    } else return phoenixFSPath.slice($659ab4db13967c07$require$Constants.TAURI_ROOT.length);
}
/**
 * Convert platform-specific Tauri paths to Phoenix virtual file system path.
 * For Windows, `c:\d\a.txt` will correspond to `/tauri/c/d/a.txt`.
 * For *nix systems (Linux/Mac/Unix), `/x/y/a.txt` will correspond to `/tauri/x/y/a.txt`.
 *
 * @param {string} platformPath - The platform-specific path to be converted.
 * @returns {string} The Phoenix virtual file system path.
 *
 * @throws {Errors.EINVAL} If the provided path cannot be converted to Phoenix FS path.
 *
 * @example
 * // On a Windows system
 * getTauriVirtualPath('c:\users\user\a.txt');  // Returns: '/tauri/c/users/user/a.txt'
 *
 * // On a *nix system
 * getTauriVirtualPath('/home/user/a.txt');  // Returns: '/tauri/home/user/a.txt'
 */ function $659ab4db13967c07$var$getTauriVirtualPath(platformPath) {
    if ($659ab4db13967c07$var$IS_WINDOWS) {
        // For Windows, we split using both forward and backward slashes because users might use either
        let parts = platformPath.split(/[\\/]/);
        if (!parts[0].endsWith(":") || parts[0].length !== 2) throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL("Invalid Windows path format: " + platformPath);
        let driveLetter = parts[0].slice(0, -1); // Remove the ':' from 'c:'
        return `/tauri/${driveLetter}/${parts.slice(1).join("/")}`;
    } else {
        if (!platformPath.startsWith("/")) throw new (0, $ee841df9a5ce9c95$exports.Errors).EINVAL("Invalid Unix path format: " + platformPath);
        return $659ab4db13967c07$require$Constants.TAURI_ROOT + platformPath;
    }
}
/**
 * Check if the given path is a subpath of the '/tauri' folder.
 * @param path
 */ function $659ab4db13967c07$var$isTauriSubPath(path) {
    if (typeof path !== "string") return false;
    if (path) {
        path = globalObject.path.normalize(path);
        if (path.startsWith($659ab4db13967c07$var$TAURI_PATH_PREFIX) && path.length > $659ab4db13967c07$var$TAURI_PATH_PREFIX.length) return true;
    }
    return false;
}
/**
 * Check if the given path is '/tauri' folder.
 * @param path
 */ function $659ab4db13967c07$var$isTauriPath(path) {
    if (typeof path !== "string") return false;
    if (path) {
        path = globalObject.path.normalize(path);
        if (path === $659ab4db13967c07$require$Constants.TAURI_ROOT) return true;
    }
    return false;
}
const $659ab4db13967c07$var$Utils = {
    createStatObject: $659ab4db13967c07$var$createStatObject,
    createDummyStatObject: $659ab4db13967c07$var$createDummyStatObject,
    createFromTauriStat: $659ab4db13967c07$var$createFromTauriStat,
    createFromNodeStat: $659ab4db13967c07$var$createFromNodeStat,
    isTauriSubPath: $659ab4db13967c07$var$isTauriSubPath,
    isTauriPath: $659ab4db13967c07$var$isTauriPath,
    getTauriPlatformPath: $659ab4db13967c07$var$getTauriPlatformPath,
    getTauriVirtualPath: $659ab4db13967c07$var$getTauriVirtualPath,
    validateFileOptions: $659ab4db13967c07$var$validateFileOptions,
    toArrayBuffer: $659ab4db13967c07$var$toArrayBuffer,
    getDecodedString: $659ab4db13967c07$var$getDecodedString,
    getDecodedStringFromBuffer: $659ab4db13967c07$var$getDecodedStringFromBuffer,
    getEncodedArrayBuffer: $659ab4db13967c07$var$getEncodedArrayBuffer,
    getEncodedBuffer: $659ab4db13967c07$var$getEncodedBuffer,
    mergeMetadataAndArrayBuffer: $659ab4db13967c07$var$mergeMetadataAndArrayBuffer,
    splitMetadataAndBuffer: $659ab4db13967c07$var$splitMetadataAndBuffer
};
$659ab4db13967c07$exports = {
    Utils: $659ab4db13967c07$var$Utils
};


var $bd5c47de9e98f4fa$require$Utils = $659ab4db13967c07$exports.Utils;
async function $bd5c47de9e98f4fa$var$_listDir(path, handle, options, callback) {
    let dirEntryNames = [];
    try {
        for await (const [key, value] of handle.entries()){
            let entry = key;
            if (options["withFileTypes"]) entry = await $bd5c47de9e98f4fa$require$Utils.createStatObject(globalObject.path.join(path, key), value);
            dirEntryNames.push(entry);
        }
        if (callback) callback(null, dirEntryNames);
        return dirEntryNames;
    } catch (e) {
        if (e.code === e.NOT_FOUND_ERR) callback(new $bd5c47de9e98f4fa$require$Errors.ENOENT(`Dir does not exist ${handle.name}`, e));
        else callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`Phoenix fs could not read directory ${handle.name}`, e));
    }
}
// never throws
async function $bd5c47de9e98f4fa$var$_subDirectoryExists(parentDirHandle, dirName) {
    try {
        await parentDirHandle.getDirectoryHandle(dirName);
        return true;
    } catch (e) {
        return false;
    }
}
async function $bd5c47de9e98f4fa$var$_mkdir(parentDirHandle, dirName, callback) {
    try {
        let alreadyExists = await $bd5c47de9e98f4fa$var$_subDirectoryExists(parentDirHandle, dirName);
        if (alreadyExists) {
            callback(new $bd5c47de9e98f4fa$require$Errors.EEXIST(`Folder ${dirName} already exists`));
            return;
        }
        let childDirHandle = await parentDirHandle.getDirectoryHandle(dirName, {
            create: true
        });
        if (callback) callback(null);
        return childDirHandle;
    } catch (e) {
        if (callback) {
            callback(new $bd5c47de9e98f4fa$require$Errors.EIO("Filer native fs.mkdir failed.", e));
            return;
        }
        throw new $bd5c47de9e98f4fa$require$Errors.EIO("Filer native fs function not yet supported.", e);
    }
}
function $bd5c47de9e98f4fa$var$mkdir(path, mode, callback) {
    if (arguments.length < 3) callback = mode;
    path = globalObject.path.normalize(path);
    let dirname = globalObject.path.dirname(path);
    let subdirName = globalObject.path.basename(path);
    $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(dirname, (err, handle)=>{
        if (err) callback(err);
        else if (handle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) callback(new $bd5c47de9e98f4fa$require$Errors.ENOTDIR("Parent path is not a directory."));
        else $bd5c47de9e98f4fa$var$_mkdir(handle, subdirName, callback);
    });
}
function $bd5c47de9e98f4fa$var$readdir(path, options, callback) {
    path = globalObject.path.normalize(path);
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (path === $bd5c47de9e98f4fa$require$Constants.MOUNT_POINT_ROOT) {
        const mountPoints = $bd5c47de9e98f4fa$require$Mounts.getMountPoints();
        let mountPointNames = Object.keys(mountPoints);
        if (options["withFileTypes"]) {
            let stats = [];
            for (let mountPointName of mountPointNames)stats.push($bd5c47de9e98f4fa$require$Utils.createStatObject(globalObject.path.join(path, mountPointName), mountPoints[mountPointName]));
            Promise.all(stats).then((results)=>{
                callback(null, results);
            }).catch((err)=>{
                callback(new $bd5c47de9e98f4fa$require$Errors.EIO("Failed reading directory: " + path + err));
            });
            return;
        }
        callback(null, mountPointNames);
    } else $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(path, (err, handle)=>{
        if (err) callback(err);
        else if (handle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) callback(new $bd5c47de9e98f4fa$require$Errors.ENOTDIR("Path is not a directory."));
        else $bd5c47de9e98f4fa$var$_listDir(path, handle, options, callback);
    });
}
async function $bd5c47de9e98f4fa$var$_getFileContents(fileHandle, encoding, callback, path) {
    try {
        let file = await fileHandle.getFile();
        const arrayBuffer = await file.arrayBuffer();
        if (encoding === $bd5c47de9e98f4fa$require$Constants.BYTE_ARRAY_ENCODING) {
            callback(null, arrayBuffer, encoding);
            return;
        } else if (encoding === $bd5c47de9e98f4fa$require$Constants.BINARY_ENCODING) {
            const buffer = $bd5c47de9e98f4fa$require$Buffer.from(arrayBuffer);
            callback(null, buffer, encoding);
            return;
        }
        let decodedString = $bd5c47de9e98f4fa$require$Utils.getDecodedString(arrayBuffer, encoding);
        callback(null, decodedString, encoding);
    } catch (e) {
        if ($bd5c47de9e98f4fa$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
function $bd5c47de9e98f4fa$var$readFile(path, options, callback) {
    try {
        path = globalObject.path.normalize(path);
        callback = arguments[arguments.length - 1];
        options = $bd5c47de9e98f4fa$require$Utils.validateFileOptions(options, $bd5c47de9e98f4fa$require$Constants.BINARY_ENCODING, "r");
        $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(path, (err, handle)=>{
            if (err) callback(err);
            else if (handle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY) callback(new $bd5c47de9e98f4fa$require$Errors.EISDIR("Path is a directory."));
            else $bd5c47de9e98f4fa$var$_getFileContents(handle, options.encoding, callback, path);
        });
    } catch (e) {
        if ($bd5c47de9e98f4fa$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
function $bd5c47de9e98f4fa$var$stat(path, callback) {
    path = globalObject.path.normalize(path);
    $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(path, (err, handle)=>{
        if (err) callback(err);
        else $bd5c47de9e98f4fa$require$Utils.createStatObject(path, handle).then((pathStat)=>{
            callback(null, pathStat);
        }).catch((error)=>{
            callback(error);
        });
    });
}
async function $bd5c47de9e98f4fa$var$_writeFileWithName(paretDirHandle, fileName, encoding, data, callback) {
    try {
        const newFileHandle = await paretDirHandle.getFileHandle(fileName, {
            create: true
        });
        const writable = await newFileHandle.createWritable();
        await writable.write(data);
        await writable.close();
        callback(null);
    } catch (e) {
        callback(e);
    }
}
function $bd5c47de9e98f4fa$var$writeFile(path, data, options, callback) {
    try {
        callback = arguments[arguments.length - 1];
        options = $bd5c47de9e98f4fa$require$Utils.validateFileOptions(options, $bd5c47de9e98f4fa$require$Constants.BINARY_ENCODING, "w");
        let arrayBuffer;
        if (data instanceof ArrayBuffer) arrayBuffer = data;
        else if ($bd5c47de9e98f4fa$require$Buffer.isBuffer(data)) arrayBuffer = $bd5c47de9e98f4fa$require$Utils.toArrayBuffer(data);
        else {
            if (typeof data === "number") data = "" + data;
            data = data || ""; // this should be after number check as if data = 0, things break
            if (typeof data !== "string") data = data.toString();
            arrayBuffer = $bd5c47de9e98f4fa$require$Utils.getEncodedArrayBuffer(data, options.encoding);
        }
        path = globalObject.path.normalize(path);
        let dirname = globalObject.path.dirname(path);
        let fileName = globalObject.path.basename(path);
        $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(dirname, (err, handle)=>{
            if (err) callback(err);
            else if (handle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) callback(new $bd5c47de9e98f4fa$require$Errors.ENOTDIR("Parent path is not a directory."));
            else $bd5c47de9e98f4fa$var$_writeFileWithName(handle, fileName, options.encoding, arrayBuffer, callback);
        });
    } catch (e) {
        if ($bd5c47de9e98f4fa$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`IO error while processing data write from file on path: ${path}`, path));
    }
}
async function $bd5c47de9e98f4fa$var$_deleteEntry(dirHandle, entryNameToDelete, callback, path) {
    try {
        await dirHandle.removeEntry(entryNameToDelete, {
            recursive: true
        });
        callback(null);
    } catch (err) {
        callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`Error while deleting path: ${path}, ${err.message}`, path));
    }
}
async function $bd5c47de9e98f4fa$var$unlink(path, callback) {
    path = globalObject.path.normalize(path);
    let dirPath = globalObject.path.dirname(path);
    let baseName = globalObject.path.basename(path);
    $bd5c47de9e98f4fa$var$stat(path, (_err)=>{
        if (_err) {
            // enoent or other error means delete will mostly fail. pass it through.
            callback(_err);
            return;
        }
        $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(dirPath, async (err, dirHandle)=>{
            if (err) callback(err);
            else $bd5c47de9e98f4fa$var$_deleteEntry(dirHandle, baseName, callback, path);
        });
    });
}
async function $bd5c47de9e98f4fa$var$_getDestinationHandleForCopy(dst, srcBaseName, handleKindToCreate) {
    return new Promise(async (resolve, reject)=>{
        // eslint async executors are needed here. we explicitly catch so it's fine.
        try {
            dst = globalObject.path.normalize(dst);
            let dirPath = globalObject.path.dirname(dst);
            let dstBaseName = globalObject.path.basename(dst);
            let dstHandle = await $bd5c47de9e98f4fa$require$Mounts.getHandleFromPathIfPresent(dst);
            let dstParentHandle = await $bd5c47de9e98f4fa$require$Mounts.getHandleFromPathIfPresent(dirPath);
            if (dstHandle && dstHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) reject(new $bd5c47de9e98f4fa$require$Errors.EEXIST(`Destination file already exists: ${dst}`));
            else if (dstHandle && dstHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY && handleKindToCreate === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) {
                const fileHandle = await dstHandle.getFileHandle(srcBaseName, {
                    create: true
                });
                const dstPath = `${dst}/${srcBaseName}`;
                resolve({
                    handle: fileHandle,
                    path: dstPath
                });
            } else if (dstHandle && dstHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY && handleKindToCreate === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY) {
                let dstChildHandle = await $bd5c47de9e98f4fa$require$Mounts.getHandleFromPathIfPresent(`${dst}/${srcBaseName}`);
                if (dstChildHandle) {
                    reject(new $bd5c47de9e98f4fa$require$Errors.EEXIST(`Copy destination already exists: ${dst}/${srcBaseName}`));
                    return;
                }
                const directoryHandle = await dstHandle.getDirectoryHandle(srcBaseName, {
                    create: true
                });
                const dstPath = `${dst}/${srcBaseName}`;
                resolve({
                    handle: directoryHandle,
                    path: dstPath
                });
            } else if (!dstHandle && dstParentHandle && dstParentHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY && handleKindToCreate === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) {
                const fileHandle = await dstParentHandle.getFileHandle(dstBaseName, {
                    create: true
                });
                const dstPath = `${dirPath}/${dstBaseName}`;
                resolve({
                    handle: fileHandle,
                    path: dstPath
                });
            } else if (!dstHandle && dstParentHandle && dstParentHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY && handleKindToCreate === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY) {
                const fileHandle = await dstParentHandle.getDirectoryHandle(dstBaseName, {
                    create: true
                });
                const dstPath = `${dirPath}/${dstBaseName}`;
                resolve({
                    handle: fileHandle,
                    path: dstPath
                });
            } else reject(new $bd5c47de9e98f4fa$require$Errors.ENOENT(`Copy destination doesnt exist: ${dst}`));
        } catch (e) {
            reject(e);
        }
    });
}
async function $bd5c47de9e98f4fa$var$_copyFileFromHandles(srcFileHandle, dstHandle, optionalName) {
    // TODO Add retry mechanisms when copying large folders
    try {
        if (optionalName) dstHandle = await dstHandle.getFileHandle(optionalName, {
            create: true
        });
        const srcFile = await srcFileHandle.getFile();
        const srcStream = await srcFile.stream();
        const writable = await dstHandle.createWritable();
        await srcStream.pipeTo(writable);
    } catch (e) {
        console.error(`PhoenixFS: Error while copying ${dstHandle.name}/${optionalName} : ${e}`);
        throw e;
    }
}
async function $bd5c47de9e98f4fa$var$_copyFileWithHandle(srcFileHandle, dst, srcFileName, callback) {
    try {
        let { handle: handle, path: path } = await $bd5c47de9e98f4fa$var$_getDestinationHandleForCopy(dst, srcFileName, $bd5c47de9e98f4fa$require$Constants.KIND_FILE);
        await $bd5c47de9e98f4fa$var$_copyFileFromHandles(srcFileHandle, handle);
        callback(null, path);
    } catch (e) {
        callback(e);
    }
}
async function $bd5c47de9e98f4fa$var$_treeCopy(srcFolderHandle, dstFolderHandle, recursive) {
    let allDonePromises = [];
    for await (const [key, srcHandle] of srcFolderHandle.entries()){
        if (srcHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) allDonePromises.push($bd5c47de9e98f4fa$var$_copyFileFromHandles(srcHandle, dstFolderHandle, key));
        else if (srcHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY) {
            const childDirHandle = await $bd5c47de9e98f4fa$var$_mkdir(dstFolderHandle, key);
            if (recursive && childDirHandle) allDonePromises.push($bd5c47de9e98f4fa$var$_treeCopy(srcHandle, childDirHandle, recursive));
        }
    }
    await Promise.all(allDonePromises);
}
async function $bd5c47de9e98f4fa$var$_copyFolderWithHandle(srcFolderHandle, dst, srcFileName, callback, recursive) {
    try {
        let { handle: handle, path: path } = await $bd5c47de9e98f4fa$var$_getDestinationHandleForCopy(dst, srcFileName, $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY);
        await $bd5c47de9e98f4fa$var$_treeCopy(srcFolderHandle, handle, recursive);
        callback(null, path);
    } catch (e) {
        callback(e);
    }
}
async function $bd5c47de9e98f4fa$var$copy(src, dst, callback, recursive = true) {
    let srcFile = globalObject.path.normalize(src);
    let srcFileName = globalObject.path.basename(srcFile);
    $bd5c47de9e98f4fa$require$Mounts.getHandleFromPath(srcFile, async (err, srcHandle)=>{
        if (err) callback(err);
        else if (srcHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_FILE) return $bd5c47de9e98f4fa$var$_copyFileWithHandle(srcHandle, dst, srcFileName, callback);
        else if (srcHandle.kind === $bd5c47de9e98f4fa$require$Constants.KIND_DIRECTORY) return $bd5c47de9e98f4fa$var$_copyFolderWithHandle(srcHandle, dst, srcFileName, callback, recursive);
        else callback(new $bd5c47de9e98f4fa$require$Errors.EIO(`Cannot copy src: ${srcFile}`));
    });
}
async function $bd5c47de9e98f4fa$var$rename(oldPath, newPath, cb) {
    $bd5c47de9e98f4fa$var$copy(oldPath, newPath, (err)=>{
        if (err) cb(err);
        else setTimeout(()=>{
            $bd5c47de9e98f4fa$var$unlink(oldPath, cb);
        }, 0);
    });
}
// this is when in windows/macos, the fs is not case-sensitive, you have to rename "a.txt" to "A.TXT".
// We have to have an intermediate name
async function $bd5c47de9e98f4fa$var$renameSameNameDiffCase(oldPath, newPath, cb) {
    const tempPath = globalObject.path.normalize(oldPath) + "_" + Math.floor(Math.random() * 4294967296);
    $bd5c47de9e98f4fa$var$rename(oldPath, tempPath, (err)=>{
        if (err) cb(err);
        else setTimeout(()=>{
            $bd5c47de9e98f4fa$var$rename(tempPath, newPath, cb);
        }, 0);
    });
}
function $bd5c47de9e98f4fa$var$mountNativeFolder(...args) {
    $bd5c47de9e98f4fa$require$Mounts.mountNativeFolder(...args);
}
function $bd5c47de9e98f4fa$var$refreshMountPoints() {
    $bd5c47de9e98f4fa$require$Mounts.refreshMountPoints();
}
const $bd5c47de9e98f4fa$var$NativeFS = {
    mountNativeFolder: $bd5c47de9e98f4fa$var$mountNativeFolder,
    refreshMountPoints: $bd5c47de9e98f4fa$var$refreshMountPoints,
    mkdir: $bd5c47de9e98f4fa$var$mkdir,
    readdir: $bd5c47de9e98f4fa$var$readdir,
    stat: $bd5c47de9e98f4fa$var$stat,
    readFile: $bd5c47de9e98f4fa$var$readFile,
    writeFile: $bd5c47de9e98f4fa$var$writeFile,
    unlink: $bd5c47de9e98f4fa$var$unlink,
    copy: $bd5c47de9e98f4fa$var$copy,
    rename: $bd5c47de9e98f4fa$var$rename,
    renameSameNameDiffCase: $bd5c47de9e98f4fa$var$renameSameNameDiffCase
};
$bd5c47de9e98f4fa$exports = {
    NativeFS: $bd5c47de9e98f4fa$var$NativeFS
};


var $e3f139c5065f0041$require$NativeFS = $bd5c47de9e98f4fa$exports.NativeFS;
var $d1f4f8cce920e9b9$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global __TAURI__, globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 
var $kznHi = parcelRequire("kznHi");
var $d1f4f8cce920e9b9$require$Buffer = $kznHi.Buffer;

var $d1f4f8cce920e9b9$require$Constants = $2ef5299e07961cfe$exports.Constants;

var $d1f4f8cce920e9b9$require$Errors = $ee841df9a5ce9c95$exports.Errors;
var $d1f4f8cce920e9b9$require$ERR_CODES = $ee841df9a5ce9c95$exports.ERR_CODES;

var $d1f4f8cce920e9b9$require$Utils = $659ab4db13967c07$exports.Utils;
var $17476582ace0b2bc$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global */ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 

var $17476582ace0b2bc$require$Errors = $ee841df9a5ce9c95$exports.Errors;

var $17476582ace0b2bc$require$Utils = $659ab4db13967c07$exports.Utils;

var $17476582ace0b2bc$require$Constants = $2ef5299e07961cfe$exports.Constants;
const $17476582ace0b2bc$var$IS_WINDOWS = navigator.userAgent.includes("Windows");
const $17476582ace0b2bc$var$WS_COMMAND = {
    PING: "ping",
    RESPONSE: "response",
    EVENT: "event",
    LARGE_DATA_SOCKET_ANNOUNCE: "largeDataSock",
    CONTROL_SOCKET_ANNOUNCE: "controlSock",
    GET_WINDOWS_DRIVES: "getWinDrives",
    READ_DIR: "readDir",
    STAT: "stat",
    READ_BIN_FILE: "readBinFile",
    WRITE_BIN_FILE: "writeBinFile",
    MKDIR: "mkdir",
    RENAME: "rename",
    COPY: "copy",
    UNLINK: "unlink",
    WATCH: "watch",
    UNWATCH: "unwatch"
};
// each browser context belongs to a single socket group. So multiple websocket connections can be pooled
// to increase throughput. Note that socketGroupID will be different for each web workers/threads in the window as
// they are separate contexts.
const $17476582ace0b2bc$var$socketGroupID = Math.floor(Math.random() * 4294967296);
let $17476582ace0b2bc$var$commandIdCounter = 1; // should be greater than 0!
let $17476582ace0b2bc$var$wssEndpoint, $17476582ace0b2bc$var$controlSocket, $17476582ace0b2bc$var$dataSocket;
const $17476582ace0b2bc$var$SOCKET_TYPE_DATA = "data", $17476582ace0b2bc$var$SOCKET_TYPE_CONTROL = "control";
const $17476582ace0b2bc$var$LARGE_DATA_THRESHOLD = 2097152; // 2MB
const $17476582ace0b2bc$var$MAX_RECONNECT_BACKOFF_TIME_MS = 1000;
function $17476582ace0b2bc$var$mapNodeTauriErrorMessage(nodeError, path, userMessage = "") {
    let error;
    switch(nodeError.code){
        case "ENOENT":
            error = new $17476582ace0b2bc$require$Errors.ENOENT(userMessage + ` No such File or Directory: ${path} ` + nodeError.message, path);
            break;
        case "EEXIST":
            error = new $17476582ace0b2bc$require$Errors.EEXIST(userMessage + ` File exists: ${path} ` + nodeError.message, path);
            break;
        case "ENOTEMPTY":
            error = new $17476582ace0b2bc$require$Errors.ENOTEMPTY(userMessage + ` Directory not empty: ${path} ` + nodeError.message, path);
            break;
        case "ENOTDIR":
            error = new $17476582ace0b2bc$require$Errors.ENOTDIR(userMessage + ` Not a Directory: ${path} ` + nodeError.message, path);
            break;
        case "EACCES":
            error = new $17476582ace0b2bc$require$Errors.EACCES(userMessage + ` Permission denied: ${path} ` + nodeError.message, path);
            break;
        case "EISDIR":
            error = new $17476582ace0b2bc$require$Errors.EISDIR(userMessage + ` Is a directory: ${path} ` + nodeError.message, path);
            break;
        case "EBADF":
            error = new $17476582ace0b2bc$require$Errors.EBADF(userMessage + ` Bad file number: ${path} ` + nodeError.message, path);
            break;
        case "EROFS":
            error = new $17476582ace0b2bc$require$Errors.EROFS(userMessage + ` Read-only file system: ${path} ` + nodeError.message, path);
            break;
        case "ENOSPC":
            error = new $17476582ace0b2bc$require$Errors.ENOSPC(userMessage + ` No space left on device: ${path} ` + nodeError.message, path);
            break;
        case "EBUSY":
            error = new $17476582ace0b2bc$require$Errors.EBUSY(userMessage + ` Device or resource busy: ${path} ` + nodeError.message, path);
            break;
        case "EINVAL":
            error = new $17476582ace0b2bc$require$Errors.EINVAL(userMessage + ` Invalid argument: ${path} ` + nodeError.message, path);
            break;
    }
    if (!error && $17476582ace0b2bc$require$Errors[nodeError.code]) error = new $17476582ace0b2bc$require$Errors[nodeError.code](userMessage + ` Error for: ${path} ` + nodeError.message, path);
    else if (!error) error = new $17476582ace0b2bc$require$Errors.EIO(userMessage + ` IO error on path: ${path} ` + nodeError.message + "\nNode Error stack: " + nodeError.nodeStack, path);
    error.nodeStack = nodeError.nodeStack;
    return error;
}
function $17476582ace0b2bc$var$_getCommand(command, data) {
    return {
        commandCode: command,
        commandId: $17476582ace0b2bc$var$commandIdCounter++,
        socketGroupID: $17476582ace0b2bc$var$socketGroupID,
        data: data
    };
}
function $17476582ace0b2bc$var$_silentlyCloseSocket(socket) {
    if (!socket) return;
    try {
        socket.autoReconnect = false;
        socket.close();
    } catch (e) {
        console.error("PhoenixFS: ", e);
    }
}
function $17476582ace0b2bc$var$_isSocketOpen(socket) {
    return socket && socket.readyState === WebSocket.OPEN;
}
let $17476582ace0b2bc$var$isNodeWsConnected = false;
/**
 * Returns true if the node websocket connection is established and ready to take requests.
 * @returns {boolean}
 */ function $17476582ace0b2bc$var$isNodeWSReady() {
    return $17476582ace0b2bc$var$isNodeWsConnected;
}
function $17476582ace0b2bc$var$updateConnectionState() {
    $17476582ace0b2bc$var$isNodeWsConnected = $17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$controlSocket) || $17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$dataSocket);
}
const $17476582ace0b2bc$var$_pendingCommandQueue = [], $17476582ace0b2bc$var$commandIdMap = {};
function $17476582ace0b2bc$var$_execCommandInternal(command, commandData, binaryData, resolve, reject) {
    let socketToUse = $17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$controlSocket) ? $17476582ace0b2bc$var$controlSocket : $17476582ace0b2bc$var$dataSocket;
    if (binaryData && binaryData.byteLength > $17476582ace0b2bc$var$LARGE_DATA_THRESHOLD && $17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$dataSocket)) socketToUse = $17476582ace0b2bc$var$dataSocket;
    const commandToSend = $17476582ace0b2bc$var$_getCommand(command, commandData);
    $17476582ace0b2bc$var$commandIdMap[commandToSend.commandId] = {
        resolve: resolve,
        reject: reject
    };
    socketToUse.send($17476582ace0b2bc$require$Utils.mergeMetadataAndArrayBuffer(commandToSend, binaryData));
}
/**
 *
 * @param command {string}
 * @param commandData {Object}
 * @param binaryData {ArrayBuffer}
 * @returns {Promise<{metadata: Object, bufferData: ArrayBuffer}>} A promise that resolves with an object containing `metadata` and `bufferData` or rejects with error.
 */ function $17476582ace0b2bc$var$_execCommand(command, commandData = null, binaryData) {
    return new Promise((resolve, reject)=>{
        if (!$17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$controlSocket) && !$17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$dataSocket)) {
            $17476582ace0b2bc$var$_pendingCommandQueue.push({
                command: command,
                commandData: commandData,
                binaryData: binaryData,
                resolve: resolve,
                reject: reject
            });
            return;
        }
        $17476582ace0b2bc$var$_execCommandInternal(command, commandData, binaryData, resolve, reject);
    });
}
function $17476582ace0b2bc$var$_execPendingCommands() {
    if (!$17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$controlSocket) && !$17476582ace0b2bc$var$_isSocketOpen($17476582ace0b2bc$var$dataSocket)) return;
    let cmd = $17476582ace0b2bc$var$_pendingCommandQueue.pop();
    while(cmd){
        $17476582ace0b2bc$var$_execCommandInternal(cmd.command, cmd.commandData, cmd.binaryData, cmd.resolve, cmd.reject);
        cmd = $17476582ace0b2bc$var$_pendingCommandQueue.pop();
    }
}
const $17476582ace0b2bc$var$_eventEmitter = {};
/**
 * you can only use this to listen to events emitter from node. Calling the emit function on the returned emitter
 * will not dispatch any events to node, but only within the browser context.
 * @param eventEmitterID - this is supplied in from node, typically from an exec metadata containing the id.
 * @returns {EventEmitter}
 * @private
 */ function $17476582ace0b2bc$var$getNodeEventListener(eventEmitterID) {
    if (!eventEmitterID) throw new $17476582ace0b2bc$require$Errors.EIO(`No such node event emitter, ${eventEmitterID}`);
    if ($17476582ace0b2bc$var$_eventEmitter[eventEmitterID]) return $17476582ace0b2bc$var$_eventEmitter[eventEmitterID];
    $17476582ace0b2bc$var$_eventEmitter[eventEmitterID] = new $7487250c9841db87$exports();
    $17476582ace0b2bc$var$_eventEmitter[eventEmitterID].eventEmitterID = eventEmitterID;
    return $17476582ace0b2bc$var$_eventEmitter[eventEmitterID];
}
function $17476582ace0b2bc$var$removeNodeEventListener(eventEmitter) {
    if (eventEmitter.allreadyClosed) return;
    eventEmitter.removeAllListeners();
    eventEmitter.on = function() {
        throw new $17476582ace0b2bc$require$Errors.EIO("The File watcher is closed. Please use `fs.watchAsync` if you want to watch again.");
    };
    eventEmitter.allreadyClosed = true;
    const eventEmitterID = eventEmitter.eventEmitterID;
    if (!eventEmitterID) throw new $17476582ace0b2bc$require$Errors.EIO(`No such node event emitter, ${eventEmitterID}`);
    if ($17476582ace0b2bc$var$_eventEmitter[eventEmitterID]) delete $17476582ace0b2bc$var$_eventEmitter[eventEmitterID];
}
function $17476582ace0b2bc$var$_processEvent(metadata, bufferData) {
    const eventEmitter = $17476582ace0b2bc$var$_eventEmitter[metadata.eventEmitterID];
    if (eventEmitter) {
        if (metadata.data.path) metadata.data.path = $17476582ace0b2bc$require$Utils.getTauriVirtualPath(metadata.data.path);
        eventEmitter.emit(metadata.eventName, metadata.data, bufferData);
    } else console.error("PhoenixFS: Received stray event: ", metadata);
}
function $17476582ace0b2bc$var$_processMessage(data) {
    const { metadata: metadata, bufferData: bufferData } = $17476582ace0b2bc$require$Utils.splitMetadataAndBuffer(data);
    if (metadata.eventEmitterID) {
        $17476582ace0b2bc$var$_processEvent(metadata, bufferData);
        return;
    }
    if (!metadata.commandId || !$17476582ace0b2bc$var$commandIdMap[metadata.commandId]) throw new Error("CommandID not found in ws response! " + metadata);
    const { resolve: resolve, reject: reject } = $17476582ace0b2bc$var$commandIdMap[metadata.commandId];
    if (metadata.error) reject(metadata.error);
    else resolve({
        metadata: metadata,
        bufferData: bufferData
    });
    delete $17476582ace0b2bc$var$commandIdMap[metadata.commandId];
}
function $17476582ace0b2bc$var$_wait(timeMS) {
    return new Promise((resolve)=>{
        setTimeout(resolve, timeMS);
    });
}
async function $17476582ace0b2bc$var$_establishAndMaintainConnection(socketType, firstConnectCB) {
    let ws = new WebSocket($17476582ace0b2bc$var$wssEndpoint);
    ws.binaryType = "arraybuffer";
    ws.autoReconnect = true;
    const resolved = false;
    while(ws.autoReconnect){
        let wsClosePromiseResolve;
        const wsClosePromise = new Promise((resolve)=>{
            wsClosePromiseResolve = resolve;
        });
        if (socketType === $17476582ace0b2bc$var$SOCKET_TYPE_CONTROL) $17476582ace0b2bc$var$controlSocket = ws;
        else {
            ws.isLargeDataWS = true;
            $17476582ace0b2bc$var$dataSocket = ws;
        }
        ws.addEventListener("open", ()=>{
            ws.backoffTime = 0;
            if (!resolved) firstConnectCB();
            if (ws.isLargeDataWS) $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.LARGE_DATA_SOCKET_ANNOUNCE).catch((err)=>console.error("PhoenixFS: ", err));
            else $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.CONTROL_SOCKET_ANNOUNCE).catch((err)=>console.error("PhoenixFS: ", err));
            $17476582ace0b2bc$var$_execPendingCommands();
            $17476582ace0b2bc$var$updateConnectionState();
        });
        ws.addEventListener("message", function(event) {
            $17476582ace0b2bc$var$_processMessage(event.data);
        });
        ws.addEventListener("error", function(event) {
            console.error("PhoenixFS websocket error event: ", event);
        });
        ws.addEventListener("close", function() {
            wsClosePromiseResolve();
            $17476582ace0b2bc$var$updateConnectionState();
        });
        await wsClosePromise;
        const backoffTime = Math.min(ws.backoffTime * 2, $17476582ace0b2bc$var$MAX_RECONNECT_BACKOFF_TIME_MS) || 1;
        ws.backoffTime = backoffTime;
        await $17476582ace0b2bc$var$_wait(backoffTime);
        if (ws.autoReconnect) {
            ws = new WebSocket($17476582ace0b2bc$var$wssEndpoint);
            ws.backoffTime = backoffTime;
            ws.binaryType = "arraybuffer";
            ws.autoReconnect = true;
        }
    }
}
/**
 * Sets the websocket endpoint and returns a promise that resolves when the tauri node fs is open. It keeps the socket
 * open across failures and auto-reconnects as needed.
 * @param websocketEndpoint
 * @return {Promise<void>}
 */ async function $17476582ace0b2bc$var$setNodeWSEndpoint(websocketEndpoint) {
    return new Promise((resolve, reject)=>{
        if (websocketEndpoint === $17476582ace0b2bc$var$wssEndpoint) reject(new $17476582ace0b2bc$require$Errors.EEXIST("A connection on the same websocket address is in progress: ", websocketEndpoint));
        $17476582ace0b2bc$var$_silentlyCloseSocket($17476582ace0b2bc$var$controlSocket);
        $17476582ace0b2bc$var$controlSocket = null;
        $17476582ace0b2bc$var$_silentlyCloseSocket($17476582ace0b2bc$var$dataSocket);
        $17476582ace0b2bc$var$dataSocket = null;
        $17476582ace0b2bc$var$wssEndpoint = websocketEndpoint;
        let resolved = false;
        function firstConnectCB() {
            if (!resolved) {
                resolve();
                resolved = true;
            }
        }
        $17476582ace0b2bc$var$_establishAndMaintainConnection($17476582ace0b2bc$var$SOCKET_TYPE_CONTROL, firstConnectCB);
        $17476582ace0b2bc$var$_establishAndMaintainConnection($17476582ace0b2bc$var$SOCKET_TYPE_DATA, firstConnectCB);
    });
}
function $17476582ace0b2bc$var$stopNodeWSEndpoint() {
    $17476582ace0b2bc$var$_silentlyCloseSocket($17476582ace0b2bc$var$controlSocket);
    $17476582ace0b2bc$var$controlSocket = null;
    $17476582ace0b2bc$var$_silentlyCloseSocket($17476582ace0b2bc$var$dataSocket);
    $17476582ace0b2bc$var$dataSocket = null;
    $17476582ace0b2bc$var$wssEndpoint = null;
}
function $17476582ace0b2bc$var$getNodeWSEndpoint() {
    return $17476582ace0b2bc$var$wssEndpoint;
}
function $17476582ace0b2bc$var$testNodeWsEndpoint(wsEndPoint, echoData, echoBuffer) {
    return new Promise((resolve, reject)=>{
        const ws = new WebSocket(wsEndPoint);
        ws.binaryType = "arraybuffer";
        let commandSent, opened = false;
        ws.addEventListener("open", ()=>{
            console.log("testNodeWsPort: Ws connected");
            opened = true;
            commandSent = $17476582ace0b2bc$var$_getCommand($17476582ace0b2bc$var$WS_COMMAND.PING, echoData);
            commandSent.socketGroupID = Math.floor(Math.random() * 4294967296); // use different for tests
            ws.send($17476582ace0b2bc$require$Utils.mergeMetadataAndArrayBuffer(commandSent, echoBuffer));
        });
        ws.addEventListener("message", function(event) {
            console.log("testNodeWsPort: received ws data", event.data);
            const { metadata: metadata, bufferData: bufferData } = $17476582ace0b2bc$require$Utils.splitMetadataAndBuffer(event.data);
            console.log("testNodeWsPort: received ws data", metadata, bufferData);
            ws.close();
            if (metadata.commandCode !== $17476582ace0b2bc$var$WS_COMMAND.RESPONSE) reject(new $17476582ace0b2bc$require$Errors.EIO(`Expected commandCode ${metadata.commandCode} to be ${$17476582ace0b2bc$var$WS_COMMAND.RESPONSE}`, wsEndPoint));
            else if (metadata.commandId !== commandSent.commandId) reject(new $17476582ace0b2bc$require$Errors.EIO(`Mismatched commandId ${metadata.commandId} to be ${commandSent.commandId}`, wsEndPoint));
            else if (metadata.socketGroupID !== commandSent.socketGroupID) reject(new $17476582ace0b2bc$require$Errors.EIO(`Mismatched socketGroupID ${metadata.socketGroupID} to be ${commandSent.socketGroupID}`, wsEndPoint));
            else resolve({
                echoData: metadata.data,
                echoBuffer: bufferData
            });
        });
        ws.addEventListener("error", function(event) {
            console.error("testNodeWsPort: ", event);
            reject(new $17476582ace0b2bc$require$Errors.EIO("Websocket error", wsEndPoint));
            ws.close();
        });
        ws.addEventListener("close", function(event) {
            console.log("PhoenixFS: WebSocket connection closed:", event.code, event.reason);
            if (!opened) reject(new $17476582ace0b2bc$require$Errors.EIO("Socket not opened: " + event.reason, wsEndPoint));
        });
    });
}
function $17476582ace0b2bc$var$_readDirWindowsDrives(path, options, callback) {
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.GET_WINDOWS_DRIVES).then(({ metadata: metadata })=>{
        const drives = metadata.data.drives;
        if (!options.withFileTypes) {
            callback(null, drives);
            return;
        }
        let entries = [];
        for (let drive of drives)entries.push($17476582ace0b2bc$require$Utils.createDummyStatObject(`${path}/${drive}`, true, $17476582ace0b2bc$require$Constants.TAURI_WS_DEVICE_NAME));
        callback(null, entries);
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to get drives: "));
    });
}
function $17476582ace0b2bc$var$readdir(path, options, callback) {
    if ($17476582ace0b2bc$var$IS_WINDOWS && path === $17476582ace0b2bc$require$Constants.TAURI_ROOT) {
        $17476582ace0b2bc$var$_readDirWindowsDrives(path, options, callback);
        return;
    }
    let platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.READ_DIR, {
        path: platformPath,
        options: options
    }).then(({ metadata: metadata })=>{
        if (metadata.data.contents) callback(null, metadata.data.contents);
        else if (metadata.data.contentStats) {
            let stats = [];
            for (let contentStat of metadata.data.contentStats)stats.push($17476582ace0b2bc$require$Utils.createFromNodeStat(`${path}/${contentStat.name}`, contentStat));
            callback(null, stats);
        } else callback(new $17476582ace0b2bc$require$Errors.EIO("Failed readdir as node ws connector returned empty", path));
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to read directory: "));
    });
}
function $17476582ace0b2bc$var$stat(path, callback) {
    let platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.STAT, {
        path: platformPath
    }).then(({ metadata: metadata })=>{
        callback(null, $17476582ace0b2bc$require$Utils.createFromNodeStat(`${path}/${metadata.data.stat.name}`, metadata.data.stat));
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to get stat: "));
    });
}
function $17476582ace0b2bc$var$readBinaryFile(path) {
    return new Promise((resolve, reject)=>{
        const platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
        $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.READ_BIN_FILE, {
            path: platformPath
        }).then(({ bufferData: bufferData })=>{
            resolve(bufferData);
        }).catch((err)=>{
            reject($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to read file: "));
        });
    });
}
function $17476582ace0b2bc$var$writeBinaryFile(path, mode, flag, dataArrayBuffer) {
    return new Promise((resolve, reject)=>{
        const platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
        $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.WRITE_BIN_FILE, {
            path: platformPath,
            mode: mode,
            flag: flag
        }, dataArrayBuffer).then(()=>{
            resolve();
        }).catch((err)=>{
            reject($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to write file: "));
        });
    });
}
function $17476582ace0b2bc$var$mkdirs(path, mode, recursive, callback) {
    const platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.MKDIR, {
        path: platformPath,
        mode: mode,
        recursive: recursive
    }).then(()=>{
        callback(null);
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to mkdir: "));
    });
}
function $17476582ace0b2bc$var$rename(oldPath, newPath, callback) {
    const oldPlatformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(oldPath);
    const newPlatformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(newPath);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.RENAME, {
        oldPath: oldPlatformPath,
        newPath: newPlatformPath
    }).then(()=>{
        callback(null);
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, oldPath, `Failed to rename: ${oldPath} to ${newPath}`));
    });
}
function $17476582ace0b2bc$var$unlink(path, callback) {
    const platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.UNLINK, {
        path: platformPath
    }).then(()=>{
        callback(null);
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, "Failed to unlink: "));
    });
}
/**
 *
 * @param {string} path
 * @param {string|Array<string>} gitIgnorePaths The contents of the gitIgnore file as text. The watcher will ignore all files matching git ignore.
 * @returns {Promise<EventEmitter>} That will be resolved with a watcher once the watcher is ready.
 */ async function $17476582ace0b2bc$var$watchAsync(path, gitIgnorePaths = "") {
    return new Promise((resolve, reject)=>{
        const platformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(path);
        $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.WATCH, {
            path: platformPath,
            gitIgnorePaths: gitIgnorePaths
        }).then(({ metadata: metadata })=>{
            const eventEmitter = $17476582ace0b2bc$var$getNodeEventListener(metadata.data.eventEmitterID);
            eventEmitter.watchPath = path;
            resolve(eventEmitter);
        }).catch((err)=>{
            reject($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, path, `Failed to watch path: ${path}`));
        });
    });
}
/**
 * Stops the fs watcher given the EventEmitter returned by watchAsync API.
 * @param eventEmitter
 * @returns {Promise<void>} That will be resolved with a watcher stops. The event emitter will no longer work after this call.
 */ function $17476582ace0b2bc$var$unwatchAsync(eventEmitter) {
    return new Promise((resolve, reject)=>{
        $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.UNWATCH, {
            eventEmitterID: eventEmitter.eventEmitterID
        }).then(()=>{
            $17476582ace0b2bc$var$removeNodeEventListener(eventEmitter);
            resolve();
        }).catch((err)=>{
            reject($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, eventEmitter.watchPath, `Failed to unwatch path: ${eventEmitter.watchPath}`));
        });
    });
}
async function $17476582ace0b2bc$var$copy(src, dst, callback) {
    const srcPlatformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(src);
    const dstPlatformPath = $17476582ace0b2bc$require$Utils.getTauriPlatformPath(dst);
    $17476582ace0b2bc$var$_execCommand($17476582ace0b2bc$var$WS_COMMAND.COPY, {
        src: srcPlatformPath,
        dst: dstPlatformPath
    }).then(({ metadata: metadata })=>{
        callback(null, $17476582ace0b2bc$require$Utils.getTauriVirtualPath(metadata.data.copiedPath));
    }).catch((err)=>{
        callback($17476582ace0b2bc$var$mapNodeTauriErrorMessage(err, src, `Failed to copy: ${src} to ${dst}`));
    });
}
const $17476582ace0b2bc$var$NodeTauriFS = {
    testNodeWsEndpoint: $17476582ace0b2bc$var$testNodeWsEndpoint,
    setNodeWSEndpoint: $17476582ace0b2bc$var$setNodeWSEndpoint,
    stopNodeWSEndpoint: $17476582ace0b2bc$var$stopNodeWSEndpoint,
    getNodeWSEndpoint: $17476582ace0b2bc$var$getNodeWSEndpoint,
    isNodeWSReady: $17476582ace0b2bc$var$isNodeWSReady,
    readdir: $17476582ace0b2bc$var$readdir,
    mkdirs: $17476582ace0b2bc$var$mkdirs,
    stat: $17476582ace0b2bc$var$stat,
    readBinaryFile: $17476582ace0b2bc$var$readBinaryFile,
    writeBinaryFile: $17476582ace0b2bc$var$writeBinaryFile,
    rename: $17476582ace0b2bc$var$rename,
    unlink: $17476582ace0b2bc$var$unlink,
    watchAsync: $17476582ace0b2bc$var$watchAsync,
    unwatchAsync: $17476582ace0b2bc$var$unwatchAsync,
    copy: $17476582ace0b2bc$var$copy
};
$17476582ace0b2bc$exports = {
    NodeTauriFS: $17476582ace0b2bc$var$NodeTauriFS
};


var $d1f4f8cce920e9b9$require$NodeTauriFS = $17476582ace0b2bc$exports.NodeTauriFS;
const $d1f4f8cce920e9b9$var$IS_WINDOWS = navigator.userAgent.includes("Windows");
let $d1f4f8cce920e9b9$var$preferNodeWs = false, $d1f4f8cce920e9b9$var$forceNodeWs = false;
/**
 * Opens the Tauri file picker asynchronously with given options. If options aren't provided, defaults to picking a single file.
 * If the `defaultPath` option isn't provided, it will default to the user's document directory.
 *
 * @param {Object} [options] - Configuration options for the Tauri file picker.
 * @param {boolean} [options.directory=false] - Whether it is directory or file to be picked.
 * @param {boolean} [options.multiple=false] - Whether to allow picking multiple files.
 * @param {string} [options.defaultPath] - Default directory to open in the file picker. Defaults to document directory if not provided.
 * @param {string} [options.title] - The title of the dialog window.
 * @param {Array<{name: string, extensions: string[]}>} [options.filters] - Extension filters for the file dialog.
 *   filters: [{
 *     name: 'Image',
 *     extensions: ['png', 'jpeg']
 *   }]
 *
 * @returns {Promise<null|string|Array<string>>} A promise that resolves to null if user dismissed the dialogue, a string (selected filepath), or an array of strings (multiple selected filepaths).
 */ async function $d1f4f8cce920e9b9$var$openTauriFilePickerAsync(options) {
    options = options || {
        multiple: false
    };
    if (!options.defaultPath) options.defaultPath = await __TAURI__.path.documentDir();
    return new Promise((resolve, reject)=>{
        __TAURI__.dialog.open(options).then((filePaths)=>{
            if (typeof filePaths === "string") resolve($d1f4f8cce920e9b9$require$Utils.getTauriVirtualPath(filePaths));
            else if (Array.isArray(filePaths)) {
                let virtualPaths = [];
                for (let platformPath of filePaths)virtualPaths.push($d1f4f8cce920e9b9$require$Utils.getTauriVirtualPath(platformPath));
                resolve(virtualPaths);
            } else resolve(null);
        }).catch(reject);
    });
}
/**
 * Opens the Tauri file save dialogue asynchronously using the provided options.
 * If `defaultPath` option isn't provided, it defaults to the user's document directory.
 *
 * @async
 * @param {Object} [options] - Configuration options for the Tauri file save dialogue.
 * @param {string} [options.defaultPath] - Initial directory or file path. If it's a directory path, the dialog interface will change to that folder. If it's not an existing directory, the file name will be set to the dialog's file name input and the dialog will be set to the parent folder. If not provided, defaults to the user's document directory.
 * @param {string} [options.title] - The title of the dialog window.
 * @param {Array<{name: string, extensions: string[]}>} [options.filters] - Extension filters for the file dialog.
 *   filters: [{
 *     name: 'Image',
 *     extensions: ['png', 'jpeg']
 *   }]
 *
 * @returns {Promise<string|null>} A promise that resolves to the selected file path if a location was chosen, or null if the dialogue was cancelled.
 *
 * @example
 * openTauriFileSaveDialogueAsync({
 *     defaultPath: '/path/to/example.txt',
 *     filters: [{ name: 'Text Files', extensions: ['txt'] }]
 * }).then(savePath => {
 *     if (savePath) {
 *         console.log("File will be saved at:", savePath);
 *     } else {
 *         console.log("Save dialogue was cancelled");
 *     }
 * });
 */ async function $d1f4f8cce920e9b9$var$openTauriFileSaveDialogueAsync(options) {
    options = options || {};
    if (!options.defaultPath) options.defaultPath = await __TAURI__.path.documentDir();
    return new Promise((resolve, reject)=>{
        __TAURI__.dialog.save(options).then((filePath)=>{
            if (typeof filePath === "string") resolve($d1f4f8cce920e9b9$require$Utils.getTauriVirtualPath(filePath));
            else resolve(null);
        }).catch(reject);
    });
}
function $d1f4f8cce920e9b9$var$extractErrorNumber(str) {
    const regex = /\(os error (\d+)\)/;
    const match = str.match(regex);
    if (match && match[1]) return match[1];
    else return null;
}
function $d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(tauriErrorMessage, path, userMessage = "") {
    let errorNumber = $d1f4f8cce920e9b9$var$extractErrorNumber(tauriErrorMessage);
    switch(errorNumber){
        case "2":
            return new $d1f4f8cce920e9b9$require$Errors.ENOENT(userMessage + ` No such File or Directory: ${path} ` + tauriErrorMessage, path);
        case "3":
            return new $d1f4f8cce920e9b9$require$Errors.ENOENT(userMessage + ` System cannot find the path specified: ${path} ` + tauriErrorMessage, path); // windows
        case "17":
            return new $d1f4f8cce920e9b9$require$Errors.EEXIST(userMessage + ` File exists: ${path} ` + tauriErrorMessage, path);
        case "183":
            return new $d1f4f8cce920e9b9$require$Errors.EEXIST(userMessage + ` File exists: ${path} ` + tauriErrorMessage, path); // windows
        case "39":
            return new $d1f4f8cce920e9b9$require$Errors.ENOTEMPTY(userMessage + ` Directory not empty: ${path} ` + tauriErrorMessage, path);
        case "20":
            return new $d1f4f8cce920e9b9$require$Errors.ENOTDIR(userMessage + ` Not a Directory: ${path} ` + tauriErrorMessage, path);
        case "13":
            return new $d1f4f8cce920e9b9$require$Errors.EACCES(userMessage + ` Permission denied: ${path} ` + tauriErrorMessage, path);
        case "21":
            return new $d1f4f8cce920e9b9$require$Errors.EISDIR(userMessage + ` Is a directory: ${path} ` + tauriErrorMessage, path);
        case "9":
            return new $d1f4f8cce920e9b9$require$Errors.EBADF(userMessage + ` Bad file number: ${path} ` + tauriErrorMessage, path);
        case "30":
            return new $d1f4f8cce920e9b9$require$Errors.EROFS(userMessage + ` Read-only file system: ${path} ` + tauriErrorMessage, path);
        case "28":
            return new $d1f4f8cce920e9b9$require$Errors.ENOSPC(userMessage + ` No space left on device: ${path} ` + tauriErrorMessage, path);
        case "16":
            return new $d1f4f8cce920e9b9$require$Errors.EBUSY(userMessage + ` Device or resource busy: ${path} ` + tauriErrorMessage, path);
        case "22":
            return new $d1f4f8cce920e9b9$require$Errors.EINVAL(userMessage + ` Invalid argument: ${path} ` + tauriErrorMessage, path);
        default:
            return new $d1f4f8cce920e9b9$require$Errors.EIO(userMessage + ` IO error on path: ${path} ` + tauriErrorMessage, path);
    }
}
async function $d1f4f8cce920e9b9$var$_getTauriStat(vfsPath) {
    let stats = await globalObject.__TAURI__.invoke("plugin:fs-extra|metadata", {
        path: globalObject.fs.getTauriPlatformPath(vfsPath)
    });
    return $d1f4f8cce920e9b9$require$Utils.createFromTauriStat(vfsPath, stats);
}
function $d1f4f8cce920e9b9$var$_readDirHelper(entries, path, options, callback, useDummyStats) {
    let children = [];
    for (const entry of entries){
        if (!options.withFileTypes) children.push(entry.name);
        else if (useDummyStats) children.push($d1f4f8cce920e9b9$require$Utils.createDummyStatObject(`${path}/${entry.name}`, true, $d1f4f8cce920e9b9$require$Constants.TAURI_DEVICE_NAME));
        else children.push($d1f4f8cce920e9b9$var$_getTauriStat(`${path}/${entry.name}`));
    }
    if (!options.withFileTypes || useDummyStats) callback(null, children);
    else Promise.all(children).then((results)=>{
        callback(null, results);
    }).catch((err)=>{
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to read directory: "));
    });
}
/**
 * Reads the contents of a directory. This method will list all the entries of a directory
 * as an array of strings(filenames , directory names, or symbolic link names).
 * If the `withFileTypes` option is set to `true`, it will return file stat objects array instead of strings.
 *
 * @param {string} path - The path to the directory that needs to be read.
 * @param {Object} [options] - Options for reading the directory.
 * @param {boolean} [options.withFileTypes=false] - Set to `true` to return stats of each content file/dir. Defaults to `false`.
 * @param {function} callback - A callback function to execute once the directory is read.
 *                              This function gets two arguments: (err, entries).
 *                              `err` will be set if an error occurred during reading. `entries` is an array of file names or fs stat objects.
 *
 * @example
 * // Using withFileTypes option
 * fs.readdir("/tauri/some/path", { withFileTypes: true }, function(err, entries) {
 *   if (err) throw err;
 *   console.log(entries); // Outputs file stats
 * });
 *
 * @example
 * // Without specifying withFileTypes option
 * fs.readdir("/tauri/some/path", function(err, entries) {
 *   if (err) throw err;
 *   console.log(entries); // Outputs an array of file/dir names
 * });
 *
 * @returns {void}
 */ function $d1f4f8cce920e9b9$var$readdir(path, options, callback) {
    path = globalObject.path.normalize(path);
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) return $d1f4f8cce920e9b9$require$NodeTauriFS.readdir(path, options, callback);
    if ($d1f4f8cce920e9b9$var$IS_WINDOWS && path === $d1f4f8cce920e9b9$require$Constants.TAURI_ROOT) {
        window.__TAURI__.invoke("_get_windows_drives").then((drives)=>{
            let entries = [];
            for (let drive of drives)entries.push({
                name: drive
            });
            $d1f4f8cce920e9b9$var$_readDirHelper(entries, path, options, callback, true);
        }).catch((err)=>{
            callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to get drives: "));
        });
        return;
    }
    let platformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(path);
    __TAURI__.fs.readDir(platformPath).then((entries)=>{
        $d1f4f8cce920e9b9$var$_readDirHelper(entries, path, options, callback);
    }).catch((err)=>{
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to read directory: "));
    });
}
/**
 * Creates a directory with optional mode and recursion(create all intermediate directories if those don't exist).
 *
 * @param {string} path - The path where the directory should be created.
 * @param {(number)} [mode=0o777] - The directory permissions. Defaults to `0o777` if not provided.
 * @param {(boolean)} [recursive=false] - Whether to create directories recursively. Defaults to `false` if not provided.
 * @param {function} [callback] - Callback to execute once directory creation is done. Called with an error as the first argument on failure, and null on success.
 *
 * @example
 * // Create directory without recursion and with default mode, and a callback.
 * fs.mkdirs("/tauri/some/path", callback);
 *
 * // Create directory with specified mode, without recursion, and a callback.
 * fs.mkdirs("/tauri/some/path", 0o755, callback);
 *
 * // Create directory with specified mode, with recursion, and a callback.
 * fs.mkdirs("/tauri/some/path", 0o755, true, callback);
 *
 * // Create directory without recursion, without mode, and without a callback.
 * fs.mkdirs("/tauri/some/path");
 *
 * @returns {void}
 */ function $d1f4f8cce920e9b9$var$mkdirs(path, mode, recursive, callback) {
    // Determine if 'mode' is provided
    if (typeof mode !== "number") {
        callback = recursive;
        recursive = mode;
        mode = 511; // Default mode (or any other default you'd like to set)
    }
    // Determine if 'recursive' is provided
    if (typeof recursive !== "boolean") {
        callback = recursive;
        recursive = false;
    }
    // Determine if 'callback' is provided
    if (typeof callback !== "function") callback = function() {
    // Do Nothing
    };
    if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) {
        $d1f4f8cce920e9b9$require$NodeTauriFS.mkdirs(path, mode, recursive, callback);
        return;
    }
    let platformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(path);
    __TAURI__.fs.createDir(platformPath, {
        recursive: recursive
    }).then(()=>{
        callback(null);
    }).catch((err)=>{
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to create directory: "));
    });
}
/**
 * Retrieves the status of a file or directory. The result will be an object with detailed information.
 * The provided callback function will be called with either an error (as the first argument) or the stat object (as the second argument).
 *
 * @param {string} path - The path to the file or directory to retrieve the status for.
 * @param {function} callback - The callback function that is executed when the operation is complete.
 *                              The callback function will receive two arguments:
 *                              1. An error object if an error occurred, otherwise null.
 *                              2. The stat object containing the details about the file or directory.
 *
 * The stat object has the following properties:
 * - 'name' : The base name of the file or directory.
 * - 'isFile()', 'isDirectory()' and 'isSymbolicLink()'- functions that does what its name suggests.
 * - 'type': Indicates the type of the node, which can be a string indicating directory, file, or symbolic link.
 *           Prefer above `isFile()` type check over this.
 * - `size`: The size of the file in bytes.
 * - `mode`: The file's mode. It's an integer that represents the file's permission mode.
 * - `readonly`: A boolean indicating if the file is read-only.
 * - `ctime`: The time the file was created, in milliseconds since the POSIX Epoch.
 * - `atime`: The time the file was last accessed, in milliseconds since the POSIX Epoch.
 * - `mtime`: The time the file was last modified, in milliseconds since the POSIX Epoch.
 * - `nlinks`: The number of hard links.
 *
 * @example
 * fs.stat("/tauri/some/path", function(err, statObj) {
 *   if (err) throw err;
 *   console.log(statObj);
 * });
 *
 * @returns {void}
 */ function $d1f4f8cce920e9b9$var$stat(path, callback, options = {}) {
    path = globalObject.path.normalize(path);
    if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) return $d1f4f8cce920e9b9$require$NodeTauriFS.stat(path, callback, options);
    $d1f4f8cce920e9b9$var$_getTauriStat(path).then((stat)=>{
        callback(null, stat);
    }).catch((err)=>{
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to get stat"));
    });
}
function $d1f4f8cce920e9b9$var$unlink(path, callback) {
    path = globalObject.path.normalize(path);
    if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) return $d1f4f8cce920e9b9$require$NodeTauriFS.unlink(path, callback);
    function errCallback(err) {
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, "Failed to unlink"));
    }
    $d1f4f8cce920e9b9$var$_getTauriStat(path).then((stat)=>{
        let platformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(path);
        if (stat.isDirectory()) __TAURI__.fs.removeDir(platformPath, {
            recursive: true
        }).then(()=>{
            callback(null);
        }).catch(errCallback);
        else __TAURI__.fs.removeFile(platformPath).then(()=>{
            callback(null);
        }).catch(errCallback);
    }).catch(errCallback);
}
function $d1f4f8cce920e9b9$var$rename(oldPath, newPath, callback) {
    oldPath = globalObject.path.normalize(oldPath);
    newPath = globalObject.path.normalize(newPath);
    if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) {
        $d1f4f8cce920e9b9$require$NodeTauriFS.rename(oldPath, newPath, callback);
        return;
    }
    const oldPlatformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(oldPath);
    const newPlatformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(newPath);
    __TAURI__.invoke("_rename_path", {
        oldPath: oldPlatformPath,
        newPath: newPlatformPath
    }).then(()=>{
        callback(null);
    }).catch((err)=>{
        callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, oldPath, `Failed to rename ${oldPath} to ${newPath}`));
    });
}
/**
 *
 * @param contents {ArrayBuffer}
 * @param encoding {string}
 * @param callback {function}
 * @param path {string}
 * @private
 */ function $d1f4f8cce920e9b9$var$_processContents(contents, encoding, callback, path) {
    try {
        let arrayBuffer = contents;
        if (contents.buffer instanceof ArrayBuffer) arrayBuffer = contents.buffer;
        if (encoding === $d1f4f8cce920e9b9$require$Constants.BYTE_ARRAY_ENCODING) {
            callback(null, arrayBuffer, encoding);
            return;
        } else if (encoding === $d1f4f8cce920e9b9$require$Constants.BINARY_ENCODING) {
            const contentBuffer = $d1f4f8cce920e9b9$require$Buffer.from(arrayBuffer);
            callback(null, contentBuffer, encoding);
            return;
        }
        let decodedString = $d1f4f8cce920e9b9$require$Utils.getDecodedString(arrayBuffer, encoding);
        callback(null, decodedString, encoding);
    } catch (e) {
        if ($d1f4f8cce920e9b9$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $d1f4f8cce920e9b9$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
/**
 * Reads the contents of a file.
 *
 * @param {string} path - The path of the file to read.
 * @param {Object|string} [options] - An object with encoding and flag options or a string representing the encoding.
 *   - If a string is provided, it specifies the encoding. Default is `'binary'` which returns a `'Buffer'`. To return a
 *     `UTF8` string use `utf8`. Get list of all supported encodings from `'fs.SUPPORTED_ENCODINGS'`.
 *      If reading binary files from within `/tauri/` or fsAccess(`/mnt/`) paths, then instead of `'binary'` encoding,
 *      prefer `'fs.BYTE_ARRAY_ENCODING'` for improved binary read performance. This will instead return an `ArrayBuffer`
 *      that is native to the browser environment instead of the 'Buffer' polyfill that we use.
 *   - If an object is provided, it can have the following properties:
 *     - `encoding` (string): The encoding type. Default is `'binary'`. Get list of supported encodings from `'fs.SUPPORTED_ENCODINGS'`.
 *     - `flag` (string): The file system flag. Default is `'r'`.
 * @param {function} callback - The callback function to execute when the file read operation is complete.
 *   - The callback is passed two arguments:
 *     1. An error object or null if no error occurred.
 *     2. The data read from the file (type depends on the encoding option).
 *
 * @example
 * fs.readFile("/path/to/file", { encoding: 'utf8' }, function(err, data) {
 *   if (err) throw err;
 *   console.log(data);
 * });
 * // OR
 * fs.readFile("/path/to/file", 'utf8', function(err, data) {
 *   if (err) throw err;
 *   console.log(data);
 * });
 *
 * @returns {void}
 */ function $d1f4f8cce920e9b9$var$readFile(path, options, callback) {
    try {
        path = globalObject.path.normalize(path);
        callback = arguments[arguments.length - 1];
        options = $d1f4f8cce920e9b9$require$Utils.validateFileOptions(options, $d1f4f8cce920e9b9$require$Constants.BINARY_ENCODING, "r");
        if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) {
            $d1f4f8cce920e9b9$require$NodeTauriFS.readBinaryFile(path).then((contents)=>{
                // contents is Array buffer, can be undefined if empty file
                contents = contents || new ArrayBuffer(0);
                $d1f4f8cce920e9b9$var$_processContents(contents, options.encoding, callback, path);
            }).catch(callback);
            return;
        }
        const platformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(path);
        __TAURI__.fs.readBinaryFile(platformPath).then((contents)=>{
            // contents is Array buffer, can be undefined if empty file
            contents = contents || new ArrayBuffer(0);
            $d1f4f8cce920e9b9$var$_processContents(contents, options.encoding, callback, path);
        }).catch((err)=>{
            callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, `Failed to read File at path ${path}`));
        });
    } catch (e) {
        if ($d1f4f8cce920e9b9$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $d1f4f8cce920e9b9$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
/**
 * Writes data to a file, replacing the file if it already exists.
 *
 * @param {string} path - The path of the file where data should be written.
 * @param {ArrayBuffer|Buffer|string|number} data - The data to write. This can be an ArrayBuffer, Buffer, string, or number.
 * @param {Object|string} [options] - An object with encoding and flag options or a string representing the encoding.
 *   - If a string is provided, it specifies the encoding. Default is `'binary'` which writes the buffer as is.
 *      Get list of all supported encodings from `'fs.SUPPORTED_ENCODINGS'`.
 *      If writing binary files from within `/tauri/` or fsAccess(`/mnt/`) paths, then instead of `'binary'` encoding,
 *      prefer `'fs.BYTE_ARRAY_ENCODING'` and `ArrayBuffer` data.
 *   - If provided as an `object`, it can have the following keys:
 *     - `encoding` (string): The type of encoding. Default is `'binary'`.
 *     - `flag` (string): The file system flag. Default is `'w'`.
 *     - `mode`- The permissions. Defaults to `0o666` if not provided.
 * @param {function} callback - The callback function to execute once the file write operation concludes.
 *   - The callback receives one argument:
 *     1. An error object (or null if there were no errors).
 *
 * @example
 * fs.writeFile("/path/to/file", "Hello World", { encoding: 'utf8' }, function(err) {
 *   if (err) throw err;
 *   console.log("File written successfully!");
 * });
 * // or
 * fs.writeFile("/path/to/file", "Hello World", 'utf8', function(err) {
 *   if (err) throw err;
 *   console.log("File written successfully!");
 * });
 * @returns {void}
 */ function $d1f4f8cce920e9b9$var$writeFile(path, data, options, callback) {
    try {
        path = globalObject.path.normalize(path);
        callback = arguments[arguments.length - 1];
        options = $d1f4f8cce920e9b9$require$Utils.validateFileOptions(options, $d1f4f8cce920e9b9$require$Constants.BINARY_ENCODING, "w");
        let arrayBuffer;
        if (data instanceof ArrayBuffer) arrayBuffer = data;
        else if ($d1f4f8cce920e9b9$require$Buffer.isBuffer(data)) arrayBuffer = $d1f4f8cce920e9b9$require$Utils.toArrayBuffer(data);
        else {
            if (typeof data === "number") data = "" + data;
            data = data || ""; // this should be after number check as if data = 0, things break
            if (typeof data !== "string") data = data.toString();
            arrayBuffer = $d1f4f8cce920e9b9$require$Utils.getEncodedArrayBuffer(data, options.encoding);
        }
        if (!globalObject.__TAURI__ || $d1f4f8cce920e9b9$var$forceNodeWs || $d1f4f8cce920e9b9$var$preferNodeWs && $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady()) {
            $d1f4f8cce920e9b9$require$NodeTauriFS.writeBinaryFile(path, options.mode || 438, options.flag, arrayBuffer).then(()=>{
                callback(null);
            }).catch(callback);
            return;
        }
        const platformPath = $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath(path);
        __TAURI__.fs.writeBinaryFile(platformPath, arrayBuffer).then(()=>{
            callback(null);
        }).catch((err)=>{
            callback($d1f4f8cce920e9b9$var$mapOSTauriErrorMessage(err, path, `Failed to write File at path ${path}`));
        });
    } catch (e) {
        if ($d1f4f8cce920e9b9$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $d1f4f8cce920e9b9$require$Errors.EIO(`IO error while processing data write from file on path: ${path}`, path));
    }
}
/**
 * Forces the usage of the Node WebSocket endpoint.
 * Throws an error if the Node WebSocket endpoint is not set.
 *
 * @param {boolean} use - If `true`, forces the use of the Node WebSocket endpoint.
 * @throws {Error} Throws an error if the Node WebSocket endpoint has not been set.
 */ function $d1f4f8cce920e9b9$var$forceUseNodeWSEndpoint(use) {
    if (!$d1f4f8cce920e9b9$require$NodeTauriFS.getNodeWSEndpoint()) throw new Error("Please call fs.setNodeWSEndpoint('ws://your server') before calling this function.");
    $d1f4f8cce920e9b9$var$forceNodeWs = use;
}
/**
 * Sets the preference to use the Node WebSocket endpoint if available.
 * Throws an error if the Node WebSocket endpoint is not set.
 * If a Node connection is not available, it falls back to Tauri.
 * To always force the library to use the Node WebSocket endpoint for all FS APIs, use `forceUseNodeWSEndpoint`.
 *
 * @param {boolean} use - If `true`, prefers the use of the Node WebSocket endpoint.
 * @throws {Error} Throws an error if the Node WebSocket endpoint has not been set.
 */ function $d1f4f8cce920e9b9$var$preferNodeWSEndpoint(use) {
    if (!$d1f4f8cce920e9b9$require$NodeTauriFS.getNodeWSEndpoint()) throw new Error("Please call fs.setNodeWSEndpoint('ws://your server') before calling this function.");
    $d1f4f8cce920e9b9$var$preferNodeWs = use;
}
function $d1f4f8cce920e9b9$var$canCopy() {
    // we can only copy if node tari fs is ready as tauri doesn't have folder copy apis.
    return $d1f4f8cce920e9b9$require$NodeTauriFS.isNodeWSReady();
}
async function $d1f4f8cce920e9b9$var$copy(src, dst, callback) {
    if (!$d1f4f8cce920e9b9$var$canCopy()) {
        callback(new $d1f4f8cce920e9b9$require$Errors.EIO(`IO error while copying: ${src} to ${dst}, node not ready.`, src));
        return;
    }
    src = globalObject.path.normalize(src);
    dst = globalObject.path.normalize(dst);
    return $d1f4f8cce920e9b9$require$NodeTauriFS.copy(src, dst, callback);
}
const $d1f4f8cce920e9b9$var$TauriFS = {
    isTauriPath: $d1f4f8cce920e9b9$require$Utils.isTauriPath,
    isTauriSubPath: $d1f4f8cce920e9b9$require$Utils.isTauriSubPath,
    getTauriPlatformPath: $d1f4f8cce920e9b9$require$Utils.getTauriPlatformPath,
    getTauriVirtualPath: $d1f4f8cce920e9b9$require$Utils.getTauriVirtualPath,
    openTauriFilePickerAsync: $d1f4f8cce920e9b9$var$openTauriFilePickerAsync,
    openTauriFileSaveDialogueAsync: $d1f4f8cce920e9b9$var$openTauriFileSaveDialogueAsync,
    forceUseNodeWSEndpoint: $d1f4f8cce920e9b9$var$forceUseNodeWSEndpoint,
    preferNodeWSEndpoint: $d1f4f8cce920e9b9$var$preferNodeWSEndpoint,
    stat: $d1f4f8cce920e9b9$var$stat,
    readdir: $d1f4f8cce920e9b9$var$readdir,
    mkdirs: $d1f4f8cce920e9b9$var$mkdirs,
    rename: $d1f4f8cce920e9b9$var$rename,
    unlink: $d1f4f8cce920e9b9$var$unlink,
    readFile: $d1f4f8cce920e9b9$var$readFile,
    writeFile: $d1f4f8cce920e9b9$var$writeFile,
    copy: $d1f4f8cce920e9b9$var$copy,
    canCopy: $d1f4f8cce920e9b9$var$canCopy
};
$d1f4f8cce920e9b9$exports = {
    TauriFS: $d1f4f8cce920e9b9$var$TauriFS
};


var $e3f139c5065f0041$require$TauriFS = $d1f4f8cce920e9b9$exports.TauriFS;

var $e3f139c5065f0041$require$NodeTauriFS = $17476582ace0b2bc$exports.NodeTauriFS;
var $50518f37971e1950$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 
var $kznHi = parcelRequire("kznHi");
var $50518f37971e1950$require$Buffer = $kznHi.Buffer;

var $50518f37971e1950$require$Constants = $2ef5299e07961cfe$exports.Constants;

var $50518f37971e1950$require$Errors = $ee841df9a5ce9c95$exports.Errors;
var $50518f37971e1950$require$ERR_CODES = $ee841df9a5ce9c95$exports.ERR_CODES;

var $50518f37971e1950$require$Utils = $659ab4db13967c07$exports.Utils;
let $50518f37971e1950$var$filerLib = null;
/**
 *
 * @param contentsBuffer {Buffer}
 * @param encoding {string}
 * @param callback {function}
 * @param path {string}
 * @private
 */ function $50518f37971e1950$var$_processContents(contentsBuffer, encoding, callback, path) {
    try {
        if (encoding === $50518f37971e1950$require$Constants.BYTE_ARRAY_ENCODING) {
            let arrayBuffer = contentsBuffer.buffer.slice(contentsBuffer.byteOffset, contentsBuffer.byteOffset + contentsBuffer.byteLength);
            callback(null, arrayBuffer, encoding);
            return;
        } else if (encoding === $50518f37971e1950$require$Constants.BINARY_ENCODING) {
            callback(null, contentsBuffer, encoding);
            return;
        }
        let decodedString = $50518f37971e1950$require$Utils.getDecodedStringFromBuffer(contentsBuffer, encoding);
        callback(null, decodedString, encoding);
    } catch (e) {
        if ($50518f37971e1950$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $50518f37971e1950$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
function $50518f37971e1950$var$readFile(path, options, callback) {
    try {
        if (typeof path !== "string") return callback(new $50518f37971e1950$require$Errors.EINVAL(`Error Invalid path for readFile: ${path}`));
        path = globalObject.path.normalize(path);
        callback = arguments[arguments.length - 1];
        options = $50518f37971e1950$require$Utils.validateFileOptions(options, $50518f37971e1950$require$Constants.BINARY_ENCODING, "r");
        const originalEncoding = options.encoding;
        // always read as binary
        options.encoding = $50518f37971e1950$require$Constants.BINARY_ENCODING;
        $50518f37971e1950$var$filerLib.fs.readFile(path, options, (err, contents)=>{
            if (err) {
                callback(err);
                return;
            }
            $50518f37971e1950$var$_processContents(contents, originalEncoding, callback, path);
        });
    } catch (e) {
        if ($50518f37971e1950$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $50518f37971e1950$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
function $50518f37971e1950$var$writeFile(path, data, options, callback) {
    try {
        callback = arguments[arguments.length - 1];
        options = $50518f37971e1950$require$Utils.validateFileOptions(options, $50518f37971e1950$require$Constants.BINARY_ENCODING, "w");
        if (typeof path !== "string") return callback(new $50518f37971e1950$require$Errors.EINVAL(`Error Invalid path for writeFile: ${path}`));
        let bufferData;
        if (data instanceof ArrayBuffer) bufferData = $50518f37971e1950$require$Buffer.from(data);
        else if ($50518f37971e1950$require$Buffer.isBuffer(data)) bufferData = data;
        else {
            if (typeof data === "number") data = "" + data;
            data = data || ""; // this should be after number check as if data = 0, things break
            if (typeof data !== "string") data = data.toString();
            bufferData = $50518f37971e1950$require$Utils.getEncodedBuffer(data, options.encoding);
        }
        path = globalObject.path.normalize(path);
        // always write as binary
        options.encoding = $50518f37971e1950$require$Constants.BINARY_ENCODING;
        $50518f37971e1950$var$filerLib.fs.writeFile(path, bufferData, options, (err)=>{
            if (err) callback(err);
            else callback(null);
        });
    } catch (e) {
        if ($50518f37971e1950$require$ERR_CODES.ERROR_CODES[e.code]) callback(e);
        else callback(new $50518f37971e1950$require$Errors.EIO(`IO error while processing data read from file on path: ${path}`, path));
    }
}
function $50518f37971e1950$var$initFilerLib(FilerLib) {
    $50518f37971e1950$var$filerLib = FilerLib;
}
const $50518f37971e1950$var$FilerFSModified = {
    initFilerLib: $50518f37971e1950$var$initFilerLib,
    readFile: $50518f37971e1950$var$readFile,
    writeFile: $50518f37971e1950$var$writeFile
};
$50518f37971e1950$exports = {
    FilerFSModified: $50518f37971e1950$var$FilerFSModified
};


var $e3f139c5065f0041$require$FilerFSModified = $50518f37971e1950$exports.FilerFSModified;

var $e3f139c5065f0041$require$Constants = $2ef5299e07961cfe$exports.Constants;

var $e3f139c5065f0041$require$Mounts = $d71a2f6bd42cb0cc$exports.Mounts;
var $1a1f52eca6bba4a3$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global globalObject, virtualfs*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ let $1a1f52eca6bba4a3$var$_channel = null;
const $1a1f52eca6bba4a3$var$_eventEmitters = [];

var $1a1f52eca6bba4a3$require$Errors = $ee841df9a5ce9c95$exports.Errors;

var $a3d6107d2fcf3806$exports = {};
// A simple implementation of make-array

var $FkHbz = parcelRequire("FkHbz");
function $a3d6107d2fcf3806$var$makeArray(subject) {
    return Array.isArray(subject) ? subject : [
        subject
    ];
}
const $a3d6107d2fcf3806$var$EMPTY = "";
const $a3d6107d2fcf3806$var$SPACE = " ";
const $a3d6107d2fcf3806$var$ESCAPE = "\\";
const $a3d6107d2fcf3806$var$REGEX_TEST_BLANK_LINE = /^\s+$/;
const $a3d6107d2fcf3806$var$REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
const $a3d6107d2fcf3806$var$REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const $a3d6107d2fcf3806$var$REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
const $a3d6107d2fcf3806$var$REGEX_SPLITALL_CRLF = /\r?\n/g;
// /foo,
// ./foo,
// ../foo,
// .
// ..
const $a3d6107d2fcf3806$var$REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
const $a3d6107d2fcf3806$var$SLASH = "/";
// Do not use ternary expression here, since "istanbul ignore next" is buggy
let $a3d6107d2fcf3806$var$TMP_KEY_IGNORE = "node-ignore";
/* istanbul ignore else */ if (typeof Symbol !== "undefined") $a3d6107d2fcf3806$var$TMP_KEY_IGNORE = Symbol.for("node-ignore");
const $a3d6107d2fcf3806$var$KEY_IGNORE = $a3d6107d2fcf3806$var$TMP_KEY_IGNORE;
const $a3d6107d2fcf3806$var$define = (object, key, value)=>Object.defineProperty(object, key, {
        value: value
    });
const $a3d6107d2fcf3806$var$REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
const $a3d6107d2fcf3806$var$RETURN_FALSE = ()=>false;
// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const $a3d6107d2fcf3806$var$sanitizeRange = (range)=>range.replace($a3d6107d2fcf3806$var$REGEX_REGEXP_RANGE, (match, from, to)=>from.charCodeAt(0) <= to.charCodeAt(0) ? match : $a3d6107d2fcf3806$var$EMPTY);
// See fixtures #59
const $a3d6107d2fcf3806$var$cleanRangeBackSlash = (slashes)=>{
    const { length: length } = slashes;
    return slashes.slice(0, length - length % 2);
};
// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'
const $a3d6107d2fcf3806$var$REPLACERS = [
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match)=>match.indexOf("\\") === 0 ? $a3d6107d2fcf3806$var$SPACE : $a3d6107d2fcf3806$var$EMPTY
    ],
    // replace (\ ) with ' '
    [
        /\\\s/g,
        ()=>$a3d6107d2fcf3806$var$SPACE
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
        /[\\$.|*+(){^]/g,
        (match)=>`\\${match}`
    ],
    [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        ()=>"[^/]"
    ],
    // leading slash
    [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        ()=>"^"
    ],
    // replace special metacharacter slash after the leading slash
    [
        /\//g,
        ()=>"\\/"
    ],
    [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        ()=>"^(?:.*\\/)?"
    ],
    // starting
    [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
    ],
    // two globstars
    [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str)=>index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2)=>{
            // 1.
            // > An asterisk "*" matches anything except a slash.
            // 2.
            // > Other consecutive asterisks are considered regular asterisks
            // > and will match according to the previous rules.
            const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
            return p1 + unescaped;
        }
    ],
    [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        ()=>$a3d6107d2fcf3806$var$ESCAPE
    ],
    [
        // '\\\\' -> '\\'
        /\\\\/g,
        ()=>$a3d6107d2fcf3806$var$ESCAPE
    ],
    [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close)=>leadEscape === $a3d6107d2fcf3806$var$ESCAPE ? `\\[${range}${$a3d6107d2fcf3806$var$cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${$a3d6107d2fcf3806$var$sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    // ending
    [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match)=>/\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
        /(\^|\\\/)?\\\*$/,
        (_, p1)=>{
            const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
            return `${prefix}(?=$|\\/$)`;
        }
    ]
];
// A simple cache, because an ignore rule only has only one certain meaning
const $a3d6107d2fcf3806$var$regexCache = Object.create(null);
// @param {pattern}
const $a3d6107d2fcf3806$var$makeRegex = (pattern, ignoreCase)=>{
    let source = $a3d6107d2fcf3806$var$regexCache[pattern];
    if (!source) {
        source = $a3d6107d2fcf3806$var$REPLACERS.reduce((prev, current)=>prev.replace(current[0], current[1].bind(pattern)), pattern);
        $a3d6107d2fcf3806$var$regexCache[pattern] = source;
    }
    return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
};
const $a3d6107d2fcf3806$var$isString = (subject)=>typeof subject === "string";
// > A blank line matches no files, so it can serve as a separator for readability.
const $a3d6107d2fcf3806$var$checkPattern = (pattern)=>pattern && $a3d6107d2fcf3806$var$isString(pattern) && !$a3d6107d2fcf3806$var$REGEX_TEST_BLANK_LINE.test(pattern) && !$a3d6107d2fcf3806$var$REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
const $a3d6107d2fcf3806$var$splitPattern = (pattern)=>pattern.split($a3d6107d2fcf3806$var$REGEX_SPLITALL_CRLF);
class $a3d6107d2fcf3806$var$IgnoreRule {
    constructor(origin, pattern, negative, regex){
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
    }
}
const $a3d6107d2fcf3806$var$createRule = (pattern, ignoreCase)=>{
    const origin = pattern;
    let negative = false;
    // > An optional prefix "!" which negates the pattern;
    if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
    }
    pattern = pattern// > Put a backslash ("\") in front of the first "!" for patterns that
    // >   begin with a literal "!", for example, `"\!important!.txt"`.
    .replace($a3d6107d2fcf3806$var$REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!")// > Put a backslash ("\") in front of the first hash for patterns that
    // >   begin with a hash.
    .replace($a3d6107d2fcf3806$var$REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex = $a3d6107d2fcf3806$var$makeRegex(pattern, ignoreCase);
    return new $a3d6107d2fcf3806$var$IgnoreRule(origin, pattern, negative, regex);
};
const $a3d6107d2fcf3806$var$throwError = (message, Ctor)=>{
    throw new Ctor(message);
};
const $a3d6107d2fcf3806$var$checkPath = (path, originalPath, doThrow)=>{
    if (!$a3d6107d2fcf3806$var$isString(path)) return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    // We don't know if we should ignore EMPTY, so throw
    if (!path) return doThrow(`path must not be empty`, TypeError);
    // Check if it is a relative path
    if ($a3d6107d2fcf3806$var$checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
};
const $a3d6107d2fcf3806$var$isNotRelative = (path)=>$a3d6107d2fcf3806$var$REGEX_TEST_INVALID_PATH.test(path);
$a3d6107d2fcf3806$var$checkPath.isNotRelative = $a3d6107d2fcf3806$var$isNotRelative;
$a3d6107d2fcf3806$var$checkPath.convert = (p)=>p;
class $a3d6107d2fcf3806$var$Ignore {
    constructor({ ignorecase: ignorecase = true, ignoreCase: ignoreCase = ignorecase, allowRelativePaths: allowRelativePaths = false } = {}){
        $a3d6107d2fcf3806$var$define(this, $a3d6107d2fcf3806$var$KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
    }
    _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
    }
    _addPattern(pattern) {
        // #32
        if (pattern && pattern[$a3d6107d2fcf3806$var$KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules);
            this._added = true;
            return;
        }
        if ($a3d6107d2fcf3806$var$checkPattern(pattern)) {
            const rule = $a3d6107d2fcf3806$var$createRule(pattern, this._ignoreCase);
            this._added = true;
            this._rules.push(rule);
        }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(pattern) {
        this._added = false;
        $a3d6107d2fcf3806$var$makeArray($a3d6107d2fcf3806$var$isString(pattern) ? $a3d6107d2fcf3806$var$splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        // Some rules have just added to the ignore,
        // making the behavior changed.
        if (this._added) this._initCache();
        return this;
    }
    // legacy
    addPattern(pattern) {
        return this.add(pattern);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule)=>{
            const { negative: negative } = rule;
            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) return;
            const matched = rule.regex.test(path);
            if (matched) {
                ignored = !negative;
                unignored = negative;
            }
        });
        return {
            ignored: ignored,
            unignored: unignored
        };
    }
    // @returns {TestResult}
    _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && $a3d6107d2fcf3806$var$checkPath.convert(originalPath);
        $a3d6107d2fcf3806$var$checkPath(path, originalPath, this._allowRelativePaths ? $a3d6107d2fcf3806$var$RETURN_FALSE : $a3d6107d2fcf3806$var$throwError);
        return this._t(path, cache, checkUnignored, slices);
    }
    _t(path, cache, checkUnignored, slices) {
        if (path in cache) return cache[path];
        if (!slices) // path/to/a.js
        // ['path', 'to', 'a.js']
        slices = path.split($a3d6107d2fcf3806$var$SLASH);
        slices.pop();
        // If the path has no parent directory, just test it
        if (!slices.length) return cache[path] = this._testOne(path, checkUnignored);
        const parent = this._t(slices.join($a3d6107d2fcf3806$var$SLASH) + $a3d6107d2fcf3806$var$SLASH, cache, checkUnignored, slices);
        // If the path contains a parent directory, check the parent first
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
    }
    ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
    }
    createFilter() {
        return (path)=>!this.ignores(path);
    }
    filter(paths) {
        return $a3d6107d2fcf3806$var$makeArray(paths).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(path) {
        return this._test(path, this._testCache, true);
    }
}
const $a3d6107d2fcf3806$var$factory = (options)=>new $a3d6107d2fcf3806$var$Ignore(options);
const $a3d6107d2fcf3806$var$isPathValid = (path)=>$a3d6107d2fcf3806$var$checkPath(path && $a3d6107d2fcf3806$var$checkPath.convert(path), path, $a3d6107d2fcf3806$var$RETURN_FALSE);
$a3d6107d2fcf3806$var$factory.isPathValid = $a3d6107d2fcf3806$var$isPathValid;
// Fixes typescript
$a3d6107d2fcf3806$var$factory.default = $a3d6107d2fcf3806$var$factory;
$a3d6107d2fcf3806$exports = $a3d6107d2fcf3806$var$factory;
// Windows
// --------------------------------------------------------------
/* istanbul ignore if */ if (// Detect `process` so that it can run in browsers.
typeof $FkHbz !== "undefined" && ($FkHbz.env && undefined, $FkHbz.platform === "win32")) {
    /* eslint no-control-regex: "off" */ const makePosix = (str)=>/^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    $a3d6107d2fcf3806$var$checkPath.convert = makePosix;
    // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
    // 'd:\\foo'
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    $a3d6107d2fcf3806$var$checkPath.isNotRelative = (path)=>REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || $a3d6107d2fcf3806$var$isNotRelative(path);
}



var $1a1f52eca6bba4a3$require$Utils = $659ab4db13967c07$exports.Utils;

var $1a1f52eca6bba4a3$require$Constants = $2ef5299e07961cfe$exports.Constants;
const $1a1f52eca6bba4a3$var$WATCH_EVENT_NOTIFICATION = "PHOENIX_WATCH_EVENT_NOTIFICATION";
function $1a1f52eca6bba4a3$var$_setupBroadcastChannel() {
    if ($1a1f52eca6bba4a3$var$_channel) return;
    if (typeof BroadcastChannel === "undefined") {
        /* eslint no-console: 0 */ console.warn("BroadcastChannel not supported. File system watch events across tabs wont be synced.");
        return;
    }
    $1a1f52eca6bba4a3$var$_channel = new BroadcastChannel($1a1f52eca6bba4a3$var$WATCH_EVENT_NOTIFICATION);
}
function $1a1f52eca6bba4a3$var$_broadcastWatchEvent(event) {
    $1a1f52eca6bba4a3$var$_setupBroadcastChannel();
    $1a1f52eca6bba4a3$var$_channel.postMessage(event);
}
function $1a1f52eca6bba4a3$var$_isAnIgnoredPath(watchedPath, changedPath, gitignore) {
    const relativePath = globalObject.path.relative(watchedPath, changedPath);
    return relativePath && gitignore.ignores(relativePath);
}
function $1a1f52eca6bba4a3$var$_isSameOrSubDirectory(parent, child) {
    return !globalObject.path.relative(parent, child).startsWith("..");
}
// event{ path, eventName}
function $1a1f52eca6bba4a3$var$_processFsWatchEvent(event, broadcast = true) {
    if (broadcast) $1a1f52eca6bba4a3$var$_broadcastWatchEvent(event);
    for (const eventEmitter of $1a1f52eca6bba4a3$var$_eventEmitters)if ($1a1f52eca6bba4a3$var$_isSameOrSubDirectory(eventEmitter.watchedPath, event.path) && !$1a1f52eca6bba4a3$var$_isAnIgnoredPath(eventEmitter.watchedPath, event.path, eventEmitter.gitignore)) eventEmitter.emit(event.event, {
        path: event.path
    });
}
function $1a1f52eca6bba4a3$var$_listenToExternalFsWatchEvents() {
    $1a1f52eca6bba4a3$var$_setupBroadcastChannel();
    $1a1f52eca6bba4a3$var$_channel.onmessage = async function(event) {
        if (virtualfs.debugMode) console.log("PhoenixFS: External fs watch event: ", event.data);
        $1a1f52eca6bba4a3$var$_processFsWatchEvent(event.data, false);
    };
}
function $1a1f52eca6bba4a3$var$_triggerEvent(path, eventType) {
    let pathLib = globalObject.path;
    path = pathLib.normalize(path);
    let event = {
        event: eventType,
        path: path
    };
    $1a1f52eca6bba4a3$var$_processFsWatchEvent(event);
}
function $1a1f52eca6bba4a3$var$reportUnlinkEvent(path, isDir) {
    if ($1a1f52eca6bba4a3$require$Utils.isTauriSubPath(path)) // tauri watches native paths with node, so no virtual events needs to be handled
    return;
    if (isDir) $1a1f52eca6bba4a3$var$_triggerEvent(path, $1a1f52eca6bba4a3$require$Constants.WATCH_EVENTS.UNLINK_DIR);
    else $1a1f52eca6bba4a3$var$_triggerEvent(path, $1a1f52eca6bba4a3$require$Constants.WATCH_EVENTS.UNLINK_FILE);
}
function $1a1f52eca6bba4a3$var$reportChangeEvent(path) {
    if ($1a1f52eca6bba4a3$require$Utils.isTauriSubPath(path)) // tauri watches native paths with node, so no virtual events needs to be handled
    return;
    $1a1f52eca6bba4a3$var$_triggerEvent(path, $1a1f52eca6bba4a3$require$Constants.WATCH_EVENTS.CHANGE);
}
function $1a1f52eca6bba4a3$var$reportCreateEvent(path, isDir) {
    if ($1a1f52eca6bba4a3$require$Utils.isTauriSubPath(path)) // tauri watches native paths with node, so no virtual events needs to be handled
    return;
    if (isDir) $1a1f52eca6bba4a3$var$_triggerEvent(path, $1a1f52eca6bba4a3$require$Constants.WATCH_EVENTS.ADD_DIR);
    else $1a1f52eca6bba4a3$var$_triggerEvent(path, $1a1f52eca6bba4a3$require$Constants.WATCH_EVENTS.ADD_FILE);
}
/**
 * Watch a specific path asynchronously for filesystem changes.
 *
 * This function returns a promise that resolves an `EventEmitter` that will emit the following events:
 * - `fs.WATCH_EVENTS.ADD_FILE`: When a file is created.
 * - `fs.WATCH_EVENTS.ADD_DIR`: When a directory is created.
 * - `fs.WATCH_EVENTS.UNLINK_FILE`: When a file is deleted.
 * - `fs.WATCH_EVENTS.UNLINK_DIR`: When a directory is deleted.
 * - `fs.WATCH_EVENTS.CHANGE`: When a file is changed.
 *
 * The watcher will ignore all files matching patterns in the provided gitignore.
 *
 * @function
 * @async
 * @param {string} path - The path to watch for filesystem changes.
 * @param {string|Array<string>} [gitIgnorePaths=""] - The patterns to ignore, either provided as a string
 *      (representing the content of a `.gitignore` file) or an array of individual patterns. The watcher will
 *      adhere to the standard `.gitignore` specification as detailed at https://git-scm.com/docs/gitignore.
 *      It's important to note that if a parent directory is excluded from watching, its child directories
 *      will also be excluded, regardless of any `un-ignore` patterns in git ignore file(e.g., `!node_modules/dont_ignore_dir`).
 *
 * @returns {EventEmitter} - The event emitter that will notify of filesystem changes.
 *
 * @example
 * // In the below watcher, we provide a gitignore formatted text to ignores 'node_modules' folder
 * // See https://git-scm.com/docs/gitignore for details.
 * const watcher = await fs.watchAsync('/path/to/watch', 'node_modules');
 *
 * watcher.on(Constants.WATCH_EVENTS.ADD_FILE, (event) => {
 *   console.log(`File created: ${event.path}`);
 * });
 *
 * watcher.on(Constants.WATCH_EVENTS.UNLINK_DIR, (event) => {
 *   console.log(`Directory deleted: ${event.path}`);
 * });
 */ async function $1a1f52eca6bba4a3$var$watchAsync(path, gitIgnorePaths = "") {
    const eventEmitter = new $7487250c9841db87$exports();
    eventEmitter.gitignore = $a3d6107d2fcf3806$exports().add(gitIgnorePaths);
    eventEmitter.watchedPath = path;
    $1a1f52eca6bba4a3$var$_eventEmitters.push(eventEmitter);
    return eventEmitter;
}
/**
 * Stops watching for filesystem changes on a previously set path.
 *
 * Once you've stopped watching using `unwatchAsync`, any further operations on the event emitter
 * will throw an error. If you wish to start watching again, you will need to call `fs.watchAsync`.
 *
 * @function
 * @param {EventEmitter} eventEmitter - The event emitter returned by `fs.watchAsync` that you wish to stop watching.
 * @throws {Errors.EINVAL} Throws an error if the watcher is already closed or if operations are attempted after closing.
 *
 * @example
 * const watcher = await fs.watchAsync('/path/to/watch', 'node_modules');
 *
 * // Listen to an event.
 * watcher.on(fs.WATCH_EVENTS.ADD_FILE, (event) => {
 *   console.log(`File created: ${event.path}`);
 * });
 *
 * // ... After some time, stop watching.
 * await unwatchAsync(watcher);
 *
 * // Throws error since the watcher is closed.
 * watcher.on(fs.WATCH_EVENTS.ADD_FILE, (event) => {
 *   console.log(`File created: ${event.path}`);
 * });
 */ async function $1a1f52eca6bba4a3$var$unwatchAsync(eventEmitter) {
    if (eventEmitter.allreadyClosed) return;
    eventEmitter.removeAllListeners();
    eventEmitter.on = function() {
        throw new $1a1f52eca6bba4a3$require$Errors.EINVAL("The File watcher is closed. Please use `fs.watchAsync` if you want to watch again.");
    };
    eventEmitter.allreadyClosed = true;
    let index = $1a1f52eca6bba4a3$var$_eventEmitters.findIndex((e)=>e === eventEmitter);
    if (index !== -1) $1a1f52eca6bba4a3$var$_eventEmitters.splice(index, 1);
}
$1a1f52eca6bba4a3$var$_listenToExternalFsWatchEvents();
const $1a1f52eca6bba4a3$var$FsWatch = {
    watchAsync: $1a1f52eca6bba4a3$var$watchAsync,
    unwatchAsync: $1a1f52eca6bba4a3$var$unwatchAsync,
    reportUnlinkEvent: $1a1f52eca6bba4a3$var$reportUnlinkEvent,
    reportChangeEvent: $1a1f52eca6bba4a3$var$reportChangeEvent,
    reportCreateEvent: $1a1f52eca6bba4a3$var$reportCreateEvent
};
$1a1f52eca6bba4a3$exports = {
    FsWatch: $1a1f52eca6bba4a3$var$FsWatch
};


var $e3f139c5065f0041$require$FsWatch = $1a1f52eca6bba4a3$exports.FsWatch;
var $b77f34d02b78ab8d$exports = {};
/*
 * GNU AGPL-3.0 License
 *
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.
 *
 */ // jshint ignore: start
/*global fs, globalObject*/ /*eslint no-console: 0*/ /*eslint strict: ["error", "global"]*/ 
var $b77f34d02b78ab8d$require$TauriFS = $d1f4f8cce920e9b9$exports.TauriFS;

var $b77f34d02b78ab8d$require$Mounts = $d71a2f6bd42cb0cc$exports.Mounts;

var $b77f34d02b78ab8d$require$Constants = $2ef5299e07961cfe$exports.Constants;

var $b77f34d02b78ab8d$require$ERR_CODES = $ee841df9a5ce9c95$exports.ERR_CODES;
var $b77f34d02b78ab8d$require$Errors = $ee841df9a5ce9c95$exports.Errors;
const $b77f34d02b78ab8d$var$ERROR_CODES = $b77f34d02b78ab8d$require$ERR_CODES.ERROR_CODES;
function $b77f34d02b78ab8d$var$_stat(path) {
    return new Promise((resolve, reject)=>{
        fs.stat(path, async (err, stat)=>{
            if (err && err.code === $b77f34d02b78ab8d$var$ERROR_CODES.ENOENT) resolve(null);
            else if (err) reject(err);
            else resolve(stat);
        });
    });
}
function $b77f34d02b78ab8d$var$_mkdirIfNotPresent(path) {
    return new Promise((resolve, reject)=>{
        fs.mkdir(path, async (err)=>{
            err && err.code !== $b77f34d02b78ab8d$var$ERROR_CODES.EEXIST ? reject(err) : resolve();
        });
    });
}
function $b77f34d02b78ab8d$var$_readDir(path) {
    return new Promise((resolve, reject)=>{
        fs.readdir(path, (err, listing)=>{
            if (err) reject(err);
            else resolve(listing);
        });
    });
}
function $b77f34d02b78ab8d$var$_copyFileContents(src, dst) {
    let encoding = $b77f34d02b78ab8d$require$Constants.BINARY_ENCODING; // this is the Filer default binary return object
    if ($b77f34d02b78ab8d$require$TauriFS.isTauriSubPath(src) && $b77f34d02b78ab8d$require$TauriFS.isTauriSubPath(dst) || $b77f34d02b78ab8d$require$Mounts.isMountSubPath(src) && $b77f34d02b78ab8d$require$Mounts.isMountSubPath(dst)) encoding = $b77f34d02b78ab8d$require$Constants.BYTE_ARRAY_ENCODING; // this is the browser native encoding to make copying faster
    return new Promise((resolve, reject)=>{
        fs.readFile(src, encoding, (err, data)=>{
            if (err) reject(err);
            else fs.writeFile(dst, data, encoding, function(writeErr) {
                writeErr ? reject(writeErr) : resolve();
            });
        });
    });
}
async function $b77f34d02b78ab8d$var$_copyFile(srcFile, dst) {
    let dstStat = await $b77f34d02b78ab8d$var$_stat(dst);
    if (!dstStat) {
        let parentDir = globalObject.path.dirname(dst);
        let dstFileName = globalObject.path.basename(dst);
        dstStat = await $b77f34d02b78ab8d$var$_stat(parentDir);
        if (dstStat && dstStat.isDirectory()) {
            let dstFilePath = `${parentDir}/${dstFileName}`;
            await $b77f34d02b78ab8d$var$_copyFileContents(srcFile, dstFilePath);
            return dstFilePath;
        } else throw new $b77f34d02b78ab8d$require$Errors.EIO(`_copyFile Cannot create destination file: ${dst}`);
    }
    let srcFileName = globalObject.path.basename(srcFile);
    if (dstStat && dstStat.isDirectory()) {
        let dstFilePath = `${dst}/${srcFileName}`;
        await $b77f34d02b78ab8d$var$_copyFileContents(srcFile, dstFilePath);
        return dstFilePath;
    } else if (dstStat && dstStat.isFile()) throw new $b77f34d02b78ab8d$require$Errors.EEXIST(`_copyFile Destination file already exists: ${dst}`);
    else throw new $b77f34d02b78ab8d$require$Errors.EIO(`_copyFile Cannot copy file, unknown destination: ${srcFile} to ${dst}`);
}
async function $b77f34d02b78ab8d$var$_copyTree(src, dst) {
    let srcEntries = await $b77f34d02b78ab8d$var$_readDir(src);
    for (let entry of srcEntries){
        let entryPath = `${src}/${entry}`;
        let dstPath = `${dst}/${entry}`;
        let srcStat = await $b77f34d02b78ab8d$var$_stat(entryPath);
        if (srcStat.isFile()) await $b77f34d02b78ab8d$var$_copyFileContents(entryPath, dstPath);
        else {
            await $b77f34d02b78ab8d$var$_mkdirIfNotPresent(dstPath);
            await $b77f34d02b78ab8d$var$_copyTree(entryPath, dstPath);
        }
    }
}
async function $b77f34d02b78ab8d$var$_copyFolder(srcFolder, dst) {
    let dstStat = await $b77f34d02b78ab8d$var$_stat(dst);
    if (dstStat && dstStat.isFile()) throw new $b77f34d02b78ab8d$require$Errors.EEXIST(`Destination file already exists: ${dst}`);
    else if (dstStat && dstStat.isDirectory()) {
        let destSubFolderPath = `${dst}/${globalObject.path.basename(srcFolder)}`;
        dstStat = await $b77f34d02b78ab8d$var$_stat(destSubFolderPath);
        if (dstStat) throw new $b77f34d02b78ab8d$require$Errors.EEXIST(`Destination folder already exists: ${destSubFolderPath}`);
        await $b77f34d02b78ab8d$var$_mkdirIfNotPresent(destSubFolderPath);
        await $b77f34d02b78ab8d$var$_copyTree(srcFolder, destSubFolderPath);
        return destSubFolderPath;
    } else {
        await $b77f34d02b78ab8d$var$_mkdirIfNotPresent(dst);
        await $b77f34d02b78ab8d$var$_copyTree(srcFolder, dst);
        return dst;
    }
}
/**
 * Asynchronously copies a source file or directory to a destination.
 * If the source is a file, it will be copied to the specified destination (the destination file doesn't exist).
 * If the source is a directory, the directory will be copied recursively to the destination.
 *
 * @param {string} src - The path to the source file or directory.
 * @param {string} dst - The path to the destination. If the source is a file, this should be the full path to the destination file.
 * If the source is a directory, this should be the destination directory where the source directory's contents should be copied.
 * If the destination directory exists, the source folder will be copied as a child of the destination folder.
 * @param {function(Error|null, string?)} callback - Callback function called once the copy operation completes.
 *        - The first argument is an error if any occurred during the copy operation or `null` if the copy was successful.
 *        - The second argument is the path to the copied file or directory if the copy was successful.
 *
 * @throws {Errors.ENOENT} When the source doesn't exist.
 * @throws {Errors.EIO} For I/O related errors.
 * @throws {Errors.EEXIST} When the destination file or directory already exists.
 *
 * @example
 * copy('/path/to/src', '/path/to/dest', (err, copiedPath) => {
 *   if (err) {
 *     console.error('Copy failed:', err);
 *   } else {
 *     console.log('Copy succeeded:', copiedPath);
 *   }
 * });
 *
 * @returns {void}
 */ async function $b77f34d02b78ab8d$var$copy(src, dst, callback) {
    try {
        let srcStat = await $b77f34d02b78ab8d$var$_stat(src);
        if (!srcStat) {
            callback(new $b77f34d02b78ab8d$require$Errors.ENOENT(`Cannot copy src that doesnt exist: ${src}`));
            return;
        }
        if (srcStat.isFile()) {
            let copiedPath = await $b77f34d02b78ab8d$var$_copyFile(src, dst);
            callback(null, copiedPath);
        } else if (srcStat.isDirectory()) {
            let copiedPath = await $b77f34d02b78ab8d$var$_copyFolder(src, dst);
            callback(null, copiedPath);
        }
    } catch (e) {
        callback(new $b77f34d02b78ab8d$require$Errors.EIO(`${e}: Cannot copy src: ${src} to ${dst}`));
    }
}
function $b77f34d02b78ab8d$var$globalCopy(src, dst, cb) {
    $b77f34d02b78ab8d$var$copy(globalObject.path.normalize(src), globalObject.path.normalize(dst), cb);
}
$b77f34d02b78ab8d$exports = {
    globalCopy: $b77f34d02b78ab8d$var$globalCopy
};


var $e3f139c5065f0041$require$globalCopy = $b77f34d02b78ab8d$exports.globalCopy;
var $b45ac22e865b129b$exports = {};
"use strict";

$b45ac22e865b129b$exports = (parcelRequire("1xCGA"));



let $e3f139c5065f0041$var$filerLib = null;
let $e3f139c5065f0041$var$filerShell = null;
/**
 * Offers functionality similar to mkdir -p
 *
 * Asynchronous operation. No arguments other than a possible exception
 * are given to the completion callback.
 */ function $e3f139c5065f0041$var$_mkdir_p(fsLib, path, mode, callback, _position) {
    const osSep = "/";
    const parts = $e3f139c5065f0041$var$filerLib.path.normalize(path).split(osSep);
    mode = mode || $FkHbz.umask();
    _position = _position || 0;
    if (_position >= parts.length) return callback(null);
    var directory = parts.slice(0, _position + 1).join(osSep) || osSep;
    fsLib.stat(directory, function(err) {
        if (err === null) $e3f139c5065f0041$var$_mkdir_p(fsLib, path, mode, callback, _position + 1);
        else fsLib.mkdir(directory, mode, function(error) {
            if (error && error.code !== "EEXIST") return callback(error);
            else $e3f139c5065f0041$var$_mkdir_p(fsLib, path, mode, callback, _position + 1);
        });
    });
}
function $e3f139c5065f0041$var$_ensure_mount_directory() {
    $e3f139c5065f0041$var$fileSystemLib.mkdirs($e3f139c5065f0041$require$Constants.MOUNT_POINT_ROOT);
    $e3f139c5065f0041$var$fileSystemLib.mkdirs($e3f139c5065f0041$require$Constants.TAURI_ROOT);
    $e3f139c5065f0041$require$NativeFS.refreshMountPoints();
}
function $e3f139c5065f0041$var$_getFirstFunctionIndex(argsArray) {
    for(let i = 0; i < argsArray.length; i++){
        if (typeof argsArray[i] === "function") return i;
    }
    return -1;
}
function $e3f139c5065f0041$var$_isSubPathOf(dir, subDir) {
    const relative = $e3f139c5065f0041$var$filerLib.path.relative(dir, subDir);
    return relative && !relative.startsWith("..") && !$e3f139c5065f0041$var$filerLib.path.isAbsolute(relative);
}
const $e3f139c5065f0041$var$fileSystemLib = {
    mountNativeFolder: async function(...args) {
        return $e3f139c5065f0041$require$NativeFS.mountNativeFolder(...args);
    },
    openTauriFilePickerAsync: function(options) {
        return $e3f139c5065f0041$require$TauriFS.openTauriFilePickerAsync(options);
    },
    openTauriFileSaveDialogueAsync: function(options) {
        return $e3f139c5065f0041$require$TauriFS.openTauriFileSaveDialogueAsync(options);
    },
    getTauriPlatformPath: function(virtualPath) {
        if ($e3f139c5065f0041$require$TauriFS.isTauriPath(virtualPath) || $e3f139c5065f0041$require$TauriFS.isTauriSubPath(virtualPath)) return $e3f139c5065f0041$require$TauriFS.getTauriPlatformPath(virtualPath);
        return null;
    },
    getTauriVirtualPath: function(platformPath) {
        return $e3f139c5065f0041$require$TauriFS.getTauriVirtualPath(platformPath);
    },
    readdir: function(...args) {
        let path = args[0];
        if ($e3f139c5065f0041$require$TauriFS.isTauriPath(path) || $e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.readdir(...args);
        if ($e3f139c5065f0041$require$Mounts.isMountPath(path) || $e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.readdir(...args);
        return $e3f139c5065f0041$var$filerLib.fs.readdir(...args);
    },
    stat: function(...args) {
        let path = args[0];
        if (typeof path !== "string") {
            let callback = args[$e3f139c5065f0041$var$_getFirstFunctionIndex(args)];
            return callback(new $e3f139c5065f0041$require$Errors.EINVAL(`Error Invalid path for stat: ${path}`));
        }
        if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.stat(...args);
        if ($e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.stat(...args);
        return $e3f139c5065f0041$var$filerLib.fs.stat(...args);
    },
    readFile: function(...args) {
        let path = args[0];
        if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.readFile(...args);
        else if ($e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.readFile(...args);
        return $e3f139c5065f0041$require$FilerFSModified.readFile(...args);
    },
    writeFile: function(...args) {
        let path = args[0];
        let newFileCreated = false;
        function callbackInterceptor(...interceptedArgs) {
            let err = interceptedArgs.length >= 1 ? interceptedArgs[0] : null;
            if (!err) {
                if (newFileCreated) $e3f139c5065f0041$require$FsWatch.reportCreateEvent(path, false);
                else $e3f139c5065f0041$require$FsWatch.reportChangeEvent(path);
            }
            if (args.originalCallback) args.originalCallback(...interceptedArgs);
        }
        let callbackIndex = $e3f139c5065f0041$var$_getFirstFunctionIndex(args);
        if (callbackIndex !== -1) {
            args.originalCallback = args[callbackIndex];
            args[callbackIndex] = callbackInterceptor;
        }
        if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.writeFile(...args);
        $e3f139c5065f0041$var$fileSystemLib.stat(path, (err)=>{
            if (err && err.code === $e3f139c5065f0041$require$ERR_CODES.ERROR_CODES.ENOENT) newFileCreated = true;
            if ($e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.writeFile(...args);
            return $e3f139c5065f0041$require$FilerFSModified.writeFile(...args);
        });
    },
    mkdir: function(...args) {
        let path = args[0];
        function callbackInterceptor(...interceptedArgs) {
            let err = interceptedArgs.length >= 1 ? interceptedArgs[0] : null;
            if (!err) $e3f139c5065f0041$require$FsWatch.reportCreateEvent(path, true);
            if (args.originalCallback) args.originalCallback(...interceptedArgs);
        }
        let callbackIndex = $e3f139c5065f0041$var$_getFirstFunctionIndex(args);
        if (callbackIndex !== -1) {
            args.originalCallback = args[callbackIndex];
            args[callbackIndex] = callbackInterceptor;
        }
        if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.mkdirs(...args);
        if ($e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.mkdir(...args);
        return $e3f139c5065f0041$var$filerLib.fs.mkdir(...args);
    },
    rename: function(oldPath, newPath, cb) {
        function callbackInterceptor(...args) {
            let err = args.length >= 1 ? args[0] : null;
            if (!err) {
                if (!$e3f139c5065f0041$require$TauriFS.isTauriSubPath(oldPath) || !$e3f139c5065f0041$require$TauriFS.isTauriSubPath(newPath)) // we only need to manually handle watch events for non tauri paths as tauri watch is done at node
                $e3f139c5065f0041$var$fileSystemLib.stat(newPath, (err, stat)=>{
                    const isDir = !err && stat.isDirectory();
                    if (!$e3f139c5065f0041$require$TauriFS.isTauriSubPath(oldPath)) $e3f139c5065f0041$require$FsWatch.reportUnlinkEvent(oldPath, isDir);
                    if (!$e3f139c5065f0041$require$TauriFS.isTauriSubPath(newPath)) $e3f139c5065f0041$require$FsWatch.reportCreateEvent(newPath, isDir);
                });
            }
            if (cb) cb(...args);
        }
        if ($e3f139c5065f0041$var$_isSubPathOf(oldPath, newPath) || $e3f139c5065f0041$var$_isSubPathOf(newPath, oldPath)) {
            callbackInterceptor(new $e3f139c5065f0041$require$Errors.EINVAL(`Error renaming as one is a sub-path of other: ${newPath}, ${oldPath}`));
            return;
        }
        if ($e3f139c5065f0041$require$Mounts.isMountPath(oldPath) || $e3f139c5065f0041$require$Mounts.isMountPath(newPath)) {
            cb(new $e3f139c5065f0041$require$Errors.EPERM("Mount root directory cannot be renamed."));
            return;
        } else if ($e3f139c5065f0041$require$TauriFS.isTauriPath(oldPath) || $e3f139c5065f0041$require$TauriFS.isTauriPath(newPath)) {
            cb(new $e3f139c5065f0041$require$Errors.EPERM("Tauri root directory cannot be renamed."));
            return;
        }
        if (oldPath !== newPath && oldPath.toLowerCase() === newPath.toLowerCase()) {
            // in windows, we should be able to rename "a.txt" to "A.txt". Since windows is case-insensitive,
            // the below stat(A.txt) will return a stat for "a.txt" which is not what we want.
            if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(oldPath) && $e3f139c5065f0041$require$TauriFS.isTauriSubPath(newPath)) return $e3f139c5065f0041$require$TauriFS.rename(oldPath, newPath, callbackInterceptor);
            else if ($e3f139c5065f0041$require$Mounts.isMountSubPath(oldPath) && $e3f139c5065f0041$require$Mounts.isMountSubPath(newPath)) return $e3f139c5065f0041$require$NativeFS.renameSameNameDiffCase(oldPath, newPath, callbackInterceptor);
        }
        $e3f139c5065f0041$var$fileSystemLib.stat(newPath, (err)=>{
            if (!err) {
                // the destination folder/file exists and we should not rename
                cb(new $e3f139c5065f0041$require$Errors.EEXIST("Cannot rename, The destination path exists: " + newPath));
                return;
            }
            if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(oldPath) && $e3f139c5065f0041$require$TauriFS.isTauriSubPath(newPath)) return $e3f139c5065f0041$require$TauriFS.rename(oldPath, newPath, callbackInterceptor);
            else if ($e3f139c5065f0041$require$Mounts.isMountSubPath(oldPath) && $e3f139c5065f0041$require$Mounts.isMountSubPath(newPath)) return $e3f139c5065f0041$require$NativeFS.rename(oldPath, newPath, callbackInterceptor);
            return $e3f139c5065f0041$var$filerLib.fs.rename(oldPath, newPath, callbackInterceptor);
        });
    },
    unlink: function(path, cb) {
        let isDir;
        function callbackInterceptor(...args) {
            let err = args.length >= 1 ? args[0] : null;
            if (!err) $e3f139c5065f0041$require$FsWatch.reportUnlinkEvent(path, isDir);
            if (cb) cb(...args);
        }
        if ($e3f139c5065f0041$require$Mounts.isMountPath(path) || $e3f139c5065f0041$require$TauriFS.isTauriPath(path)) {
            callbackInterceptor(new $e3f139c5065f0041$require$Errors.EPERM("Mount root directory cannot be deleted."));
            return;
        } else if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.unlink(path, callbackInterceptor);
        $e3f139c5065f0041$var$fileSystemLib.stat(path, (err, stat)=>{
            isDir = !err && stat.isDirectory();
            // we do this to emit fs watch events for non-tauri path unlinks.
            // We only need to manually handle watch events for non tauri paths as tauri watch is done at node
            if ($e3f139c5065f0041$require$Mounts.isMountSubPath(path)) return $e3f139c5065f0041$require$NativeFS.unlink(path, callbackInterceptor);
            if (typeof path !== "string") {
                callbackInterceptor(new $e3f139c5065f0041$require$Errors.EINVAL("Invalid arguments."));
                return;
            }
            return $e3f139c5065f0041$var$filerShell.rm(path, {
                recursive: true
            }, callbackInterceptor);
        });
    },
    copy: function(src, dst, cb) {
        function callbackInterceptor(...args) {
            let err = args.length >= 1 ? args[0] : null;
            if (!err) $e3f139c5065f0041$var$fileSystemLib.stat(dst, (err, stat)=>{
                const isDir = !err && stat.isDirectory();
                $e3f139c5065f0041$require$FsWatch.reportCreateEvent(dst, isDir);
            });
            if (cb) cb(...args);
        }
        if ($e3f139c5065f0041$var$_isSubPathOf(src, dst)) {
            callbackInterceptor(new $e3f139c5065f0041$require$Errors.EINVAL(`Error copying: ${dst} cannot be a subpath of ${src}`));
            return;
        }
        // we have two implementation here even though the globalCopy fn is capable of copying anywhere. Native has its
        // own impl to prevent large number of file node io in fs access impl.
        // Ideally we should have a tauri copy impl too, but to unblock main thread while copy, we need to
        // spawn different threads in rust and write tauri handlers which is pretty complex atm. so instead we will
        // fall back to global copy here and will use node Tauri web socket fs adapter as and when it becomes available.
        if ($e3f139c5065f0041$require$Mounts.isMountSubPath(src) && $e3f139c5065f0041$require$Mounts.isMountSubPath(dst)) return $e3f139c5065f0041$require$NativeFS.copy(src, dst, callbackInterceptor);
        else if ($e3f139c5065f0041$require$TauriFS.canCopy() && $e3f139c5065f0041$require$TauriFS.isTauriSubPath(src) && $e3f139c5065f0041$require$TauriFS.isTauriSubPath(dst)) return $e3f139c5065f0041$require$TauriFS.copy(src, dst, callbackInterceptor);
        else return $e3f139c5065f0041$require$globalCopy(src, dst, callbackInterceptor);
    },
    showSaveDialog: function(options) {
        if (window.__TAURI__) return $e3f139c5065f0041$var$fileSystemLib.openTauriFileSaveDialogueAsync(options);
        throw new $e3f139c5065f0041$require$Errors.ENOSYS("Phoenix fs showSaveDialog function not yet supported.");
    },
    watchAsync: function(path, gitIgnorePaths = "") {
        if ($e3f139c5065f0041$require$TauriFS.isTauriPath(path)) throw new $e3f139c5065f0041$require$Errors.EPERM("Cannot watch root directory!", path);
        else if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$NodeTauriFS.watchAsync(path, gitIgnorePaths);
        return $e3f139c5065f0041$require$FsWatch.watchAsync(path, gitIgnorePaths);
    },
    unwatchAsync: function(eventEmitter) {
        if (eventEmitter.eventEmitterID) return $e3f139c5065f0041$require$NodeTauriFS.unwatchAsync(eventEmitter);
        return $e3f139c5065f0041$require$FsWatch.unwatchAsync(eventEmitter);
    },
    moveToTrash: function() {
        throw new $e3f139c5065f0041$require$Errors.ENOSYS("Phoenix fs moveToTrash function not yet supported.");
    },
    mkdirs: function(path, mode, recursive, callback) {
        // Determine if 'mode' is provided
        if (typeof mode !== "number") {
            callback = recursive;
            recursive = mode;
            mode = 511; // Default mode (or any other default you'd like to set)
        }
        // Determine if 'recursive' is provided
        if (typeof recursive !== "boolean") {
            callback = recursive;
            recursive = false;
        }
        // Determine if 'callback' is provided
        if (typeof callback !== "function") callback = function() {
        // Do Nothing
        };
        if (!recursive) $e3f139c5065f0041$var$fileSystemLib.mkdir(path, mode, callback);
        else if ($e3f139c5065f0041$require$TauriFS.isTauriSubPath(path)) return $e3f139c5065f0041$require$TauriFS.mkdirs(path, mode, true, callback);
        else $e3f139c5065f0041$var$_mkdir_p($e3f139c5065f0041$var$fileSystemLib, path, mode, callback);
    },
    testNodeWsEndpoint: function(wsEndPoint, echoData, echoBuffer) {
        return $e3f139c5065f0041$require$NodeTauriFS.testNodeWsEndpoint(wsEndPoint, echoData, echoBuffer);
    },
    setNodeWSEndpoint: function(wsEndPoint) {
        return $e3f139c5065f0041$require$NodeTauriFS.setNodeWSEndpoint(wsEndPoint);
    },
    stopNodeWSEndpoint: function(wsEndPoint) {
        return $e3f139c5065f0041$require$NodeTauriFS.stopNodeWSEndpoint(wsEndPoint);
    },
    getNodeWSEndpoint: function() {
        return $e3f139c5065f0041$require$NodeTauriFS.getNodeWSEndpoint();
    },
    forceUseNodeWSEndpoint: function(use) {
        return $e3f139c5065f0041$require$TauriFS.forceUseNodeWSEndpoint(use);
    },
    preferNodeWSEndpoint: function(use) {
        return $e3f139c5065f0041$require$TauriFS.preferNodeWSEndpoint(use);
    },
    BYTE_ARRAY_ENCODING: $e3f139c5065f0041$require$Constants.BYTE_ARRAY_ENCODING,
    MOUNT_POINT_ROOT: $e3f139c5065f0041$require$Constants.MOUNT_POINT_ROOT,
    TAURI_ROOT: $e3f139c5065f0041$require$Constants.TAURI_ROOT,
    ERR_CODES: {},
    WATCH_EVENTS: $e3f139c5065f0041$require$Constants.WATCH_EVENTS,
    isEncodingSupported: function(encoding) {
        if (encoding.toLowerCase() === $e3f139c5065f0041$require$Constants.BYTE_ARRAY_ENCODING) return true;
        return $54aff2427aaf4272$exports.encodingExists(encoding);
    },
    utils: {
        iconv: $54aff2427aaf4272$exports,
        picomatch: $b45ac22e865b129b$exports,
        ignore: $a3d6107d2fcf3806$exports
    }
};
for (let errCode of Object.values($e3f139c5065f0041$require$ERR_CODES.FS_ERROR_CODES))$e3f139c5065f0041$var$fileSystemLib.ERR_CODES[errCode] = errCode;
$e3f139c5065f0041$var$fileSystemLib.copyFile = $e3f139c5065f0041$var$fileSystemLib.copy;
$e3f139c5065f0041$var$fileSystemLib.name = "phoenixFS";
function $e3f139c5065f0041$var$_populateSupportedEncodings() {
    if ($54aff2427aaf4272$exports.encodingExists("utf8")) {
        // we do this as iconv bootstraps this
        const SUPPORTED_ENCODINGS = [];
        for (let encoding of Object.keys($54aff2427aaf4272$exports.encodings))// the Object.keys list contains encoding functions and privates. so filter
        if ($54aff2427aaf4272$exports.encodingExists(encoding)) SUPPORTED_ENCODINGS.push(encoding);
        SUPPORTED_ENCODINGS.push($e3f139c5065f0041$var$fileSystemLib.BYTE_ARRAY_ENCODING);
        $e3f139c5065f0041$var$fileSystemLib.SUPPORTED_ENCODINGS = SUPPORTED_ENCODINGS;
    }
}
function $e3f139c5065f0041$var$initFsLib(FilerLib) {
    $e3f139c5065f0041$var$filerLib = FilerLib;
    $e3f139c5065f0041$require$FilerFSModified.initFilerLib($e3f139c5065f0041$var$filerLib);
    $e3f139c5065f0041$var$filerShell = new $e3f139c5065f0041$var$filerLib.fs.Shell();
    globalObject.path = FilerLib.path;
    globalObject.Buffer = FilerLib.Buffer;
    globalObject.iconv = $54aff2427aaf4272$exports;
    globalObject.fs = $e3f139c5065f0041$var$fileSystemLib;
    globalObject.fs.path = FilerLib.path;
    globalObject.fs.Buffer = FilerLib.Buffer;
    $e3f139c5065f0041$var$_populateSupportedEncodings();
    $e3f139c5065f0041$var$_ensure_mount_directory();
}
$e3f139c5065f0041$exports = {
    initFsLib: $e3f139c5065f0041$var$initFsLib
};


var $3132870559d60e53$require$initFsLib = $e3f139c5065f0041$exports.initFsLib;
$3132870559d60e53$require$initFsLib($8adf1cfaed2eb5b1$exports);

})();
//# sourceMappingURL=virtualfs.js.map
