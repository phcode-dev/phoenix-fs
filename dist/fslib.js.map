{"mappings":"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","sources":["src/errno.js","src/constants.js","src/mount_point_storage.js","src/fslib_mounts.js","src/utils.js","src/fslib_native.js","src/fslib_watch.js","src/thirdparty/globmatch.js","src/filerlib_copy.js","node_modules/process/browser.js","src/fslib.js"],"sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Copyright (c) 2012-2015 Rod Vagg (@rvagg)\n * Based on : https://github.com/rvagg/node-errno\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*eslint-env es6*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n\n/** All phoenix shell errors and their description.\n *\n * This module should be functionally as light weight as possible with minimal deps as it is a shell component.\n * **/\n\nconst ERROR_CODES = {\n    ENOENT: 'ENOENT',\n    UNKNOWN: 'UNKNOWN',\n    OK: 'OK',\n    EOF: 'EOF',\n    EADDRINFO: 'EADDRINFO',\n    EACCES: 'EACCES',\n    EAGAIN: 'EAGAIN',\n    EADDRINUSE: 'EADDRINUSE',\n    EADDRNOTAVAIL: 'EADDRNOTAVAIL',\n    EAFNOSUPPORT: 'EAFNOSUPPORT',\n    EALREADY: 'EALREADY',\n    EBADF: 'EBADF',\n    EBUSY: 'EBUSY',\n    ECONNABORTED: 'ECONNABORTED',\n    ECONNREFUSED: 'ECONNREFUSED',\n    ECONNRESET: 'ECONNRESET',\n    EDESTADDRREQ: 'EDESTADDRREQ',\n    EFAULT: 'EFAULT',\n    EHOSTUNREACH: 'EHOSTUNREACH',\n    EINTR: 'EINTR',\n    EINVAL: 'EINVAL',\n    EISCONN: 'EISCONN',\n    EMFILE: 'EMFILE',\n    EMSGSIZE: 'EMSGSIZE',\n    ENETDOWN: 'ENETDOWN',\n    ENETUNREACH: 'ENETUNREACH',\n    ENFILE: 'ENFILE',\n    ENOBUFS: 'ENOBUFS',\n    ENOMEM: 'ENOMEM',\n    ENOTDIR: 'ENOTDIR',\n    EISDIR: 'EISDIR',\n    ENONET: 'ENONET',\n    ENOTCONN: 'ENOTCONN',\n    ENOTSOCK: 'ENOTSOCK',\n    ENOTSUP: 'ENOTSUP',\n    ENOSYS: 'ENOSYS',\n    EPIPE: 'EPIPE',\n    EPROTO: 'EPROTO',\n    EPROTONOSUPPORT: 'EPROTONOSUPPORT',\n    EPROTOTYPE: 'EPROTOTYPE',\n    ETIMEDOUT: 'ETIMEDOUT',\n    ECHARSET: 'ECHARSET',\n    EAIFAMNOSUPPORT: 'EAIFAMNOSUPPORT',\n    EAISERVICE: 'EAISERVICE',\n    EAISOCKTYPE: 'EAISOCKTYPE',\n    ESHUTDOWN: 'ESHUTDOWN',\n    EEXIST: 'EEXIST',\n    ESRCH: 'ESRCH',\n    ENAMETOOLONG: 'ENAMETOOLONG',\n    EPERM: 'EPERM',\n    ELOOP: 'ELOOP',\n    EXDEV: 'EXDEV',\n    ENOTEMPTY: 'ENOTEMPTY',\n    ENOSPC: 'ENOSPC',\n    EIO: 'EIO',\n    EROFS: 'EROFS',\n    ENODEV: 'ENODEV',\n    ESPIPE: 'ESPIPE',\n    ECANCELED: 'ECANCELED'\n};\n\nconst FS_ERROR_CODES = {\n    ENOENT: ERROR_CODES.ENOENT, //no such file or directory\n    EOF: ERROR_CODES.EOF, //end of file\n    EACCES: ERROR_CODES.EACCES, //permission denied\n    EAGAIN: ERROR_CODES.EAGAIN, //resource temporarily unavailable\n    EBADF: ERROR_CODES.EBADF, //bad file descriptor\n    EBUSY: ERROR_CODES.EBUSY, //resource busy or locked\n    EINVAL: ERROR_CODES.EINVAL, //invalid argument\n    EMFILE: ERROR_CODES.EMFILE, //too many open files,\n    ENFILE: ERROR_CODES.ENFILE, //file table overflow\n    ENOBUFS: ERROR_CODES.ENOBUFS, //no buffer space available\n    ENOTDIR: ERROR_CODES.ENOTDIR, //not a directory\n    EISDIR: ERROR_CODES.EISDIR, //illegal operation on a directory\n    ENOSYS: ERROR_CODES.ENOSYS, //function not implemented. Eg. creating linux sym links in win\n    ECHARSET: ERROR_CODES.ECHARSET, //invalid Unicode character\n    EEXIST: ERROR_CODES.EEXIST, //file already exists\n    ENAMETOOLONG: ERROR_CODES.ENAMETOOLONG, //name too long\n    EPERM: ERROR_CODES.EPERM, //operation not permitted\n    ELOOP: ERROR_CODES.ELOOP, //too many symbolic links encountered\n    EXDEV: ERROR_CODES.EXDEV, //cross-device link not permitted\n    ENOTEMPTY: ERROR_CODES.ENOTEMPTY, //directory not empty\n    ENOSPC: ERROR_CODES.ENOSPC, //no space left on device\n    EIO: ERROR_CODES.EIO, //i/o error\n    EROFS: ERROR_CODES.EROFS, //read-only file system\n    ESPIPE: ERROR_CODES.ESPIPE, //invalid seek\n    ECANCELED: ERROR_CODES.ECANCELED //operation canceled\n};\n\nconst ALL_ERRORS = [\n    {\n        errno: -2,\n        code: ERROR_CODES.ENOENT,\n        description: 'no such file or directory'\n    },\n    {\n        errno: -1,\n        code: ERROR_CODES.UNKNOWN,\n        description: 'unknown error'\n    },\n    {\n        errno: 0,\n        code: ERROR_CODES.OK,\n        description: 'success'\n    },\n    {\n        errno: 1,\n        code: ERROR_CODES.EOF,\n        description: 'end of file'\n    },\n    {\n        errno: 2,\n        code: ERROR_CODES.EADDRINFO,\n        description: 'getaddrinfo error'\n    },\n    {\n        errno: 3,\n        code: ERROR_CODES.EACCES,\n        description: 'permission denied'\n    },\n    {\n        errno: 4,\n        code: ERROR_CODES.EAGAIN,\n        description: 'resource temporarily unavailable'\n    },\n    {\n        errno: 5,\n        code: ERROR_CODES.EADDRINUSE,\n        description: 'address already in use'\n    },\n    {\n        errno: 6,\n        code: ERROR_CODES.EADDRNOTAVAIL,\n        description: 'address not available'\n    },\n    {\n        errno: 7,\n        code: ERROR_CODES.EAFNOSUPPORT,\n        description: 'address family not supported'\n    },\n    {\n        errno: 8,\n        code: ERROR_CODES.EALREADY,\n        description: 'connection already in progress'\n    },\n    {\n        errno: 9,\n        code: ERROR_CODES.EBADF,\n        description: 'bad file descriptor'\n    },\n    {\n        errno: 10,\n        code: ERROR_CODES.EBUSY,\n        description: 'resource busy or locked'\n    },\n    {\n        errno: 11,\n        code: ERROR_CODES.ECONNABORTED,\n        description: 'software caused connection abort'\n    },\n    {\n        errno: 12,\n        code: ERROR_CODES.ECONNREFUSED,\n        description: 'connection refused'\n    },\n    {\n        errno: 13,\n        code: ERROR_CODES.ECONNRESET,\n        description: 'connection reset by peer'\n    },\n    {\n        errno: 14,\n        code: ERROR_CODES.EDESTADDRREQ,\n        description: 'destination address required'\n    },\n    {\n        errno: 15,\n        code: ERROR_CODES.EFAULT,\n        description: 'bad address in system call argument'\n    },\n    {\n        errno: 16,\n        code: ERROR_CODES.EHOSTUNREACH,\n        description: 'host is unreachable'\n    },\n    {\n        errno: 17,\n        code: ERROR_CODES.EINTR,\n        description: 'interrupted system call'\n    },\n    {\n        errno: 18,\n        code: ERROR_CODES.EINVAL,\n        description: 'invalid argument'\n    },\n    {\n        errno: 19,\n        code: ERROR_CODES.EISCONN,\n        description: 'socket is already connected'\n    },\n    {\n        errno: 20,\n        code: ERROR_CODES.EMFILE,\n        description: 'too many open files'\n    },\n    {\n        errno: 21,\n        code: ERROR_CODES.EMSGSIZE,\n        description: 'message/datagram too long'\n    },\n    {\n        errno: 22,\n        code: ERROR_CODES.ENETDOWN,\n        description: 'network is down'\n    },\n    {\n        errno: 23,\n        code: ERROR_CODES.ENETUNREACH,\n        description: 'network is unreachable'\n    },\n    {\n        errno: 24,\n        code: ERROR_CODES.ENFILE,\n        description: 'file table overflow'\n    },\n    {\n        errno: 25,\n        code: ERROR_CODES.ENOBUFS,\n        description: 'no buffer space available'\n    },\n    {\n        errno: 26,\n        code: ERROR_CODES.ENOMEM,\n        description: 'not enough memory/ high virtual memory usage'\n    },\n    {\n        errno: 27,\n        code: ERROR_CODES.ENOTDIR,\n        description: 'not a directory'\n    },\n    {\n        errno: 28,\n        code: ERROR_CODES.EISDIR,\n        description: 'illegal operation on a directory'\n    },\n    {\n        errno: 29,\n        code: ERROR_CODES.ENONET,\n        description: 'machine is not on the network'\n    },\n    {\n        errno: 31,\n        code: ERROR_CODES.ENOTCONN,\n        description: 'socket is not connected'\n    },\n    {\n        errno: 32,\n        code: ERROR_CODES.ENOTSOCK,\n        description: 'socket operation on non-socket'\n    },\n    {\n        errno: 33,\n        code: ERROR_CODES.ENOTSUP,\n        description: 'operation not supported on socket'\n    },\n    {\n        errno: 34,\n        code: ERROR_CODES.ENOENT,\n        description: 'no such file or directory'\n    },\n    {\n        errno: 35,\n        code: ERROR_CODES.ENOSYS,\n        description: 'function not implemented'\n    },\n    {\n        errno: 36,\n        code: ERROR_CODES.EPIPE,\n        description: 'broken pipe'\n    },\n    {\n        errno: 37,\n        code: ERROR_CODES.EPROTO,\n        description: 'protocol error'\n    },\n    {\n        errno: 38,\n        code: ERROR_CODES.EPROTONOSUPPORT,\n        description: 'protocol not supported'\n    },\n    {\n        errno: 39,\n        code: ERROR_CODES.EPROTOTYPE,\n        description: 'protocol wrong type for socket'\n    },\n    {\n        errno: 40,\n        code: ERROR_CODES.ETIMEDOUT,\n        description: 'connection timed out'\n    },\n    {\n        errno: 41,\n        code: ERROR_CODES.ECHARSET,\n        description: 'invalid Unicode character'\n    },\n    {\n        errno: 42,\n        code: ERROR_CODES.EAIFAMNOSUPPORT,\n        description: 'address family for hostname not supported'\n    },\n    {\n        errno: 44,\n        code: ERROR_CODES.EAISERVICE,\n        description: 'servname not supported for ai_socktype'\n    },\n    {\n        errno: 45,\n        code: ERROR_CODES.EAISOCKTYPE,\n        description: 'ai_socktype not supported'\n    },\n    {\n        errno: 46,\n        code: ERROR_CODES.ESHUTDOWN,\n        description: 'cannot send after transport endpoint shutdown'\n    },\n    {\n        errno: 47,\n        code: ERROR_CODES.EEXIST,\n        description: 'file already exists'\n    },\n    {\n        errno: 48,\n        code: ERROR_CODES.ESRCH,\n        description: 'no such process'\n    },\n    {\n        errno: 49,\n        code: ERROR_CODES.ENAMETOOLONG,\n        description: 'name too long'\n    },\n    {\n        errno: 50,\n        code: ERROR_CODES.EPERM,\n        description: 'operation not permitted'\n    },\n    {\n        errno: 51,\n        code: ERROR_CODES.ELOOP,\n        description: 'too many symbolic links encountered'\n    },\n    {\n        errno: 52,\n        code: ERROR_CODES.EXDEV,\n        description: 'cross-device link not permitted'\n    },\n    {\n        errno: 53,\n        code: ERROR_CODES.ENOTEMPTY,\n        description: 'directory not empty'\n    },\n    {\n        errno: 54,\n        code: ERROR_CODES.ENOSPC,\n        description: 'no space left on device'\n    },\n    {\n        errno: 55,\n        code: ERROR_CODES.EIO,\n        description: 'i/o error'\n    },\n    {\n        errno: 56,\n        code: ERROR_CODES.EROFS,\n        description: 'read-only file system'\n    },\n    {\n        errno: 57,\n        code: ERROR_CODES.ENODEV,\n        description: 'no such device'\n    },\n    {\n        errno: 58,\n        code: ERROR_CODES.ESPIPE,\n        description: 'invalid seek'\n    },\n    {\n        errno: 59,\n        code: ERROR_CODES.ECANCELED,\n        description: 'operation canceled'\n    }\n];\n\nlet ERRNO_TO_ERROR_MAP = {};\nlet CODE_TO_ERROR_MAP = {};\n\nALL_ERRORS.forEach(function (error) {\n    ERRNO_TO_ERROR_MAP[error.errno] = error;\n    CODE_TO_ERROR_MAP[error.code] = error;\n});\n\nconst ERR_CODES = {\n    ERROR_CODES: ERROR_CODES,\n    FS_ERROR_CODES: FS_ERROR_CODES,\n    ALL_ERRORS: ALL_ERRORS,\n    ERRNO_TO_ERROR_MAP: ERRNO_TO_ERROR_MAP,\n    CODE_TO_ERROR_MAP: CODE_TO_ERROR_MAP\n};\n\nconst Errors = {};\n[\n    /**\n     * node.js errors - we only use some of these, add as needed.\n     */\n    //'-1:UNKNOWN:unknown error',\n    //'0:OK:success',\n    //'1:EOF:end of file',\n    //'2:EADDRINFO:getaddrinfo error',\n    '3:EACCES:permission denied',\n    //'4:EAGAIN:resource temporarily unavailable',\n    //'5:EADDRINUSE:address already in use',\n    //'6:EADDRNOTAVAIL:address not available',\n    //'7:EAFNOSUPPORT:address family not supported',\n    //'8:EALREADY:connection already in progress',\n    '9:EBADF:bad file descriptor',\n    '10:EBUSY:resource busy or locked',\n    //'11:ECONNABORTED:software caused connection abort',\n    //'12:ECONNREFUSED:connection refused',\n    //'13:ECONNRESET:connection reset by peer',\n    //'14:EDESTADDRREQ:destination address required',\n    //'15:EFAULT:bad address in system call argument',\n    //'16:EHOSTUNREACH:host is unreachable',\n    //'17:EINTR:interrupted system call',\n    '18:EINVAL:invalid argument',\n    //'19:EISCONN:socket is already connected',\n    //'20:EMFILE:too many open files',\n    //'21:EMSGSIZE:message too long',\n    //'22:ENETDOWN:network is down',\n    //'23:ENETUNREACH:network is unreachable',\n    //'24:ENFILE:file table overflow',\n    //'25:ENOBUFS:no buffer space available',\n    //'26:ENOMEM:not enough memory',\n    '27:ENOTDIR:not a directory',\n    '28:EISDIR:illegal operation on a directory',\n    //'29:ENONET:machine is not on the network',\n    // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n    //'31:ENOTCONN:socket is not connected',\n    //'32:ENOTSOCK:socket operation on non-socket',\n    //'33:ENOTSUP:operation not supported on socket',\n    '34:ENOENT:no such file or directory',\n    '35:ENOSYS:function not implemented',\n    //'36:EPIPE:broken pipe',\n    //'37:EPROTO:protocol error',\n    //'38:EPROTONOSUPPORT:protocol not supported',\n    //'39:EPROTOTYPE:protocol wrong type for socket',\n    //'40:ETIMEDOUT:connection timed out',\n    //'41:ECHARSET:invalid Unicode character',\n    //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n    // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n    //'44:EAISERVICE:servname not supported for ai_socktype',\n    //'45:EAISOCKTYPE:ai_socktype not supported',\n    //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n    '47:EEXIST:file already exists',\n    //'48:ESRCH:no such process',\n    //'49:ENAMETOOLONG:name too long',\n    '50:EPERM:operation not permitted',\n    '51:ELOOP:too many symbolic links encountered',\n    //'52:EXDEV:cross-device link not permitted',\n    '53:ENOTEMPTY:directory not empty',\n    //'54:ENOSPC:no space left on device',\n    '55:EIO:i/o error',\n    //'56:EROFS:read-only file system',\n    //'57:ENODEV:no such device',\n    //'58:ESPIPE:invalid seek',\n    //'59:ECANCELED:operation canceled',\n\n    /**\n     * Phoenix/Filer specific errors\n     */\n    '1000:ENOTMOUNTED:not mounted',\n    '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n    '1002:ENOATTR:attribute does not exist'\n\n].forEach(function (e) {\n    e = e.split(':');\n    var errno = +e[0];\n    var errName = e[1];\n    var defaultMessage = e[2];\n\n    function FilerError(msg, path) {\n        Error.call(this);\n\n        this.name = errName;\n        this.code = errName;\n        this.errno = errno;\n        this.message = msg || defaultMessage;\n        if (path) {\n            this.path = path;\n        }\n        this.stack = (new Error(this.message)).stack;\n    }\n\n    FilerError.prototype = Object.create(Error.prototype);\n    FilerError.prototype.constructor = FilerError;\n    FilerError.prototype.toString = function () {\n        var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n        return this.name + ': ' + this.message + pathInfo;\n    };\n\n    // We expose the error as both Errors.EINVAL and Errors[18]\n    Errors[errName] = Errors[errno] = FilerError;\n});\n\n\nmodule.exports = {\n    ERR_CODES: ERR_CODES,\n    Errors: Errors\n};\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n/* jshint ignore:start */\n\nconst Constants = {\n    MOUNT_DEVICE_NAME: 'nativeFsAccess',\n    KIND_FILE: 'file',\n    KIND_DIRECTORY: 'directory',\n    NODE_TYPE_FILE: 'FILE',\n    NODE_TYPE_DIRECTORY: 'DIRECTORY',\n    IDB_RW_TYPE: 'readwrite',\n    MOUNT_POINT_ROOT: '/mnt'\n};\n\nmodule.exports = {\n    Constants: Constants\n};\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global idb*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n/**\n * Persists serialised mounted native file system handles to indexed db to usage across tabs and sessions.\n**/\nimport Constants from './constants.js';\n\nconst PHOENIX_MOUNTS_DB_NAME = 'PHOENIX_MOUNTS';\nconst STORE_NAME = 'FS_ACCESS';\nconst MOUNT_POINTS_KEY = 'MOUNT_POINTS';\nconst VERSION_1 = 1;\n\nlet db = null;\nlet _currentMounts = {};\n\nasync function _ensureDB(){\n    if(db) {\n        return;\n    }\n    db = await idb.openDB(PHOENIX_MOUNTS_DB_NAME, VERSION_1, {\n        upgrade(db) {\n            db.createObjectStore(STORE_NAME);\n        }\n    });\n\n}\n\nasync function addMountPoint(mountName, handle) {\n    await _ensureDB();\n    const tx = db.transaction(STORE_NAME, Constants.IDB_RW_TYPE);\n    const store = tx.objectStore(STORE_NAME);\n    _currentMounts = (await store.get(MOUNT_POINTS_KEY)) || {};\n    _currentMounts[mountName] = handle;\n    await store.put(_currentMounts, MOUNT_POINTS_KEY);\n    await tx.done;\n}\n\nasync function refreshMountPoints() {\n    await _ensureDB();\n    const tx = db.transaction(STORE_NAME, Constants.IDB_RW_TYPE);\n    const store = tx.objectStore(STORE_NAME);\n    _currentMounts = (await store.get(MOUNT_POINTS_KEY)) || {};\n    await tx.done;\n    return _currentMounts;\n}\n\nfunction getMountPoints() {\n    return _currentMounts;\n}\n\nconst MountPointsStore = {\n    addMountPoint,\n    getMountPoints,\n    refreshMountPoints\n};\n\nexport default MountPointsStore;\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global BroadcastChannel*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n\nimport {Errors} from './errno.js';\nimport MountPointsStore from './mount_point_storage.js';\nimport Constants from './constants.js';\n\nconst MOUNT_POINT_CHANGED_NOTIFICATION = 'PHOENIX_MOUNT_POINT_CHANGED_NOTIFICATION';\n\nlet MAX_NUM_MOUNTS = 1000000;\nlet _channel = null;\n\n/**\n * Check if the given path is a subpath of the '/mnt' folder.\n * @param path\n */\nfunction isMountSubPath(path) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    let mntSubPathStart = '/mnt/';\n    if (path) {\n        path = window.path.normalize(path);\n        if (path.startsWith(mntSubPathStart) && path.length > mntSubPathStart.length) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if the given path is '/mnt' folder.\n * @param path\n */\nfunction isMountPath(path) {\n    if (typeof path !== 'string') {\n        return false;\n    }\n    if (path) {\n        path = window.path.normalize(path);\n        if (path === Constants.MOUNT_POINT_ROOT) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nfunction _setupBroadcastChannel() {\n    if(_channel){\n        return;\n    }\n    if(typeof BroadcastChannel === 'undefined'){\n        /* eslint no-console: 0 */\n        console.warn('window.BroadcastChannel not supported. Mount point changes wont reflect across tabs.');\n        return;\n    }\n    _channel = new BroadcastChannel(MOUNT_POINT_CHANGED_NOTIFICATION);\n}\n\nfunction _broadcastMountPointChanged() {\n    _setupBroadcastChannel();\n    _channel.postMessage(MOUNT_POINT_CHANGED_NOTIFICATION);\n}\n\nfunction _listenToMountPointChanges () {\n    _setupBroadcastChannel();\n    _channel.onmessage = async function(event) {\n        if(event.data === MOUNT_POINT_CHANGED_NOTIFICATION) {\n            await MountPointsStore.refreshMountPoints();\n        }\n    };\n}\n\n/**\n * Checks if the given handleToMount is same as or a subdir of all existing mounts\n * @param handleToMount\n * @returns {*[]} array of details of handleToMount relative to existing mount\n * @private\n */\nfunction _resolveFileHandle(handleToMount) {\n    let allMountPointResolutions = [];\n    const currentMounts = MountPointsStore.getMountPoints();\n    for (const [mountName, handle] of Object.entries(currentMounts)) {\n        allMountPointResolutions.push(new Promise((resolve) => {\n            const isSameEntryPromise = handle.isSameEntry(handleToMount);\n            const isSubEntryPromise = handle.resolve(handleToMount);\n            Promise.all([isSameEntryPromise, isSubEntryPromise]).then((mountDetail=>{\n                let isSameEntry = mountDetail[0] || false;\n                let subPathList = mountDetail[1] || [];\n                resolve({\n                    existingMountName: mountName,\n                    isSameEntry: isSameEntry,\n                    subPath: subPathList.join('/')\n                });\n            }));\n        }));\n    }\n    return allMountPointResolutions;\n}\n\nfunction _getPathIfAlreadyMounted(handleToMount) {\n    return new Promise((resolve) => {\n        let allMountPointResolutions = _resolveFileHandle(handleToMount);\n        Promise.all(allMountPointResolutions).then(values => {\n            for(let i=0; i<values.length; i++) {\n                let mountName = values[i].existingMountName;\n                if(values[i].isSameEntry) {\n                    resolve(`${Constants.MOUNT_POINT_ROOT}/${mountName}`);\n                    return;\n                } else if(values[i].subPath.length >= 1) {\n                    resolve(`${Constants.MOUNT_POINT_ROOT}/${mountName}/${values[i].subPath}`);\n                    return;\n                }\n            }\n            resolve(null);\n        });\n    });\n}\n\nfunction _getNewMountName(handleToMount) {\n    let name = handleToMount.name;\n    const currentMounts = MountPointsStore.getMountPoints();\n    if(!currentMounts[name]) {\n        return name;\n    }\n    for(let i=0; i<MAX_NUM_MOUNTS; i++) {\n        let mountName = `${name}_${i}`;\n        if(!currentMounts[mountName]){\n            return mountName;\n        }\n    }\n}\n\n/**\n * If the new handle is the same as or a subdir of an existing mount, we return the existing mount path\n * resolved to the given handle. Eg, if a folder `a` with subdir `b` is mounted to `mnt/a`;if we try to mount subdir `b`\n * then, we will return `mnt/a/b` as `b` is a subdirectory of an already mounted directory.\n * @param handleToMount\n * @param currentMounts {mountName1:handle1, ...}\n * @private\n */\nfunction _mountHandle(handleToMount) {\n    return new Promise(async (resolve, reject) => {\n        let path = await _getPathIfAlreadyMounted(handleToMount);\n        if(path){\n            resolve(path);\n        } else {\n            let mountName = _getNewMountName(handleToMount);\n            if(!mountName) {\n                reject('Mount name not fount');\n            } else {\n                await MountPointsStore.addMountPoint(mountName, handleToMount);\n                resolve(`${Constants.MOUNT_POINT_ROOT}/${mountName}`);\n            }\n        }\n    });\n}\n\nfunction mountNativeFolder(optionalDirHandle, callback) {\n    if(!callback) {\n        callback = optionalDirHandle;\n        optionalDirHandle = null;\n    }\n    let mountedPath = null;\n    let error = null;\n    MountPointsStore.refreshMountPoints()\n        .then(() => optionalDirHandle || window.showDirectoryPicker())\n        .then((directoryHandle) => _mountHandle(directoryHandle))\n        .then( mountPath => mountedPath = mountPath)\n        .then(() => _broadcastMountPointChanged())\n        .catch(function (err) {\n            error = new Errors.ENOTMOUNTED(err);\n        }).finally(()=>{\n            if(callback) {\n                callback(error, [mountedPath]);\n            } else if (error) {\n                throw new Errors.ENOTMOUNTED(error);\n            }\n        });\n}\n\nasync function _findLeafNode(currentNode, pathArray, currentIndex, callback) {\n    let pathLength = pathArray.length;\n    if(currentIndex === pathLength) {\n        callback(null, currentNode);\n    } else {\n        let childName = pathArray[currentIndex];\n        let childDirHandle = null;\n        let childFileHandle = null;\n        try {\n            childDirHandle = await currentNode.getDirectoryHandle(childName);\n        } catch (e) {\n            // do nothing\n        }\n        try {\n            childFileHandle = await currentNode.getFileHandle(childName);\n        } catch (e) {\n            // do nothing\n        }\n\n        if(childFileHandle && currentIndex === pathLength - 1) {\n            // the last node is a file\n            callback(null, childFileHandle);\n        } else if(childDirHandle) {\n            _findLeafNode(childDirHandle, pathArray, currentIndex + 1, callback);\n        } else {\n            let path= pathArray.join('/');\n            callback(new Errors.ENOENT('File/Dir does not exist: ', path));\n        }\n    }\n}\n\nasync function _verifyOrRequestPermission(fileHandle, callback) {\n    const options = {\n        mode: 'read'\n    };\n\n    // Check if permission was already granted. If so, return true.\n    try {\n        let status = await fileHandle.queryPermission(options);\n        if (status === 'granted') {\n            callback(true);\n            return;\n        }\n        status = await fileHandle.requestPermission(options);\n        if (status === 'granted') {\n            callback(true);\n        } else {\n            callback(false);\n        }\n    } catch(e){\n        callback(false);\n    }\n}\n\nfunction getHandleFromPath(normalisedPath, callback) {\n    const pathNodes = normalisedPath.split('/');\n    const currentMounts = MountPointsStore.getMountPoints();\n    if(pathNodes.length < 3 || pathNodes[0] !== '' || pathNodes[1] !== 'mnt'){\n        callback(new Errors.EINVAL('Cannot operate on path ' + normalisedPath));\n    }\n    let mountPoint = currentMounts[pathNodes[2]];\n    if(!mountPoint) {\n        callback(new Errors.ENOENT('Path does not exist: ', normalisedPath));\n        return;\n    }\n    _verifyOrRequestPermission(mountPoint, (permitted)=>{\n        if(permitted){\n            _findLeafNode(mountPoint, pathNodes, 3, callback);\n        } else {\n            callback(new Errors.EACCES('permission denied on path: ' + normalisedPath));\n        }\n    });\n}\n\nasync function getHandleFromPathIfPresent(normalisedPath) {\n    return new Promise(resolve => {\n        getHandleFromPath(normalisedPath, (err, handle) =>{\n            if(err) {\n                resolve(null);\n            } else {\n                resolve(handle);\n            }\n        });\n    });\n}\n\nfunction getMountPoints() {\n    return MountPointsStore.getMountPoints();\n}\n\nfunction refreshMountPoints() {\n    return MountPointsStore.refreshMountPoints();\n}\n\n_listenToMountPointChanges();\n\nconst Mounts = {\n    mountNativeFolder,\n    isMountPath,\n    isMountSubPath,\n    getHandleFromPath,\n    getMountPoints,\n    refreshMountPoints,\n    getHandleFromPathIfPresent\n};\n\nexport default Mounts;\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\nimport Constants from './constants.js';\n\nfunction _dateFromMs(ms) {\n    if(ms === null || ms === undefined){\n        return null;\n    }\n    return new Date(Number(ms));\n}\n\nfunction Stats(path, fileNode, devName) {\n    this.dev = devName;\n    this.node = fileNode.id;\n    this.type = fileNode.type;\n    this.size = fileNode.size;\n    this.nlinks = fileNode.nlinks;\n    // Date objects\n    this.atime = _dateFromMs(fileNode.atime);\n    this.mtime = _dateFromMs(fileNode.mtime);\n    this.ctime = _dateFromMs(fileNode.ctime);\n    // Unix timestamp MS Numbers\n    this.atimeMs = fileNode.atime;\n    this.mtimeMs = fileNode.mtime;\n    this.ctimeMs = fileNode.ctime;\n    this.version = fileNode.version;\n    this.mode = fileNode.mode;\n    this.name = window.path.basename(path);\n}\n\nStats.prototype.isFile = function() {\n    return this.type === Constants.NODE_TYPE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n    return this.type === Constants.NODE_TYPE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n    return this.type === Constants.NODE_TYPE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\n    Stats.prototype.isFIFO            =\n        Stats.prototype.isCharacterDevice =\n            Stats.prototype.isBlockDevice     =\n                function() {\n                    return false;\n                };\n\nfunction _getType(handle) {\n    switch (handle.kind) {\n    case Constants.KIND_FILE: return Constants.NODE_TYPE_FILE;\n    case Constants.KIND_DIRECTORY: return Constants.NODE_TYPE_DIRECTORY;\n    default: return null;\n    }\n}\n\nasync function _getDetails(nativeFsHandle) {\n    let file = null;\n    let details = {};\n    switch (nativeFsHandle.kind) {\n    case Constants.KIND_FILE:\n        file = await nativeFsHandle.getFile();\n        details.size = file.size;\n        details.mtime = file.lastModified;\n        return details;\n    case Constants.KIND_DIRECTORY:\n    default:\n        return details;\n    }\n}\n\nconst createStatObject = async function (path, handle) {\n    let details = await _getDetails(handle);\n    let fileDetails = {\n        type: _getType(handle),\n        size: details.size,\n        mtime: details.mtime\n    };\n    return new Stats(path, fileDetails, Constants.MOUNT_DEVICE_NAME);\n};\n\nconst Utils = {\n    createStatObject\n};\n\nexport default Utils;\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global TextDecoder, buffer*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\nimport Mounts from './fslib_mounts.js';\nimport {Errors} from './errno.js';\nimport Constants from './constants.js';\nimport Utils from './utils.js';\n\n\nasync function _listDir(handle, callback) {\n    let dirEntryNames = [];\n    for await (const [key] of handle.entries()) {\n        dirEntryNames.push(key);\n    }\n    if(callback){\n        callback(null, dirEntryNames);\n    }\n    return dirEntryNames;\n}\n\n\nasync function _mkdir(paretDirHandle, dirName, callback) {\n    try {\n        let childDirHandle = await paretDirHandle.getDirectoryHandle(dirName, { create: true });\n        if(callback){\n            callback(null);\n        }\n        return childDirHandle;\n    } catch (e) {\n        if(callback){\n            callback(new Errors.EIO('Filer native fs function not yet supported.', e));\n        }\n        throw new Errors.EIO('Filer native fs function not yet supported.', e);\n    }\n}\n\n\nfunction mkdir(path, mode, callback) {\n    if (arguments.length < 4) {\n        callback = mode;\n    }\n\n    path = window.path.normalize(path);\n    let dirname= window.path.dirname(path);\n    let subdirName= window.path.basename(path);\n    Mounts.getHandleFromPath(dirname, (err, handle) => {\n        if(err){\n            callback(err);\n        } else if (handle.kind === Constants.KIND_FILE) {\n            callback(new Errors.ENOTDIR('Parent path is not a directory.'));\n        }else {\n            _mkdir(handle, subdirName, callback);\n        }\n    });\n}\n\n\nfunction readdir(path, options, callback) {\n    path = window.path.normalize(path);\n    if (typeof options !== 'function') {\n        throw new Errors.ENOSYS('Filer readdir options are not yet supported');\n    }\n    callback = options;\n\n    if(path === Constants.MOUNT_POINT_ROOT ) {\n        let mountedFolders = Object.keys(Mounts.getMountPoints());\n        callback(null, mountedFolders);\n    } else {\n        Mounts.getHandleFromPath(path, (err, handle) => {\n            if(err){\n                callback(err);\n            } else if (handle.kind === Constants.KIND_FILE) {\n                callback(new Errors.ENOTDIR('Path is not a directory.'));\n            }else {\n                _listDir(handle, callback);\n            }\n        });\n    }\n}\n\nfunction _getDecodedString(buffer, encoding) {\n    try {\n        return new TextDecoder(encoding).decode(buffer);\n    } catch (e) {\n        return null;\n    }\n}\n\nasync function _getFileContents(fileHandle, encoding, callback) {\n    encoding = encoding || 'utf-8';\n    try {\n        let file = await fileHandle.getFile();\n        let buffer = await file.arrayBuffer();\n        if(encoding === BYTE_ARRAY_ENCODING) {\n            callback(null, buffer, encoding);\n            return;\n        }\n        let decodedString = _getDecodedString(buffer, encoding);\n        if(decodedString !== null){\n            callback(null, decodedString, encoding);\n        } else {\n            callback(new Errors.EIO(`Encoding ${encoding} no supported`));\n        }\n    } catch (e) {\n        callback(e);\n    }\n}\n\nfunction _validateFileOptions(options, enc, fileMode){\n    if(!options) {\n        options = { encoding: enc, flag: fileMode };\n    } else if(typeof options === 'function') {\n        options = { encoding: enc, flag: fileMode };\n    } else if(typeof options === 'string') {\n        options = { encoding: options, flag: fileMode };\n    }\n    return options;\n}\n\nfunction readFile(path, options, callback) {\n    path = window.path.normalize(path);\n\n    callback = arguments[arguments.length - 1];\n    options = _validateFileOptions(options, null, 'r');\n\n    Mounts.getHandleFromPath(path, (err, handle) => {\n        if(err){\n            callback(err);\n        } else if (handle.kind === Constants.KIND_DIRECTORY) {\n            callback(new Errors.EISDIR('Path is a directory.'));\n        }else {\n            _getFileContents(handle, options.encoding, callback);\n        }\n    });\n}\n\n\nfunction stat(path, callback) {\n    path = window.path.normalize(path);\n    Mounts.getHandleFromPath(path, (err, handle) => {\n        if(err){\n            callback(err);\n        } else {\n            Utils.createStatObject(path, handle).then(pathStat => {\n                callback(null, pathStat);\n            }).catch( error => {\n                callback(error);\n            });\n        }\n    });\n}\n\n\nasync function _writeFileWithName(paretDirHandle, fileName, encoding, data, callback) {\n    try {\n        const newFileHandle = await paretDirHandle.getFileHandle(fileName, { create: true });\n        const writable = await newFileHandle.createWritable();\n        await writable.write(data);\n        await writable.close();\n        callback(null);\n    } catch (e) {\n        callback(e);\n    }\n}\n\nfunction writeFile (path, data, options, callback) {\n    callback = arguments[arguments.length - 1];\n    options = _validateFileOptions(options, 'utf8', 'w');\n    if(!buffer.Buffer.isBuffer(data)) {\n        if(typeof data === 'number') {\n            data = '' + data;\n        }\n        data = data || '';\n        if(typeof data !== 'string') {\n            data = buffer.Buffer.from(data.toString());\n        } else {\n            data = buffer.Buffer.from(data || '', options.encoding || 'utf8');\n        }\n    }\n\n    path = window.path.normalize(path);\n    let dirname= window.path.dirname(path);\n    let fileName= window.path.basename(path);\n    Mounts.getHandleFromPath(dirname, (err, handle) => {\n        if(err){\n            callback(err);\n        } else if (handle.kind === Constants.KIND_FILE) {\n            callback(new Errors.ENOTDIR('Parent path is not a directory.'));\n        }else {\n            _writeFileWithName(handle, fileName, options.encoding, data, callback);\n        }\n    });\n}\n\nasync function _deleteEntry(dirHandle, entryNameToDelete, callback, recursive=true){\n    try {\n        await dirHandle.removeEntry(entryNameToDelete, { recursive: recursive });\n        callback(null);\n    } catch (err) {\n        callback(err);\n    }\n}\n\nasync function unlink(path, callback) {\n    path = window.path.normalize(path);\n    let dirPath= window.path.dirname(path);\n    let baseName= window.path.basename(path);\n    Mounts.getHandleFromPath(dirPath, async (err, dirHandle) => {\n        if(err){\n            callback(err);\n        } else {\n            _deleteEntry(dirHandle, baseName, callback);\n        }\n    });\n}\n\nasync function _getDestinationHandleForCopy(dst, srcBaseName, handleKindToCreate) {\n    return new Promise(async (resolve, reject) => {\n        dst = window.path.normalize(dst);\n        let dirPath= window.path.dirname(dst);\n        let dstBaseName= window.path.basename(dst);\n        let dstHandle = await Mounts.getHandleFromPathIfPresent(dst);\n        let dstParentHandle = await Mounts.getHandleFromPathIfPresent(dirPath);\n        if (dstHandle && dstHandle.kind === Constants.KIND_FILE) {\n            reject(new Errors.EEXIST(`Destination file already exists: ${dst}`));\n        } else if (dstHandle && dstHandle.kind === Constants.KIND_DIRECTORY\n            && handleKindToCreate === Constants.KIND_FILE) {\n            const fileHandle = await dstHandle.getFileHandle(srcBaseName, {create: true});\n            resolve(fileHandle);\n        } else if (dstHandle && dstHandle.kind === Constants.KIND_DIRECTORY\n            && handleKindToCreate === Constants.KIND_DIRECTORY) {\n            let dstChildHandle = await Mounts.getHandleFromPathIfPresent(`${dst}/${srcBaseName}`);\n            if(dstChildHandle){\n                reject(new Errors.EEXIST(`Copy destination already exists: ${dst}/${srcBaseName}`));\n                return;\n            }\n            const directoryHandle = await dstHandle.getDirectoryHandle(srcBaseName, {create: true});\n            resolve(directoryHandle);\n        } else if (!dstHandle && dstParentHandle && dstParentHandle.kind === Constants.KIND_DIRECTORY\n            && handleKindToCreate === Constants.KIND_FILE) {\n            const fileHandle = await dstParentHandle.getFileHandle(dstBaseName, {create: true});\n            resolve(fileHandle);\n        } else if (!dstHandle && dstParentHandle && dstParentHandle.kind === Constants.KIND_DIRECTORY\n            && handleKindToCreate === Constants.KIND_DIRECTORY) {\n            const fileHandle = await dstParentHandle.getDirectoryHandle(dstBaseName, {create: true});\n            resolve(fileHandle);\n        } else {\n            reject(new Errors.ENOENT(`Copy destination doesnt exist: ${dst}`));\n        }\n    });\n}\n\nasync function _copyFileFromHandles(srcFileHandle, dstHandle, optionalName) {\n    // TODO Add retry mechanisms when copying large folders\n    try {\n        if(optionalName){\n            dstHandle = await dstHandle.getFileHandle(optionalName, {create: true});\n        }\n        const srcFile = await srcFileHandle.getFile();\n        const srcStream = await srcFile.stream();\n        const writable = await dstHandle.createWritable();\n        await srcStream.pipeTo(writable);\n    } catch (e) {\n        console.error(`Error while copying ${dstHandle.name}/${optionalName} : ${e}`);\n        throw e;\n    }\n}\n\nasync function _copyFileWithHandle(srcFileHandle, dst, srcFileName, callback) {\n    try {\n        let dstHandle = await _getDestinationHandleForCopy(dst, srcFileName, Constants.KIND_FILE);\n        await _copyFileFromHandles(srcFileHandle, dstHandle);\n        callback(null);\n    } catch (e) {\n        callback(e);\n    }\n}\n\nasync function _treeCopy(srcFolderHandle, dstFolderHandle, recursive) {\n    let allDonePromises = [];\n    for await (const [key, srcHandle] of srcFolderHandle.entries()) {\n        if (srcHandle.kind === Constants.KIND_FILE) {\n            allDonePromises.push(_copyFileFromHandles(srcHandle, dstFolderHandle, key));\n        } else if (srcHandle.kind === Constants.KIND_DIRECTORY) {\n            const childDirHandle = await _mkdir(dstFolderHandle, key);\n            if(recursive && childDirHandle){\n                allDonePromises.push(_treeCopy(srcHandle, childDirHandle, recursive));\n            }\n        }\n    }\n    await Promise.all(allDonePromises);\n}\n\nasync function _copyFolderWithHandle(srcFolderHandle, dst, srcFileName, callback, recursive) {\n    try {\n        let dstFolderHandle = await _getDestinationHandleForCopy(dst, srcFileName, Constants.KIND_DIRECTORY);\n        await _treeCopy(srcFolderHandle, dstFolderHandle, recursive);\n        callback(null);\n    } catch (e) {\n        callback(e);\n    }\n}\n\nasync function copy(src, dst, callback, recursive = true) {\n    let srcFile = window.path.normalize(src);\n    let srcFileName= window.path.basename(srcFile);\n    Mounts.getHandleFromPath(srcFile, async (err, srcHandle) => {\n        if(err){\n            callback(err);\n        } else if (srcHandle.kind === Constants.KIND_FILE) {\n            return _copyFileWithHandle(srcHandle, dst, srcFileName, callback);\n        } else if (srcHandle.kind === Constants.KIND_DIRECTORY) {\n            return _copyFolderWithHandle(srcHandle, dst, srcFileName, callback, recursive);\n        } else {\n            callback(new Errors.EIO(`Cannot copy src: ${srcFile}`));\n        }\n    });\n}\n\nasync function rename(oldPath, newPath, cb) {\n    copy(oldPath, newPath, err => {\n        if(err) {\n            cb(err);\n        } else {\n            setTimeout(()=>{\n                unlink(oldPath, cb);\n            }, 0);\n        }\n    });\n}\n\nfunction mountNativeFolder(...args) {\n    Mounts.mountNativeFolder(...args);\n}\n\nfunction refreshMountPoints() {\n    Mounts.refreshMountPoints();\n}\n\nconst BYTE_ARRAY_ENCODING = 'byte-array';\n\nconst NativeFS = {\n    mountNativeFolder,\n    refreshMountPoints,\n    mkdir,\n    readdir,\n    stat,\n    readFile,\n    writeFile,\n    unlink,\n    copy,\n    rename,\n    BYTE_ARRAY_ENCODING\n};\n\nexport default NativeFS;\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global BroadcastChannel*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n\nlet _channel = null;\nlet _watchListeners = [];\nlet _globmatch = require('./thirdparty/globmatch');\n\nconst WATCH_EVENT_NOTIFICATION = 'PHOENIX_WATCH_EVENT_NOTIFICATION';\nconst WATCH_EVENT_CREATED = 'created';\nconst WATCH_EVENT_DELETED = 'deleted';\nconst WATCH_EVENT_CHANGED = 'changed';\n\nfunction _setupBroadcastChannel() {\n    if(_channel){\n        return;\n    }\n    if(typeof BroadcastChannel === 'undefined'){\n        /* eslint no-console: 0 */\n        console.warn('window.BroadcastChannel not supported. File system watch events across tabs wont be synced.');\n        return;\n    }\n    _channel = new BroadcastChannel(WATCH_EVENT_NOTIFICATION);\n}\n\nfunction _broadcastWatchEvent(event) {\n    _setupBroadcastChannel();\n    _channel.postMessage(event);\n}\n\nfunction _isAnIgnoredPath(path, ignoreGlobList) {\n    if(ignoreGlobList && ignoreGlobList.length > 0){\n        for (const glob of ignoreGlobList){\n            if (_globmatch(path, glob)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction _isSameOrSubDirectory(parent, child) {\n    return !(window.path.relative(parent, child).startsWith('..'));\n}\n\n// event{ path, eventName}\nfunction _processFsWatchEvent(event, broadcast=true) {\n    if(broadcast){\n        _broadcastWatchEvent(event);\n    }\n    for (const listener of _watchListeners){\n        if(listener.callback\n            && _isSameOrSubDirectory(listener.path, event.path)\n            && !_isAnIgnoredPath(event.path, listener.ignoreGlobList)){\n            listener.callback(event.event, event.parentDirPath, event.entryName, event.path);\n        }\n    }\n}\n\nfunction _listenToExternalFsWatchEvents() {\n    _setupBroadcastChannel();\n    _channel.onmessage = async function(event) {\n        console.log('External fs watch event: ', event.data);\n        _processFsWatchEvent(event.data, false);\n    };\n}\n\nfunction watch(path, ignoreGlobList, changeCallback, callback) {\n    if(changeCallback){\n        _watchListeners.push({\n            path: path,\n            ignoreGlobList: ignoreGlobList,\n            callback: changeCallback\n        });\n    }\n    callback();\n}\n\nfunction _triggerEvent(path, eventType) {\n    let pathLib = window.path;\n    path = pathLib.normalize(path);\n    let event = {\n        event: eventType,\n        parentDirPath: `${pathLib.dirname(path)}/`,\n        entryName: pathLib.basename(path),\n        path: path\n    };\n    _processFsWatchEvent(event);\n}\n\nfunction reportUnlinkEvent(path) {\n    _triggerEvent(path, WATCH_EVENT_DELETED);\n}\n\nfunction reportChangeEvent(path) {\n    _triggerEvent(path, WATCH_EVENT_CHANGED);\n}\n\nfunction reportCreateEvent(path) {\n    _triggerEvent(path, WATCH_EVENT_CREATED);\n}\n\nfunction unwatch(path, callback) {\n    _watchListeners = _watchListeners.filter(function (item) {\n        return item.path !== path;\n    });\n    callback();\n}\n\nfunction unwatchAll(callback) {\n    _watchListeners =[];\n    callback();\n}\n\n_listenToExternalFsWatchEvents();\n\nconst FsWatch = {\n    watch,\n    unwatch,\n    unwatchAll,\n    reportUnlinkEvent,\n    reportChangeEvent,\n    reportCreateEvent\n};\n\nexport default FsWatch;\n","// This is a slightly modified version of the minimatch library\n// https://github.com/isaacs/minimatch\n// (MIT-licensed, Copyright 2009-2011 Isaac Z. Schlueter)\n//\n// It has been modified to work properly with RequireJS and\n// to export an fnmatch function adapted from the EditorConfig project:\n// https://github.com/editorconfig/editorconfig-core-js/\n// (MIT-licensed, Copyright 2012 EditorConfig Team)\n\n\ndefine(function (r, exports, module, platform) {\n\n    module.exports = fnmatch;\n    minimatch.Minimatch = Minimatch;\n    \n    function fnmatch(filepath, glob) {\n        var matchOptions = {dot: true, noext: true};\n  \n        // brackets #7374: don't try to match base if a directory name is passed in\n        if (filepath[filepath.length - 1] !== '/') {\n            matchOptions.matchBase = true;\n        }\n  \n        glob = glob.replace(/\\*\\*/g, '{*,**/**/**}');\n        return minimatch(filepath, glob, matchOptions);\n    }\n\n    var LRU = function LRUCache () {\n        // not quite an LRU, but still space-limited.\n            var cache = {};\n            var cnt = 0;\n            this.set = function (k, v) {\n                cnt ++;\n                if (cnt >= 100) cache = {};\n                cache[k] = v;\n            };\n            this.get = function (k) { return cache[k]; };\n        }\n        , cache = minimatch.cache = new LRU({max: 100})\n        , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n        , sigmund = function sigmund (obj) {\n            return JSON.stringify(obj);\n        };\n\n    var path = { basename: function (f) {\n            f = f.split(/[\\/\\\\]/);\n            var e = f.pop();\n            if (!e) e = f.pop();\n            return e;\n        }}\n        // any single thing other than /\n        // don't need to escape / when using new RegExp()\n        , qmark = '[^/]'\n\n        // * => any number of characters\n        , star = qmark + '*?'\n\n        // ** when dots are allowed.  Anything goes, except .. and .\n        // not (^ or / followed by one or two dots followed by $ or /),\n        // followed by anything, any number of times.\n        , twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n        // not a ^ or / followed by a dot,\n        // followed by anything, any number of times.\n        , twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n        // characters that need to be escaped in RegExp.\n        , reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n    // \"abc\" -> { a:true, b:true, c:true }\n    function charSet (s) {\n        return s.split('').reduce(function (set, c) {\n            set[c] = true;\n            return set;\n        }, {});\n    }\n\n    // normalizes slashes.\n    var slashSplit = /\\/+/;\n\n    minimatch.monkeyPatch = monkeyPatch;\n    function monkeyPatch () {\n        var desc = Object.getOwnPropertyDescriptor(String.prototype, 'match');\n        var orig = desc.value;\n        desc.value = function (p) {\n            if (p instanceof Minimatch) return p.match(this);\n            return orig.call(this, p);\n        };\n        Object.defineProperty(String.prototype, desc);\n    }\n\n    minimatch.filter = filter;\n    function filter (pattern, options) {\n        options = options || {};\n        return function (p, i, list) {\n            return minimatch(p, pattern, options);\n        };\n    }\n\n    function ext (a, b) {\n        a = a || {};\n        b = b || {};\n        var t = {};\n        Object.keys(b).forEach(function (k) {\n            t[k] = b[k];\n        });\n        Object.keys(a).forEach(function (k) {\n            t[k] = a[k];\n        });\n        return t;\n    }\n\n    minimatch.defaults = function (def) {\n        if (!def || !Object.keys(def).length) return minimatch;\n\n        var orig = minimatch;\n\n        var m = function minimatch (p, pattern, options) {\n            return orig.minimatch(p, pattern, ext(def, options));\n        };\n\n        m.Minimatch = function Minimatch (pattern, options) {\n            return new orig.Minimatch(pattern, ext(def, options));\n        };\n\n        return m;\n    };\n\n    Minimatch.defaults = function (def) {\n        if (!def || !Object.keys(def).length) return Minimatch;\n        return minimatch.defaults(def).Minimatch;\n    };\n\n\n    function minimatch (p, pattern, options) {\n        if (typeof pattern !== 'string') {\n            throw new TypeError('glob pattern string required');\n        }\n\n        if (!options) options = {};\n\n        // shortcut: comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            return false;\n        }\n\n        // \"\" only matches \"\"\n        if (pattern.trim() === '') return p === '';\n\n        return new Minimatch(pattern, options).match(p);\n    }\n\n    function Minimatch (pattern, options) {\n        if (!(this instanceof Minimatch)) {\n            return new Minimatch(pattern, options, cache);\n        }\n\n        if (typeof pattern !== 'string') {\n            throw new TypeError('glob pattern string required');\n        }\n\n        if (!options) options = {};\n        pattern = pattern.trim();\n\n        // windows: need to use /, not \\\n        // On other platforms, \\ is a valid (albeit bad) filename char.\n        if (platform === 'win32') {\n            pattern = pattern.split('\\\\').join('/');\n        }\n\n        // lru storage.\n        // these things aren't particularly big, but walking down the string\n        // and turning it into a regexp can get pretty costly.\n        var cacheKey = pattern + '\\n' + sigmund(options);\n        var cached = minimatch.cache.get(cacheKey);\n        if (cached) return cached;\n        minimatch.cache.set(cacheKey, this);\n\n        this.options = options;\n        this.set = [];\n        this.pattern = pattern;\n        this.regexp = null;\n        this.negate = false;\n        this.comment = false;\n        this.empty = false;\n\n        // make the set of regexps etc.\n        this.make();\n    }\n\n    Minimatch.prototype.make = make;\n    function make () {\n        // don't do it more than once.\n        if (this._made) return;\n\n        var pattern = this.pattern;\n        var options = this.options;\n\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n\n        // step 2: expand braces\n        var set = this.globSet = this.braceExpand();\n\n        if (options.debug) console.error(this.pattern, set);\n\n        // step 3: now we have a set, so turn each one into a series of path-portion\n        // matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        set = this.globParts = set.map(function (s) {\n            return s.split(slashSplit);\n        });\n\n        if (options.debug) console.error(this.pattern, set);\n\n        // glob --> regexps\n        set = set.map(function (s, si, set) {\n            return s.map(this.parse, this);\n        }, this);\n\n        if (options.debug) console.error(this.pattern, set);\n\n        // filter out everything that didn't compile properly.\n        set = set.filter(function (s) {\n            return -1 === s.indexOf(false);\n        });\n\n        if (options.debug) console.error(this.pattern, set);\n\n        this.set = set;\n    }\n\n    Minimatch.prototype.parseNegate = parseNegate;\n    function parseNegate () {\n        var pattern = this.pattern\n            , negate = false\n            , options = this.options\n            , negateOffset = 0;\n\n        if (options.nonegate) return;\n\n        for ( var i = 0, l = pattern.length\n            ; i < l && pattern.charAt(i) === '!'\n            ; i ++) {\n            negate = !negate;\n            negateOffset ++;\n        }\n\n        if (negateOffset) this.pattern = pattern.substr(negateOffset);\n        this.negate = negate;\n    }\n\n    // Brace expansion:\n    // a{b,c}d -> abd acd\n    // a{b,}c -> abc ac\n    // a{0..3}d -> a0d a1d a2d a3d\n    // a{b,c{d,e}f}g -> abg acdfg acefg\n    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n    //\n    // Invalid sets are not expanded.\n    // a{2..}b -> a{2..}b\n    // a{b}c -> a{b}c\n    minimatch.braceExpand = function (pattern, options) {\n        return new Minimatch(pattern, options).braceExpand();\n    };\n\n    Minimatch.prototype.braceExpand = braceExpand;\n    function braceExpand (pattern, options) {\n        options = options || this.options;\n        pattern = typeof pattern === 'undefined'\n            ? this.pattern : pattern;\n\n        if (typeof pattern === 'undefined') {\n            throw new Error('undefined pattern');\n        }\n\n        if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n            // shortcut. no need to expand.\n            return [pattern];\n        }\n\n        var escaping = false;\n\n        // examples and comments refer to this crazy pattern:\n        // a{b,c{d,e},{f,g}h}x{y,z}\n        // expected:\n        // abxy\n        // abxz\n        // acdxy\n        // acdxz\n        // acexy\n        // acexz\n        // afhxy\n        // afhxz\n        // aghxy\n        // aghxz\n\n        // everything before the first \\{ is just a prefix.\n        // So, we pluck that off, and work with the rest,\n        // and then prepend it to everything we find.\n        if (pattern.charAt(0) !== '{') {\n            // console.error(pattern)\n            var prefix = null;\n            for (var i = 0, l = pattern.length; i < l; i ++) {\n                var c = pattern.charAt(i);\n                // console.error(i, c)\n                if (c === '\\\\') {\n                    escaping = !escaping;\n                } else if (c === '{' && !escaping) {\n                    prefix = pattern.substr(0, i);\n                    break;\n                }\n            }\n\n            // actually no sets, all { were escaped.\n            if (prefix === null) {\n                // console.error(\"no sets\")\n                return [pattern];\n            }\n\n            var tail = braceExpand(pattern.substr(i), options);\n            return tail.map(function (t) {\n                return prefix + t;\n            });\n        }\n\n        // now we have something like:\n        // {b,c{d,e},{f,g}h}x{y,z}\n        // walk through the set, expanding each part, until\n        // the set ends.  then, we'll expand the suffix.\n        // If the set only has a single member, then'll put the {} back\n\n        // first, handle numeric sets, since they're easier\n        var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/);\n        if (numset) {\n            // console.error(\"numset\", numset[1], numset[2])\n            var suf = braceExpand(pattern.substr(numset[0].length), options)\n                , start = +numset[1]\n                , end = +numset[2]\n                , inc = start > end ? -1 : 1\n                , set = [];\n            for (var i = start; i != (end + inc); i += inc) {\n                // append all the suffixes\n                for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n                    set.push(i + suf[ii]);\n                }\n            }\n            return set;\n        }\n\n        // ok, walk through the set\n        // We hope, somewhat optimistically, that there\n        // will be a } at the end.\n        // If the closing brace isn't found, then the pattern is\n        // interpreted as braceExpand(\"\\\\\" + pattern) so that\n        // the leading \\{ will be interpreted literally.\n        var i = 1 // skip the \\{\n            , depth = 1\n            , set = []\n            , member = ''\n            , sawEnd = false\n            , escaping = false;\n\n        function addMember () {\n            set.push(member);\n            member = '';\n        }\n\n        // console.error(\"Entering for\")\n        FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n            var c = pattern.charAt(i);\n            // console.error(\"\", i, c)\n\n            if (escaping) {\n                escaping = false;\n                member += '\\\\' + c;\n            } else {\n                switch (c) {\n                case '\\\\':\n                    escaping = true;\n                    continue;\n\n                case '{':\n                    depth ++;\n                    member += '{';\n                    continue;\n\n                case '}':\n                    depth --;\n                    // if this closes the actual set, then we're done\n                    if (depth === 0) {\n                        addMember();\n                        // pluck off the close-brace\n                        i ++;\n                        break FOR;\n                    } else {\n                        member += c;\n                        continue;\n                    }\n\n                case ',':\n                    if (depth === 1) {\n                        addMember();\n                    } else {\n                        member += c;\n                    }\n                    continue;\n\n                default:\n                    member += c;\n                    continue;\n                } // switch\n            } // else\n        } // for\n\n        // now we've either finished the set, and the suffix is\n        // pattern.substr(i), or we have *not* closed the set,\n        // and need to escape the leading brace\n        if (depth !== 0) {\n            // console.error(\"didn't close\", pattern)\n            return braceExpand('\\\\' + pattern, options);\n        }\n\n        // x{y,z} -> [\"xy\", \"xz\"]\n        // console.error(\"set\", set)\n        // console.error(\"suffix\", pattern.substr(i))\n        var suf = braceExpand(pattern.substr(i), options);\n        // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n        //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n        var addBraces = set.length === 1;\n        // console.error(\"set pre-expanded\", set)\n        set = set.map(function (p) {\n            return braceExpand(p, options);\n        });\n        // console.error(\"set expanded\", set)\n\n\n        // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n        //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n        set = set.reduce(function (l, r) {\n            return l.concat(r);\n        });\n\n        if (addBraces) {\n            set = set.map(function (s) {\n                return '{' + s + '}';\n            });\n        }\n\n        // now attach the suffixes.\n        var ret = [];\n        for (var i = 0, l = set.length; i < l; i ++) {\n            for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n                ret.push(set[i] + suf[ii]);\n            }\n        }\n        return ret;\n    }\n\n    // parse a component of the expanded set.\n    // At this point, no pattern may contain \"/\" in it\n    // so we're going to return a 2d array, where each entry is the full\n    // pattern, split on '/', and then turned into a regular expression.\n    // A regexp is made at the end which joins each array with an\n    // escaped /, and another full one which joins each regexp with |.\n    //\n    // Following the lead of Bash 4.1, note that \"**\" only has special meaning\n    // when it is the *only* thing in a path portion.  Otherwise, any series\n    // of * is equivalent to a single *.  Globstar behavior is enabled by\n    // default, and can be disabled by setting options.noglobstar.\n    Minimatch.prototype.parse = parse;\n    var SUBPARSE = {};\n    function parse (pattern, isSub) {\n        var options = this.options;\n\n        // shortcuts\n        if (!options.noglobstar && pattern === '**') return GLOBSTAR;\n        if (pattern === '') return '';\n\n        var re = ''\n            , hasMagic = !!options.nocase\n            , escaping = false\n            // ? => one single character\n            , patternListStack = []\n            , plType\n            , stateChar\n            , inClass = false\n            , reClassStart = -1\n            , classStart = -1\n            // . and .. never match anything that doesn't start with .,\n            // even when options.dot is set.\n            , patternStart = pattern.charAt(0) === '.' ? '' // anything\n            // not (start or / followed by . or .. followed by / or end)\n                : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n                    : '(?!\\\\.)';\n\n        function clearStateChar () {\n            if (stateChar) {\n                // we had some state-tracking character\n                // that wasn't consumed by this pass.\n                switch (stateChar) {\n                case '*':\n                    re += star;\n                    hasMagic = true;\n                    break;\n                case '?':\n                    re += qmark;\n                    hasMagic = true;\n                    break;\n                default:\n                    re += '\\\\'+stateChar;\n                    break;\n                }\n                stateChar = false;\n            }\n        }\n\n        for ( var i = 0, len = pattern.length, c\n            ; (i < len) && (c = pattern.charAt(i))\n            ; i ++ ) {\n\n            if (options.debug) {\n                console.error('%s\\t%s %s %j', pattern, i, re, c);\n            }\n\n            // skip over any that are escaped.\n            if (escaping && reSpecials[c]) {\n                re += '\\\\' + c;\n                escaping = false;\n                continue;\n            }\n\n            switch (c) {\n            case '/':\n                // completely not allowed, even escaped.\n                // Should already be path-split by now.\n                return false;\n\n            case '\\\\':\n                clearStateChar();\n                escaping = true;\n                continue;\n\n                // the various stateChar values\n                // for the \"extglob\" stuff.\n            case '?':\n            case '*':\n            case '+':\n            case '@':\n            case '!':\n                if (options.debug) {\n                    console.error('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n                }\n\n                // all of those are literals inside a class, except that\n                // the glob [!a] means [^a] in regexp\n                if (inClass) {\n                    if (c === '!' && i === classStart + 1) c = '^';\n                    re += c;\n                    continue;\n                }\n\n                // if we already have a stateChar, then it means\n                // that there was something like ** or +? in there.\n                // Handle the stateChar, then proceed with this one.\n                clearStateChar();\n                stateChar = c;\n                // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                // just clear the statechar *now*, rather than even diving into\n                // the patternList stuff.\n                if (options.noext) clearStateChar();\n                continue;\n\n            case '(':\n                if (inClass) {\n                    re += '(';\n                    continue;\n                }\n\n                if (!stateChar) {\n                    re += '\\\\(';\n                    continue;\n                }\n\n                plType = stateChar;\n                patternListStack.push({ type: plType\n                    , start: i - 1\n                    , reStart: re.length });\n                // negation is (?:(?!js)[^/]*)\n                re += stateChar === '!' ? '(?:(?!' : '(?:';\n                stateChar = false;\n                continue;\n\n            case ')':\n                if (inClass || !patternListStack.length) {\n                    re += '\\\\)';\n                    continue;\n                }\n\n                hasMagic = true;\n                re += ')';\n                plType = patternListStack.pop().type;\n                // negation is (?:(?!js)[^/]*)\n                // The others are (?:<pattern>)<type>\n                switch (plType) {\n                case '!':\n                    re += '[^/]*?)';\n                    break;\n                case '?':\n                case '+':\n                case '*': re += plType;\n                case '@': break; // the default anyway\n                }\n                continue;\n\n            case '|':\n                if (inClass || !patternListStack.length || escaping) {\n                    re += '\\\\|';\n                    escaping = false;\n                    continue;\n                }\n\n                re += '|';\n                continue;\n\n                // these are mostly the same in regexp and glob\n            case '[':\n                // swallow any state-tracking char before the [\n                clearStateChar();\n\n                if (inClass) {\n                    re += '\\\\' + c;\n                    continue;\n                }\n\n                inClass = true;\n                classStart = i;\n                reClassStart = re.length;\n                re += c;\n                continue;\n\n            case ']':\n                //  a right bracket shall lose its special\n                //  meaning and represent itself in\n                //  a bracket expression if it occurs\n                //  first in the list.  -- POSIX.2 2.8.3.2\n                if (i === classStart + 1 || !inClass) {\n                    re += '\\\\' + c;\n                    escaping = false;\n                    continue;\n                }\n\n                // finish up the class.\n                hasMagic = true;\n                inClass = false;\n                re += c;\n                continue;\n\n            default:\n                // swallow any state char that wasn't consumed\n                clearStateChar();\n\n                if (escaping) {\n                    // no need\n                    escaping = false;\n                } else if (reSpecials[c]\n                   && !(c === '^' && inClass)) {\n                    re += '\\\\';\n                }\n\n                re += c;\n\n            } // switch\n        } // for\n\n\n        // handle the case where we left a class open.\n        // \"[abc\" is valid, equivalent to \"\\[abc\"\n        if (inClass) {\n            // split where the last [ was, and escape it\n            // this is a huge pita.  We now have to re-walk\n            // the contents of the would-be class to re-translate\n            // any characters that were passed through as-is\n            var cs = pattern.substr(classStart + 1)\n                , sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n            hasMagic = hasMagic || sp[1];\n        }\n\n        // handle the case where we had a +( thing at the *end*\n        // of the pattern.\n        // each pattern list stack adds 3 chars, and we need to go through\n        // and escape any | chars that were passed through as-is for the regexp.\n        // Go through and escape them, taking care not to double-escape any\n        // | chars that were already escaped.\n        var pl;\n        while (pl = patternListStack.pop()) {\n            var tail = re.slice(pl.reStart + 3);\n            // maybe some even number of \\, then maybe 1 \\, followed by a |\n            tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n                if (!$2) {\n                    // the | isn't already escaped, so escape it.\n                    $2 = '\\\\';\n                }\n\n                // need to escape all those slashes *again*, without escaping the\n                // one that we need for escaping the | character.  As it works out,\n                // escaping an even number of slashes can be done by simply repeating\n                // it exactly after itself.  That's why this trick works.\n                //\n                // I am sorry that you have to see this.\n                return $1 + $1 + $2 + '|';\n            });\n\n            // console.error(\"tail=%j\\n   %s\", tail, tail)\n            var t = pl.type === '*' ? star\n                : pl.type === '?' ? qmark\n                    : '\\\\' + pl.type;\n\n            hasMagic = true;\n            re = re.slice(0, pl.reStart)\n       + t + '\\\\('\n       + tail;\n        }\n\n        // handle trailing things that only matter at the very end.\n        clearStateChar();\n        if (escaping) {\n            // trailing \\\\\n            re += '\\\\\\\\';\n        }\n\n        // only need to apply the nodot start if the re starts with\n        // something that could conceivably capture a dot\n        var addPatternStart = false;\n        switch (re.charAt(0)) {\n        case '.':\n        case '[':\n        case '(': addPatternStart = true;\n        }\n\n        // if the re is not \"\" at this point, then we need to make sure\n        // it doesn't match against an empty path part.\n        // Otherwise a/* will match a/, which it should not.\n        if (re !== '' && hasMagic) re = '(?=.)' + re;\n\n        if (addPatternStart) re = patternStart + re;\n\n        // parsing just a piece of a larger pattern.\n        if (isSub === SUBPARSE) {\n            return [ re, hasMagic ];\n        }\n\n        // skip the regexp for non-magical patterns\n        // unescape anything in it, though, so that it'll be\n        // an exact match against a file etc.\n        if (!hasMagic) {\n            return globUnescape(pattern);\n        }\n\n        var flags = options.nocase ? 'i' : ''\n            , regExp = new RegExp('^' + re + '$', flags);\n\n        regExp._glob = pattern;\n        regExp._src = re;\n\n        return regExp;\n    }\n\n    minimatch.makeRe = function (pattern, options) {\n        return new Minimatch(pattern, options || {}).makeRe();\n    };\n\n    Minimatch.prototype.makeRe = makeRe;\n    function makeRe () {\n        if (this.regexp || this.regexp === false) return this.regexp;\n\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        var set = this.set;\n\n        if (!set.length) return this.regexp = false;\n        var options = this.options;\n\n        var twoStar = options.noglobstar ? star\n                : options.dot ? twoStarDot\n                    : twoStarNoDot\n            , flags = options.nocase ? 'i' : '';\n\n        var re = set.map(function (pattern) {\n            return pattern.map(function (p) {\n                return (p === GLOBSTAR) ? twoStar\n                    : (typeof p === 'string') ? regExpEscape(p)\n                        : p._src;\n            }).join('\\\\\\/');\n        }).join('|');\n\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^(?:' + re + ')$';\n\n        // can match anything, as long as it's not this.\n        if (this.negate) re = '^(?!' + re + ').*$';\n\n        try {\n            return this.regexp = new RegExp(re, flags);\n        } catch (ex) {\n            return this.regexp = false;\n        }\n    }\n\n    minimatch.match = function (list, pattern, options) {\n        var mm = new Minimatch(pattern, options);\n        list = list.filter(function (f) {\n            return mm.match(f);\n        });\n        if (options.nonull && !list.length) {\n            list.push(pattern);\n        }\n        return list;\n    };\n\n    Minimatch.prototype.match = match;\n    function match (f, partial) {\n        // console.error(\"match\", f, this.pattern)\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) return false;\n        if (this.empty) return f === '';\n\n        if (f === '/' && partial) return true;\n\n        var options = this.options;\n\n        // windows: need to use /, not \\\n        // On other platforms, \\ is a valid (albeit bad) filename char.\n        if (platform === 'win32') {\n            f = f.split('\\\\').join('/');\n        }\n\n        // treat the test path as a set of pathparts.\n        f = f.split(slashSplit);\n        if (options.debug) {\n            console.error(this.pattern, 'split', f);\n        }\n\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n\n        var set = this.set;\n        // console.error(this.pattern, \"set\", set)\n\n        for (var i = 0, l = set.length; i < l; i ++) {\n            var pattern = set[i];\n            var hit = this.matchOne(f, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) return true;\n                return !this.negate;\n            }\n        }\n\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) return false;\n        return this.negate;\n    }\n\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    Minimatch.prototype.matchOne = function (file, pattern, partial) {\n        var options = this.options;\n\n        if (options.debug) {\n            console.error('matchOne',\n                { 'this': this\n                    , file: file\n                    , pattern: pattern });\n        }\n\n        if (options.matchBase && pattern.length === 1) {\n            file = path.basename(file.join('/')).split('/');\n        }\n\n        if (options.debug) {\n            console.error('matchOne', file.length, pattern.length);\n        }\n\n        for ( var fi = 0\n            , pi = 0\n            , fl = file.length\n            , pl = pattern.length\n            ; (fi < fl) && (pi < pl)\n            ; fi ++, pi ++ ) {\n\n            if (options.debug) {\n                console.error('matchOne loop');\n            }\n            var p = pattern[pi]\n                , f = file[fi];\n\n            if (options.debug) {\n                console.error(pattern, p, f);\n            }\n\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            if (p === false) return false;\n\n            if (p === GLOBSTAR) {\n                if (options.debug)\n                    console.error('GLOBSTAR', [pattern, p, f]);\n\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi\n                    , pr = pi + 1;\n                if (pr === pl) {\n                    if (options.debug)\n                        console.error('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for ( ; fi < fl; fi ++) {\n                        if (file[fi] === '.' || file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')) return false;\n                    }\n                    return true;\n                }\n\n                // ok, let's see if we can swallow whatever we can.\n                WHILE: while (fr < fl) {\n                    var swallowee = file[fr];\n\n                    if (options.debug) {\n                        console.error('\\nglobstar while',\n                            file, fr, pattern, pr, swallowee);\n                    }\n\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        if (options.debug)\n                            console.error('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' || swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')) {\n                            if (options.debug)\n                                console.error('dot detected!', file, fr, pattern, pr);\n                            break WHILE;\n                        }\n\n                        // ** swallows a segment, and continue.\n                        if (options.debug)\n                            console.error('globstar swallow a segment, and continue');\n                        fr ++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                // If there's more *pattern* left, then \n                if (partial) {\n                    // ran out of file\n                    // console.error(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n                    if (fr === fl) return true;\n                }\n                return false;\n            }\n\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            var hit;\n            if (typeof p === 'string') {\n                if (options.nocase) {\n                    hit = f.toLowerCase() === p.toLowerCase();\n                } else {\n                    hit = f === p;\n                }\n                if (options.debug) {\n                    console.error('string match', p, f, hit);\n                }\n            } else {\n                hit = f.match(p);\n                if (options.debug) {\n                    console.error('pattern match', p, f, hit);\n                }\n            }\n\n            if (!hit) return false;\n        }\n\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');\n            return emptyFileEnd;\n        }\n\n        // should be unreachable.\n        throw new Error('wtf?');\n    };\n\n\n    // replace stuff like \\* with *\n    function globUnescape (s) {\n        return s.replace(/\\\\(.)/g, '$1');\n    }\n\n\n    function regExpEscape (s) {\n        return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    }\n\n});","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global fs*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n\nconst {ERR_CODES, Errors} = require('./errno');\n\nconst ERROR_CODES = ERR_CODES.ERROR_CODES;\n\nasync function _stat(path) {\n    return new Promise(async (resolve, reject) => {\n        fs.stat(path, async (err, stat) => {\n            if(err && err.code === ERROR_CODES.ENOENT){\n                resolve(null);\n            } else if(err) {\n                reject(err);\n            } else {\n                resolve(stat);\n            }\n        });\n    });\n}\n\nasync function _mrdirIfNotPresent(path) {\n    return new Promise(async (resolve, reject) => {\n        fs.mkdir(path, async (err) => {\n            err && err.code !== ERROR_CODES.EEXIST?\n                reject(err):\n                resolve();\n        });\n    });\n}\n\nasync function _readDir(path) {\n    return new Promise(async (resolve, reject) => {\n        fs.readdir(path, async (err, listing) => {\n            if(err) {\n                reject(err);\n            } else {\n                resolve(listing);\n            }\n        });\n    });\n}\n\nasync function _copyFileContents(src, dst) {\n    return new Promise(async (resolve, reject) => {\n        fs.readFile(src, async (err, data) => {\n            if(err) {\n                reject(err);\n            } else {\n                fs.writeFile(dst, data, function (writeErr) {\n                    writeErr?\n                        reject(writeErr):\n                        resolve();\n                });\n            }\n        });\n    });\n}\n\nasync function _copyFile(srcFile, dst) {\n    let dstStat = await _stat(dst);\n    if(!dstStat){\n        let parentDir= window.path.dirname(dst);\n        let dstFileName= window.path.basename(dst);\n        dstStat = await _stat(parentDir);\n        if(dstStat && dstStat.isDirectory()){\n            let dstFilePath =`${parentDir}/${dstFileName}`;\n            await _copyFileContents(srcFile, dstFilePath);\n            return;\n        } else {\n            throw new Errors.EIO(`_copyFile Cannot create destination file: ${dst}`);\n        }\n    }\n\n    let srcFileName= window.path.basename(srcFile);\n    if(dstStat && dstStat.isDirectory()){\n        let dstFilePath =`${dst}/${srcFileName}`;\n        await _copyFileContents(srcFile, dstFilePath);\n    } else if(dstStat && dstStat.isFile()){\n        throw new Errors.EEXIST(`_copyFile Destination file already exists: ${dst}`);\n    } else {\n        throw new Errors.EIO(`_copyFile Cannot copy file, unknown destination: ${srcFile} to ${dst}`);\n    }\n}\n\nasync function _copyTree(src, dst) {\n    let srcEntries = await _readDir(src);\n    for(let entry of srcEntries){\n        let entryPath = `${src}/${entry}`;\n        let dstPath = `${dst}/${entry}`;\n        let srcStat = await _stat(entryPath);\n        if(srcStat.isFile()){\n            await _copyFileContents(entryPath, dstPath);\n        } else { //dir\n            await _mrdirIfNotPresent(dstPath);\n            await _copyTree(entryPath, dstPath);\n        }\n    }\n}\n\nasync function _copyFolder(srcFolder, dst) {\n    let dstStat = await _stat(dst);\n    if(dstStat && dstStat.isFile()){\n        throw new Errors.EEXIST(`Destination file already exists: ${dst}`);\n    } else if(dstStat && dstStat.isDirectory()){\n        await _copyTree(srcFolder, dst);\n    } else {\n        throw new Errors.ENONET(`Destination folder does not exist: ${dst}`);\n    }\n}\n\nasync function copy(src, dst, callback) {\n    try {\n        let srcStat = await _stat(src);\n        if(!srcStat){\n            callback(new Errors.EIO(`Cannot copy src: ${src}`));\n            return;\n        }\n        if (srcStat.isFile()) {\n            await _copyFile(src, dst);\n            callback(null);\n        } else if (srcStat.isDirectory()) {\n            await _copyFolder(src, dst);\n            callback(null);\n        }\n    } catch (e) {\n        callback(new Errors.EIO(`${e}: Cannot copy src: ${src} to ${dst}`));\n    }\n}\n\nfunction filerCopy(src, dst, cb) {\n    copy(window.path.normalize(src), window.path.normalize(dst), cb);\n}\n\nexport default filerCopy;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*global process*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\nimport ERR_CODES, {Errors} from './errno.js';\nimport NativeFS from './fslib_native.js';\nimport Constants from './constants.js';\nimport Mounts from './fslib_mounts.js';\nimport FsWatch from './fslib_watch.js';\nimport filerCopy from './filerlib_copy.js';\n\nlet filerLib = null;\nlet filerShell = null;\n\n/**\n * Offers functionality similar to mkdir -p\n *\n * Asynchronous operation. No arguments other than a possible exception\n * are given to the completion callback.\n */\nfunction mkdir_p (fsLib, path, mode, callback, position) {\n    const osSep = '/';\n    const parts = filerLib.path.normalize(path).split(osSep);\n\n    mode = mode || process.umask();\n    position = position || 0;\n\n    if (position >= parts.length) {\n        return callback(null);\n    }\n\n    var directory = parts.slice(0, position + 1).join(osSep) || osSep;\n    fsLib.stat(directory, function(err) {\n        if (err === null) {\n            mkdir_p(fsLib, path, mode, callback, position + 1);\n        } else {\n            fsLib.mkdir(directory, mode, function (error) {\n                if (error && error.code !== 'EEXIST') {\n                    return callback(error);\n                } else {\n                    mkdir_p(fsLib, path, mode, callback, position + 1);\n                }\n            });\n        }\n    });\n}\n\nfunction _ensure_mount_directory() {\n    fileSystemLib.mkdirs(Constants.MOUNT_POINT_ROOT);\n    NativeFS.refreshMountPoints();\n}\n\nfunction _getFirstFunctionIndex(argsArray) {\n    for(let i=0; i<argsArray.length; i++){\n        if (typeof argsArray[i] === 'function') {\n            return i;\n        }\n    }\n    return -1;\n}\n\nconst fileSystemLib = {\n    mountNativeFolder: async function (...args) {\n        return NativeFS.mountNativeFolder(...args);\n    },\n    readdir: function (...args) { // (path, options, callback)\n        let path = args[0];\n        if(Mounts.isMountPath(path) || Mounts.isMountSubPath(path)) {\n            return NativeFS.readdir(...args);\n        }\n        return filerLib.fs.readdir(...args);\n    },\n    stat: function (...args) { // (path, callback)\n        let path = args[0];\n        if(Mounts.isMountSubPath(path)) {\n            return NativeFS.stat(...args);\n        }\n        return filerLib.fs.stat(...args);\n    },\n    readFile: function (...args) { // (path, options, callback)\n        let path = args[0];\n        if(Mounts.isMountSubPath(path)) {\n            return NativeFS.readFile(...args);\n        }\n        return filerLib.fs.readFile(...args);\n    },\n    writeFile: function (...args) { // (path, data, options, callback)\n        let path = args[0];\n        function callbackInterceptor(...interceptedArgs) {\n            let err = interceptedArgs.length >= 1 ? interceptedArgs[0] : null;\n            if(!err){\n                FsWatch.reportChangeEvent(path);\n            }\n            if(args.originalCallback){\n                args.originalCallback(...interceptedArgs);\n            }\n        }\n        let callbackIndex = _getFirstFunctionIndex(args);\n        if(callbackIndex !== -1) {\n            args.originalCallback = args[callbackIndex];\n            args[callbackIndex] = callbackInterceptor;\n        }\n\n        if(Mounts.isMountSubPath(path)) {\n            return NativeFS.writeFile(...args);\n        }\n        return filerLib.fs.writeFile(...args);\n    },\n    mkdir: function (...args) { // (path, mode, callback)\n        let path = args[0];\n        function callbackInterceptor(...interceptedArgs) {\n            let err = interceptedArgs.length >= 1 ? interceptedArgs[0] : null;\n            if(!err){\n                FsWatch.reportCreateEvent(path);\n            }\n            if(args.originalCallback){\n                args.originalCallback(...interceptedArgs);\n            }\n        }\n        let callbackIndex = _getFirstFunctionIndex(args);\n        if(callbackIndex !== -1) {\n            args.originalCallback = args[callbackIndex];\n            args[callbackIndex] = callbackInterceptor;\n        }\n\n        if(Mounts.isMountSubPath(path)) {\n            return NativeFS.mkdir(...args);\n        }\n        return filerLib.fs.mkdir(...args);\n    },\n    rename: function (oldPath, newPath, cb) {\n        function callbackInterceptor(...args) {\n            let err = args.length >= 1 ? args[0] : null;\n            if(!err){\n                FsWatch.reportUnlinkEvent(oldPath);\n                FsWatch.reportCreateEvent(newPath);\n            }\n            if(cb){\n                cb(...args);\n            }\n        }\n\n        if(Mounts.isMountPath(oldPath) || Mounts.isMountPath(newPath)) {\n            throw new Errors.EPERM('Mount root directory cannot be deleted.');\n        } else if(Mounts.isMountSubPath(oldPath) && Mounts.isMountSubPath(newPath)) {\n            return NativeFS.rename(oldPath, newPath, callbackInterceptor);\n        }\n        return filerLib.fs.rename(oldPath, newPath, callbackInterceptor);\n    },\n    unlink: function (path, cb) {\n        function callbackInterceptor(...args) {\n            let err = args.length >= 1 ? args[0] : null;\n            if(!err){\n                FsWatch.reportUnlinkEvent(path);\n            }\n            if(cb){\n                cb(...args);\n            }\n        }\n\n        if(Mounts.isMountPath(path)) {\n            throw new Errors.EPERM('Mount root directory cannot be deleted.');\n        } else if(Mounts.isMountSubPath(path)) {\n            return NativeFS.unlink(path, callbackInterceptor);\n        }\n        if (typeof path !== 'string') {\n            callbackInterceptor(new Errors.EINVAL('Invalid arguments.'));\n            return;\n        }\n        return filerShell.rm(path, { recursive: true }, callbackInterceptor);\n    },\n    copy: function (src, dst, cb) {\n        function callbackInterceptor(...args) {\n            let err = args.length >= 1 ? args[0] : null;\n            if(!err){\n                FsWatch.reportCreateEvent(dst);\n            }\n            if(cb){\n                cb(...args);\n            }\n        }\n\n        if(Mounts.isMountSubPath(src) && Mounts.isMountSubPath(dst)) {\n            return NativeFS.copy(src, dst, callbackInterceptor);\n        } else if(!Mounts.isMountSubPath(src) && !Mounts.isMountSubPath(dst)) {\n            return filerCopy(src, dst, callbackInterceptor);\n        }\n        throw new Errors.ENOSYS('Phoenix fs copy across filer and native not yet supported');\n    },\n    showSaveDialog: function () {\n        throw new Errors.ENOSYS('Phoenix fs showSaveDialog function not yet supported.');\n    },\n    watch: function (...args) {\n        return FsWatch.watch(...args);\n    },\n    unwatch: function (...args) {\n        return FsWatch.unwatch(...args);\n    },\n    unwatchAll: function (...args) {\n        return FsWatch.unwatchAll(...args);\n    },\n    moveToTrash: function () {\n        throw new Errors.ENOSYS('Phoenix fs moveToTrash function not yet supported.');\n    },\n    mkdirs: function (path, mode, recursive, callback) {\n        if (typeof recursive !== 'boolean') {\n            callback = recursive;\n            recursive = false;\n        }\n\n        if (typeof callback !== 'function') {\n            callback = function () {\n                // Do Nothing\n            };\n        }\n\n        if (!recursive) {\n            fileSystemLib.mkdir(path, mode, callback);\n        } else {\n            mkdir_p(fileSystemLib, path, mode, callback);\n        }\n    },\n    BYTE_ARRAY_ENCODING: NativeFS.BYTE_ARRAY_ENCODING,\n    ERR_NOT_FOUND: ERR_CODES.ERROR_CODES.ENOENT,\n    ERR_EISDIR: ERR_CODES.ERROR_CODES.EISDIR,\n    ERR_EINVAL: ERR_CODES.ERROR_CODES.EINVAL,\n    ERR_FILE_EXISTS: ERR_CODES.ERROR_CODES.EEXIST\n};\n\nfileSystemLib.copyFile = fileSystemLib.copy;\n\nexport default function initFsLib(Phoenix, FilerLib) {\n    filerLib = FilerLib;\n    filerShell = new filerLib.fs.Shell();\n    window.path = FilerLib.path;\n    window.fs = fileSystemLib;\n\n    _ensure_mount_directory();\n}\n"],"names":["$505970e6c1eacf0c$var$ERROR_CODES","ENOENT","UNKNOWN","OK","EOF","EADDRINFO","EACCES","EAGAIN","EADDRINUSE","EADDRNOTAVAIL","EAFNOSUPPORT","EALREADY","EBADF","EBUSY","ECONNABORTED","ECONNREFUSED","ECONNRESET","EDESTADDRREQ","EFAULT","EHOSTUNREACH","EINTR","EINVAL","EISCONN","EMFILE","EMSGSIZE","ENETDOWN","ENETUNREACH","ENFILE","ENOBUFS","ENOMEM","ENOTDIR","EISDIR","ENONET","ENOTCONN","ENOTSOCK","ENOTSUP","ENOSYS","EPIPE","EPROTO","EPROTONOSUPPORT","EPROTOTYPE","ETIMEDOUT","ECHARSET","EAIFAMNOSUPPORT","EAISERVICE","EAISOCKTYPE","ESHUTDOWN","EEXIST","ESRCH","ENAMETOOLONG","EPERM","ELOOP","EXDEV","ENOTEMPTY","ENOSPC","EIO","EROFS","ENODEV","ESPIPE","ECANCELED","$505970e6c1eacf0c$var$FS_ERROR_CODES","$505970e6c1eacf0c$var$ALL_ERRORS","errno","code","description","$505970e6c1eacf0c$var$ERRNO_TO_ERROR_MAP","$505970e6c1eacf0c$var$CODE_TO_ERROR_MAP","forEach","error","$505970e6c1eacf0c$var$ERR_CODES","ERROR_CODES","FS_ERROR_CODES","ALL_ERRORS","ERRNO_TO_ERROR_MAP","CODE_TO_ERROR_MAP","$505970e6c1eacf0c$var$Errors","e","split","errName","defaultMessage","FilerError","msg","path","Error","call","this","name","message","stack","prototype","Object","create","constructor","toString","pathInfo","$505970e6c1eacf0c$exports","ERR_CODES","Errors","$53cc2e000314a49f$exports","Constants","MOUNT_DEVICE_NAME","KIND_FILE","KIND_DIRECTORY","NODE_TYPE_FILE","NODE_TYPE_DIRECTORY","IDB_RW_TYPE","MOUNT_POINT_ROOT","$5d5bda998e954df2$var$STORE_NAME","$5d5bda998e954df2$var$MOUNT_POINTS_KEY","$5d5bda998e954df2$var$db","$5d5bda998e954df2$var$_currentMounts","async","$5d5bda998e954df2$var$_ensureDB","idb","openDB","upgrade","db","createObjectStore","$5d5bda998e954df2$export$2e2bcd8739ae039","addMountPoint","mountName","handle","tx","transaction","$parcel$interopDefault","store","objectStore","get","put","done","getMountPoints","refreshMountPoints","$aa3c82cc608bd675$var$MOUNT_POINT_CHANGED_NOTIFICATION","$aa3c82cc608bd675$var$_channel","$aa3c82cc608bd675$var$_setupBroadcastChannel","BroadcastChannel","console","warn","$aa3c82cc608bd675$var$_getPathIfAlreadyMounted","handleToMount","Promise","resolve","allMountPointResolutions","currentMounts","entries","push","isSameEntryPromise","isSameEntry","isSubEntryPromise","all","then","mountDetail","subPathList","existingMountName","subPath","join","$aa3c82cc608bd675$var$_resolveFileHandle","values","i","length","$aa3c82cc608bd675$var$_mountHandle","reject","$aa3c82cc608bd675$var$_getNewMountName","$aa3c82cc608bd675$var$_findLeafNode","currentNode","pathArray","currentIndex","callback","pathLength","childName","childDirHandle","childFileHandle","getDirectoryHandle","getFileHandle","e1","$aa3c82cc608bd675$var$getHandleFromPath","normalisedPath","pathNodes","mountPoint","fileHandle","options","mode","status","queryPermission","requestPermission","$aa3c82cc608bd675$var$_verifyOrRequestPermission","permitted","onmessage","event","data","$aa3c82cc608bd675$export$2e2bcd8739ae039","mountNativeFolder","optionalDirHandle","mountedPath","window","showDirectoryPicker","directoryHandle","mountPath","postMessage","catch","err","ENOTMOUNTED","finally","isMountPath","normalize","isMountSubPath","mntSubPathStart","startsWith","getHandleFromPath","getHandleFromPathIfPresent","$e1f0b8fa1ae2171c$var$_dateFromMs","ms","Date","Number","$e1f0b8fa1ae2171c$var$Stats","fileNode","devName","dev","node","id","type","size","nlinks","atime","mtime","ctime","atimeMs","mtimeMs","ctimeMs","version","basename","$e1f0b8fa1ae2171c$var$_getType","kind","isFile","isDirectory","isSymbolicLink","NODE_TYPE_SYMBOLIC_LINK","isSocket","isFIFO","isCharacterDevice","isBlockDevice","$e1f0b8fa1ae2171c$export$2e2bcd8739ae039","createStatObject","details","nativeFsHandle","file","getFile","lastModified","$e1f0b8fa1ae2171c$var$_getDetails","$93a77513e637ad12$var$_mkdir","paretDirHandle","dirName","$93a77513e637ad12$var$_getFileContents","encoding","buffer","arrayBuffer","$93a77513e637ad12$var$BYTE_ARRAY_ENCODING","decodedString","TextDecoder","decode","$93a77513e637ad12$var$_getDecodedString","$93a77513e637ad12$var$_validateFileOptions","enc","fileMode","flag","$93a77513e637ad12$var$_writeFileWithName","fileName","newFileHandle","writable","createWritable","write","close","$93a77513e637ad12$var$unlink","dirPath","dirname","baseName","dirHandle","entryNameToDelete","recursive","removeEntry","$93a77513e637ad12$var$_deleteEntry","$93a77513e637ad12$var$_getDestinationHandleForCopy","dst","srcBaseName","handleKindToCreate","dstBaseName","dstHandle","dstParentHandle","$93a77513e637ad12$var$_copyFileFromHandles","srcFileHandle","optionalName","srcFile","srcStream","stream","pipeTo","$93a77513e637ad12$var$_treeCopy","srcFolderHandle","dstFolderHandle","allDonePromises","key","srcHandle","$93a77513e637ad12$var$_copyFolderWithHandle","srcFileName","$93a77513e637ad12$var$copy","src","$93a77513e637ad12$var$_copyFileWithHandle","$93a77513e637ad12$export$2e2bcd8739ae039","args","mkdir","arguments","subdirName","readdir","mountedFolders","keys","dirEntryNames","$93a77513e637ad12$var$_listDir","stat","pathStat","readFile","writeFile","Buffer","isBuffer","from","unlink","copy","rename","oldPath","newPath","cb","setTimeout","BYTE_ARRAY_ENCODING","$37b095e0e8046d7a$var$_channel","$37b095e0e8046d7a$var$_watchListeners","define","r1","exports","module","platform","filepath","glob","matchOptions","dot","noext","matchBase","replace","minimatch","Minimatch","cache1","cache","cnt","set","k","v","max","GLOBSTAR","f","pop","qmark","star","reSpecials","reduce","c","slashSplit","ext","a","b","t","p","pattern","TypeError","nocomment","charAt","trim","match","obj","cacheKey","JSON","stringify","cached","regexp","negate","comment","empty","make","monkeyPatch","desc","getOwnPropertyDescriptor","String","orig","value","defineProperty","filter","list","defaults","def","m","_made","parseNegate","globSet","braceExpand","debug","globParts","map","s","si","parse","indexOf","negateOffset","nonegate","l","substr","nobrace","escaping","prefix","tail","numset","suf","start","end","inc","ii","ll","depth","member","addMember","FOR","addBraces","r","concat","ret","isSub","noglobstar","plType","stateChar","pl","re","hasMagic","nocase","patternListStack","inClass","reClassStart","classStart","patternStart","clearStateChar","len","reStart","cs","sp","SUBPARSE","slice","_","$1","$2","addPatternStart","globUnescape","flags","regExp","RegExp","_glob","_src","makeRe","twoStar","regExpEscape","ex","mm","nonull","partial","matchOne","flipNegate","fi","pi","fl","hit","fr","pr","WHILE","swallowee","toLowerCase","$37b095e0e8046d7a$var$_setupBroadcastChannel","$37b095e0e8046d7a$var$_isAnIgnoredPath","ignoreGlobList","$6e10eb9dcf3999a2$exports","$37b095e0e8046d7a$var$_processFsWatchEvent","broadcast","$37b095e0e8046d7a$var$_broadcastWatchEvent","listener","parent","child","relative","parentDirPath","entryName","$37b095e0e8046d7a$var$_triggerEvent","eventType","pathLib","log","$37b095e0e8046d7a$export$2e2bcd8739ae039","watch","changeCallback","unwatch","item","unwatchAll","reportUnlinkEvent","reportChangeEvent","reportCreateEvent","$e319fa88088e7e31$var$ERROR_CODES","$e319fa88088e7e31$require$ERR_CODES","$e319fa88088e7e31$var$_stat","fs","$e319fa88088e7e31$var$_mrdirIfNotPresent","$e319fa88088e7e31$var$_copyFileContents","writeErr","$e319fa88088e7e31$var$_copyTree","srcEntries","listing","$e319fa88088e7e31$var$_readDir","entry","entryPath","dstPath","$e319fa88088e7e31$var$copy","srcStat","$e319fa88088e7e31$require$Errors","dstStat","parentDir","dstFileName","dstFilePath","$e319fa88088e7e31$var$_copyFile","srcFolder","$e319fa88088e7e31$var$_copyFolder","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$e319fa88088e7e31$export$2e2bcd8739ae039","$d3c1734dacb01657$var$process","$d3c1734dacb01657$exports","$d3c1734dacb01657$var$defaultSetTimout","$d3c1734dacb01657$var$defaultClearTimeout","$d3c1734dacb01657$var$runTimeout","fun","clearTimeout","$d3c1734dacb01657$var$currentQueue","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","$d3c1734dacb01657$var$drainQueue","timeout","run","marker","$d3c1734dacb01657$var$runClearTimeout","$d3c1734dacb01657$var$Item","array","$d3c1734dacb01657$var$noop","nextTick","Array","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$fe07aa8563a4b855$var$filerLib","$fe07aa8563a4b855$var$filerShell","$fe07aa8563a4b855$var$mkdir_p","fsLib","position","parts","directory","$fe07aa8563a4b855$var$_getFirstFunctionIndex","argsArray","$fe07aa8563a4b855$var$fileSystemLib","callbackIndex","originalCallback","interceptedArgs","callbackInterceptor","rm","showSaveDialog","moveToTrash","mkdirs","ERR_NOT_FOUND","ERR_EISDIR","ERR_EINVAL","ERR_FILE_EXISTS","copyFile"],"version":3,"file":"fslib.js.map"}