<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Mocha Tests distribution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css"/>
    <script src="virtualfs.js"></script>
<!--    Comment above line and Uncomment below line if you want to get more debug symbols in web inspector.-->
<!--    <script src="virtualfs-debug.js"></script>-->
    <script>
        // Electron detection and setup
        if(window.electronAPI) {
            window.__ELECTRON__ = true;
        }
        window.addEventListener('keydown', function(event) {
            if (event.key === 'F5') {
                location.reload();
            }
        });
        if(window.showOpenFilePicker){
           window.supportsFsAccessAPIs = true;
        }
        if(window.__TAURI__ || window.__ELECTRON__) {
            window.supportsFsAccessAPIs = false; // use native fs apis directly
        }
        const TEST_TYPE_FS_ACCESS = "fs access";
        const TEST_TYPE_FILER = "filer";
        const TEST_TYPE_TAURI = "tauri"; // electron will reuse this. tauri is our native edge name(which includes electron)
        const TEST_TYPE_TAURI_WS = "tauriWs"; // electron will reuse this
        window.IS_WINDOWS = navigator.userAgent.includes('Windows');
    </script>
    <script>
        window.NODE_COMMANDS = {
            TERMINATE: "terminate",
            PING: "ping",
            GET_PORT: "getPort",
            HEART_BEAT: "heartBeat"
        };
        let command, child;
        let commandId = 0, pendingCommands = {};
        if(window.__TAURI__){
            window.__TAURI__.path.resolveResource("node-src/index.js").then(async nodeSrcPath=>{
                command = new window.__TAURI__.shell.Command('node', ['--inspect', nodeSrcPath]);
                command.on('close', data => {
                    window.isNodeTerminated = true;
                    console.log(`Node: command finished with code ${data.code} and signal ${data.signal}`)
                });
                command.on('error', error => console.error(`Node: command error: "${error}"`));
                command.stdout.on('data', line => {
                    if(line){
                        if(line.trim().startsWith("{")){
                            // its a js object
                            const jsonMsg = JSON.parse(line);
                            pendingCommands[jsonMsg.commandId].resolve(jsonMsg.message);
                            delete pendingCommands[jsonMsg.commandId];
                        } else {
                            console.log(`Node: ${line}`);
                        }
                    }
                });
                command.stderr.on('data', line => console.error(`Node: ${line}`));
                child = await command.spawn();

                window.execNode = function (commandCode) {
                    const newCommandID = commandId ++;
                    child.write(JSON.stringify({commandCode: commandCode, commandId: newCommandID}) + "\n");
                    let resolveP, rejectP;
                    const promise = new Promise((resolve, reject) => {resolveP = resolve; rejectP=reject;});
                    pendingCommands[newCommandID]= {resolve:resolveP, reject:rejectP};
                    return promise;
                }
                execNode(NODE_COMMANDS.GET_PORT)
                    .then(async message=>{
                        window.nodeWSEndpoint = `ws://localhost:${message.port}/phoenixFS`;
                        await fs.setNodeWSEndpoint(`ws://localhost:${message.port}/phoenixFS`);
                        window.isNodeSetup = true;
                    });
                setInterval(()=>{
                    if(!window.isNodeTerminated) {
                        execNode(NODE_COMMANDS.HEART_BEAT);
                    }
                },10000);
            }). catch(console.error);
        }
        // Electron detection and setup
        if(window.electronAPI){
            window.electronAPI.documentDir().then(d => console.log("Electron documentsDir:", d));
            window.electronAPI.appLocalDataDir().then(d => console.log("Electron appDataDir:", d));
            window.electronAPI.getAppPath().then(appPath => {
                const nodeSrcPath = appPath + "/../src-tauri/node-src/index.js";
                return window.electronAPI.spawnProcess('node', ['--inspect', nodeSrcPath]);
            }).then(async (myInstanceId) => {
                window.electronAPI.onProcessClose((instanceId, data) => {
                    if(instanceId !== myInstanceId) return;
                    window.isNodeTerminated = true;
                    console.log(`Node: command finished with code ${data.code} and signal ${data.signal}`);
                });
                window.electronAPI.onProcessStdout((instanceId, line) => {
                    if(instanceId !== myInstanceId) return;
                    if(line){
                        if(line.trim().startsWith("{")){
                            const jsonMsg = JSON.parse(line);
                            pendingCommands[jsonMsg.commandId].resolve(jsonMsg.message);
                            delete pendingCommands[jsonMsg.commandId];
                        } else {
                            console.log(`Node: ${line}`);
                        }
                    }
                });
                window.electronAPI.onProcessStderr((instanceId, line) => {
                    if(instanceId !== myInstanceId) return;
                    console.error(`Node: ${line}`);
                });

                window.execNode = function (commandCode) {
                    const newCommandID = commandId++;
                    window.electronAPI.writeToProcess(myInstanceId,
                        JSON.stringify({commandCode: commandCode, commandId: newCommandID}) + "\n"
                    );
                    let resolveP, rejectP;
                    const promise = new Promise((resolve, reject) => {resolveP = resolve; rejectP = reject;});
                    pendingCommands[newCommandID] = {resolve: resolveP, reject: rejectP};
                    return promise;
                };

                execNode(NODE_COMMANDS.GET_PORT)
                    .then(async message => {
                        window.nodeWSEndpoint = `ws://localhost:${message.port}/phoenixFS`;
                        await fs.setNodeWSEndpoint(`ws://localhost:${message.port}/phoenixFS`);
                        window.isNodeSetup = true;
                    });

                setInterval(() => {
                    if(!window.isNodeTerminated) {
                        execNode(NODE_COMMANDS.HEART_BEAT);
                    }
                }, 10000);
            }).catch(console.error);
        }
    </script>
    <script src="thirdparty/chai@4.2.0.js"></script>
    <script src="thirdparty/mocha@10.3.0.js"></script>

    <script class="mocha-init">
        mocha.setup('bdd');
        mocha.globals(['isNodeTerminated', 'isNodeSetup', 'execNode', 'nodeWSEndpoint']);
        mocha.checkLeaks();
    </script>

    <script src="testInit.js"></script>
    <script src="test-node.browser.js"></script>
    <script src="test-dir.browser.js"></script>
    <script src="test-file.browser.js"></script>
    <script src="test-copy.browser.js"></script>
    <script src="test.worker.js"></script>
    <script src="test-getPlatformPath-api.browser.js"></script>
    <script src="test-watcher.browser.js"></script>
    <script class="mocha-exec">
        window.virtualTestPath = '/test-phoenix-fs';

        function observeRunStatus(runner) {
            if(!window.__TAURI__ && !window.__ELECTRON__){
                return;
            }

            let consoleLogToShell;
            let quitIfNeeded;

            if(window.__TAURI__) {
                console.log("setting up tauri test reporters to log to system console.");
                consoleLogToShell = function(message) {
                    return window.__TAURI__.invoke("console_log", {message});
                };
                quitIfNeeded = async function(exitStatus) {
                    if(!location.href.startsWith("http://localhost:8081/test/")) {
                        // during development, we dont switch off node at end of tests for ease of development and debug
                        fs.stopNodeWSEndpoint();
                        window.execNode(NODE_COMMANDS.TERMINATE);
                        await waitForTrue(()=>{return window.isNodeTerminated;},1000);
                    }
                    window.__TAURI__.cli.getMatches().then(matches=>{
                        if(matches?.args["quit-when-done"]?.occurrences) {
                            window.__TAURI__.process.exit(exitStatus)
                        }
                    });
                };
            } else if(window.__ELECTRON__) {
                console.log("setting up electron test reporters to log to system console.");
                consoleLogToShell = function(message) {
                    window.electronAPI.consoleLog(message);
                    return Promise.resolve();
                };
                quitIfNeeded = async function(exitStatus) {
                    if(!location.href.startsWith("http://localhost:8081/test/")) {
                        // during development, we dont switch off node at end of tests for ease of development and debug
                        fs.stopNodeWSEndpoint();
                        window.execNode(NODE_COMMANDS.TERMINATE);
                        await waitForTrue(() => { return window.isNodeTerminated; }, 1000);
                    }
                    window.electronAPI.getCliArgs().then(argv => {
                        if(argv.includes('--quit-when-done') || argv.includes('-q')) {
                            window.electronAPI.quitApp(exitStatus);
                        }
                    });
                };
            }

            runner.on('end', function() {
                const stats = runner.stats;
                if (stats.failures > 0) {
                    consoleLogToShell(`\u2716 ${stats.failures} tests failed of ${stats.tests} tests in ${stats.suites} suites!. Time: ${stats.duration} ms`)
                        .finally(()=>{
                            quitIfNeeded(1);
                        });
                } else {
                    consoleLogToShell(`\u2714 All(${stats.tests}) tests passed in in ${stats.suites} suites! Time: ${stats.duration} ms`)
                        .finally(()=>{
                            quitIfNeeded(0);
                        });
                }
            });
            runner.on('suite', (suite) => {
                consoleLogToShell(`\nSuite started: ${suite.title}\n`);
            });

            runner.on('pass', function(test) {
                consoleLogToShell(`\u2714 '${test.title}' passed! ( ${test.duration}ms )`);
            });

            runner.on('fail', function(test, err) {
                consoleLogToShell(`\u2716 Test '${test.title}' failed after ( ${test.duration}ms )! \nReason: ${err.message} \n${err.stack}`);
            });

            runner.on('pending', function(test) {
                consoleLogToShell(`Test '${test.title}' was skipped.`);
            });
        }
        function openFolderAndRunTests() {
            function mountNative() {
                fs.mountNativeFolder((err, mountTestPath)=>{
                    if(!mountTestPath[0]) return;
                    localStorage.setItem('mountTestPath', mountTestPath[0]);
                    document.getElementById('openFolderButton').style = "display:none";
                    window.mountTestPath = `${mountTestPath[0]}/test`;
                    observeRunStatus(mocha.run());
                });
            }

            let mountTestPath = localStorage.getItem('mountTestPath');
            if(!mountTestPath) {
                mountNative();
                return;
            }
            fs.readdir(mountTestPath, (err, contents)=>{
                console.log("Checking if any mounted paths exists: ",err, contents);
                if(err){
                    mountNative();
                    return;
                }
                window.mountTestPath = `${mountTestPath}/test-phoenix-fs`;
                document.getElementById('openFolderButton').style = "display:none";
                observeRunStatus(mocha.run());
            });
        }
        function runNativeAppTests() {
            if(window.__TAURI__ || window.__ELECTRON__){
                window.tauriTests = true; // reuse tauriTests flag for both
                console.log("Native app env detected. Running native app tests.");
                document.getElementById('openFolderButton').style = "display:none";
                // Wait for Node WebSocket setup before running tests
                function waitAndRun() {
                    if(window.isNodeSetup) {
                        observeRunStatus(mocha.run());
                    } else {
                        setTimeout(waitAndRun, 100);
                    }
                }
                waitAndRun();
            }
        }
    </script>
</head>
<body onload="runNativeAppTests()">
<div id="mocha"></div>
<button id="openFolderButton" onclick="openFolderAndRunTests()">Open any blank folder to start tests. Warning - folder contents will be deleted!!!!</button>
</body>
</html>
